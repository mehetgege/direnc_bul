<!DOCTYPE html>
<html lang="tr" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTIMATE TRADING KOMUTA MERKEZİ</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>

    <style>
        :root {
            --background-dark: #0d1117; --panel-bg-dark: #161b22; --text-main-dark: #c9d1d9; --text-secondary-dark: #8b949e; --border-color-dark: #30363d; --input-bg-dark: #010409; --hover-bg-dark: #21262d; --primary-dark: #58a6ff;
            --background-light: #ffffff; --panel-bg-light: #f6f8fa; --text-main-light: #24292f; --text-secondary-light: #57606a; --border-color-light: #d0d7de; --input-bg-light: #f0f2f5; --hover-bg-light: #e8eaed; --primary-light: #0969da;
            --war-mode-bg: linear-gradient(145deg, #4d0000 0%, #000000 75%); --war-mode-panel-bg: rgba(255, 0, 0, 0.08); --war-mode-border: #8B0000; --war-mode-text: #ff5858; --war-mode-primary: #ffc107;
            --positive: #28a745; --negative: #dc3545; --neutral: #ffc107;
        }
        [data-theme="light"] { --background: var(--background-light); --panel-bg: var(--panel-bg-light); --text-main: var(--text-main-light); --text-secondary: var(--text-secondary-light); --border-color: var(--border-color-light); --input-bg: var(--input-bg-light); --hover-bg: var(--hover-bg-light); --primary: var(--primary-light); }
        [data-theme="dark"] { --background: var(--background-dark); --panel-bg: var(--panel-bg-dark); --text-main: var(--text-main-dark); --text-secondary: var(--text-secondary-dark); --border-color: var(--border-color-dark); --input-bg: var(--input-bg-dark); --hover-bg: var(--hover-bg-dark); --primary: var(--primary-dark); }
        [data-theme="war"] { --background: var(--war-mode-bg); --panel-bg: var(--war-mode-panel-bg); --text-main: var(--war-mode-text); --text-secondary: #ffaaaa; --border-color: var(--war-mode-border); --input-bg: rgba(255, 255, 255, 0.05); --hover-bg: rgba(255, 255, 255, 0.1); --primary: var(--war-mode-primary); }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Roboto Mono', monospace; font-size: 12px; background: var(--background); color: var(--text-main); overflow: hidden; transition: background 0.5s, color 0.5s; }
        .container { display: flex; flex-direction: column; height: 100vh; padding: 5px; }
        .header { display: flex; justify-content: space-between; align-items: center; padding: 5px 15px; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; flex-shrink: 0; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
        .logo { font-weight: 700; font-size: 16px; color: var(--primary); }
        .controls { display: flex; gap: 8px; align-items: center; }
        .form-control { background: var(--input-bg); color: var(--text-main); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-family: 'Roboto Mono', monospace; }
        .status { display: flex; align-items: center; gap: 5px; font-size: 11px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--negative); transition: background-color 0.5s; }
        .status-dot.online { background: var(--positive); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 #28a745b3; } 70% { box-shadow: 0 0 0 6px #28a74500; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        [data-theme="war"] .status-dot.online { background: var(--war-mode-primary); animation: war-pulse 1s infinite; }
        @keyframes war-pulse { 0% { box-shadow: 0 0 0 0 #ffc107b3; } 70% { box-shadow: 0 0 0 6px #ffc10700; } 100% { box-shadow: 0 0 0 0 #ffc10700; } }
        .btn { padding: 4px 12px; border: 1px solid var(--border-color); background: var(--panel-bg); color: var(--text-main); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .btn:hover { background: var(--hover-bg); border-color: var(--primary); }
        .btn-success { background: var(--positive); color: white; border-color: var(--positive); } .btn-danger { background: var(--negative); color: white; border-color: var(--negative); }
        .main-grid { display: grid; grid-template-columns: 280px 1fr 320px; gap: 5px; flex-grow: 1; margin-top: 5px; overflow: hidden; }
        .panel { display: flex; flex-direction: column; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; overflow: hidden; }
        .panel-title { font-weight: 700; font-size: 13px; color: var(--primary); padding: 8px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .panel-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
        .settings-group { margin-bottom: 15px; } .form-group { margin-bottom: 8px; } .form-label { display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
        .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 12px; padding: 4px 0;}
        .center-panel { display: grid; grid-template-rows: auto 1fr; gap: 5px; padding: 0 !important; }
        .price-display { display: grid; grid-template-columns: repeat(4, 1fr); padding: 8px; text-align: center; }
        .price-item .price-label { color: var(--text-secondary); } .price-item .price-value { font-size: 18px; font-weight: 700; }
        .data-container { display: grid; grid-template-rows: 1fr auto; overflow: hidden; } .data-grid { position: relative; overflow: hidden; } #live-chart { width: 100%; height: 100%; }
        .heatmap-container { display: grid; grid-template-rows: auto 1fr; border-top: 1px solid var(--border-color); }
        #orderbook-heatmap { width: 100%; height: 100%; display: block; }
        .data-table-container { width: 100%; height: 100%; overflow: auto; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .data-table th, .data-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap;}
        .data-table th { font-weight: 700; position: sticky; top: 0; background: var(--panel-bg); z-index: 10;}
        .data-table tr:hover { background: var(--hover-bg); }
        .signal-buy { background-color: #28a74514; } .signal-sell { background-color: #dc354514; }
        .signal-tp { background-color: #28a74533; } .signal-sl { background-color: #dc354533; }
        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border-color); font-size: 12px; }
        .stat-item:last-child { border-bottom: none; } .stat-label { color: var(--text-secondary); } .stat-value { font-weight: 700; }
        .btn-sm { padding: 1px 4px; font-size: 9px; margin-left: 4px; border-radius: 3px; cursor: pointer;}
        ::-webkit-scrollbar { width: 6px; height: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--text-secondary); border-radius: 3px; }
        .notifications { position: fixed; bottom: 15px; right: 15px; z-index: 2000; width: 320px; }
        .notification { background: var(--panel-bg); border: 1px solid var(--border-color); border-left-width: 5px; border-radius: 4px; padding: 12px; font-size: 13px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); margin-top: 10px; }
        .notification.success { border-left-color: var(--positive); } .notification.danger { border-left-color: var(--negative); } .notification.warning { border-left-color: var(--neutral); }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="logo">KOMUTA MERKEZİ</div>
            <div class="controls">
                <select id="symbol-select" class="form-control"></select>
                <select id="timeframe-select" class="form-control">
                    <option value="1m">1m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option>
                </select>
                <div class="status">
                    <div id="connection-status" class="status-dot"></div>
                    <span id="connection-text">BAĞLANTI YOK</span>
                </div>
                <button id="theme-toggle-btn" class="btn">Tema</button>
                <button id="start-btn" class="btn btn-success">SİSTEMİ BAŞLAT</button>
                <button id="stop-btn" class="btn btn-danger" disabled>DURDUR</button>
            </div>
        </header>

        <main class="main-grid">
            <aside id="settings-panel" class="panel">
                <div class="panel-title">AYARLAR & STRATEJİLER</div>
                <div class="panel-content">
                    <div class="settings-group">
                        <div class="form-group"><label class="form-label">Min. Uyum Skoru (1-10)</label><input type="range" id="confluence-threshold" class="form-control" min="1" max="10" value="3" step="1"></div>
                        <div class="form-group"><label class="form-label">RSI Periyodu</label><input type="number" id="param-rsi-period" class="form-control" value="14"></div>
                        <div class="form-group"><label class="form-label">ATR Periyodu</label><input type="number" id="param-atr-period" class="form-control" value="14"></div>
                        <div class="form-group"><label class="form-label">Duvar Tespiti (BTC)</label><input type="number" id="param-wall-btc" class="form-control" value="20"></div>
                        <div class="form-group"><label class="form-label">Risk/Ödül Oranı (R/R)</label><input type="number" id="param-rr-ratio" class="form-control" value="1.5" step="0.1"></div>
                    </div>
                    <div id="strategy-toggles" class="settings-group"></div>
                </div>
            </aside>

            <section class="center-panel panel">
                <div class="price-display">
                     <div class="price-item"><div class="price-label">FİYAT</div><div class="price-value" id="current-price">-</div></div>
                    <div class="price-item"><div class="price-label">24s DEĞİŞİM</div><div class="price-value" id="price-change-24h">-</div></div>
                    <div class="price-item"><div class="price-label">24s HACİM</div><div class="price-value" id="volume-24h">-</div></div>
                    <div class="price-item"><div class="price-label">VOLATİLİTE (ATR)</div><div class="price-value" id="atr-value">-</div></div>
                </div>
                <div class="data-container">
                    <div class="data-grid"><div id="live-chart"></div></div>
                     <div class="heatmap-container">
                        <div class="panel-title" style="border-top: 1px solid var(--border-color); border-bottom: none;">EMİR DEFTERİ ISI HARİTASI</div>
                        <canvas id="orderbook-heatmap"></canvas>
                    </div>
                </div>
            </section>
            
            <aside id="analytics-panel" class="panel">
                <div class="panel-title">SİNYALLER & ANALİZ</div>
                <div class="panel-content" style="padding:0; display: flex; flex-direction: column;">
                    <div class="data-table-container" style="flex: 3;">
                        <table class="data-table">
                            <thead><tr><th>Zaman</th><th>Tip</th><th>Fiyat</th><th>TP</th><th>SL</th><th>Skor</th><th>İşlem</th></tr></thead>
                            <tbody id="signals-body"></tbody>
                        </table>
                    </div>
                    <div class="analytics-container" style="flex: 1; padding: 10px; border-top: 2px solid var(--border-color);">
                        <div class="panel-title" style="padding:0 0 8px 0; border:none;">GENEL ANALİZ</div>
                        <div id="stats-container"></div>
                    </div>
                </div>
            </aside>
        </main>
    </div>
    
    <div id="notifications-container" class="notifications"></div>
    <audio id="combat-mode-audio" src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-alarm-442.mp3" preload="auto"></audio>

<script>
    /**
     * =================================================================
     * GÖRSELLEŞTİRME YÖNETİCİLERİ (MANAGER CLASSES)
     * =================================================================
     */

    class ChartManager {
        constructor(chartContainerId) {
            this.chartContainer = document.getElementById(chartContainerId);
            if (!this.chartContainer) throw new Error("Chart container bulunamadı!");
            this.chart = null; this.series = {}; this.signalMarkers = [];
            this._initChart();
        }
        _initChart() {
            this.chart = LightweightCharts.createChart(this.chartContainer, this._getChartOptions());
            this.series.candles = this.chart.addCandlestickSeries(this._getCandlestickOptions());
            this.series.volume = this.chart.addHistogramSeries(this._getVolumeOptions());
            window.addEventListener('resize', () => { if (this.chart && this.chartContainer.clientWidth > 0) this.chart.resize(this.chartContainer.clientWidth, this.chartContainer.clientHeight); });
        }
        updateTheme() {
            if(!this.chart) return;
            this.chart.applyOptions(this._getChartOptions());
            this.series.candles.applyOptions(this._getCandlestickOptions());
            this.series.volume.applyOptions(this._getVolumeOptions());
        }
        setData(candles) {
            if (!this.series.candles) return;
            const candleData = candles.map(c => ({ time: c.time / 1000, open: c.open, high: c.high, low: c.low, close: c.close }));
            const volumeData = candles.map(c => ({ time: c.time / 1000, value: c.volume, color: c.close >= c.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' }));
            this.series.candles.setData(candleData);
            this.series.volume.setData(volumeData);
            this.chart.timeScale().fitContent();
        }
        updateRealtime(kline) {
             if (!this.series.candles) return;
             const candle = { time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c) };
             const volume = { time: kline.t / 1000, value: parseFloat(kline.v), color: candle.close >= candle.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' };
             this.series.candles.update(candle);
             this.series.volume.update(volume);
        }
        addSignalMarker(signal) {
            if (!this.series.candles) return;
            const styles = getComputedStyle(document.body);
            const marker = {
                time: signal.timestamp / 1000,
                position: signal.direction === 'buy' ? 'belowBar' : 'aboveBar',
                color: signal.direction === 'buy' ? styles.getPropertyValue('--positive').trim() : styles.getPropertyValue('--negative').trim(),
                shape: signal.direction === 'buy' ? 'arrowUp' : 'arrowDown',
                text: `Skor: ${signal.score} @ ${this._formatMarkerPrice(signal.price)}`
            };
            this.signalMarkers.push(marker);
            this.series.candles.setMarkers(this.signalMarkers);
        }
        clearMarkers() {
            if (!this.series.candles) return;
            this.signalMarkers = [];
            this.series.candles.setMarkers([]);
        }
        _formatMarkerPrice(price) { if (price > 1000) return price.toFixed(2); if (price > 1) return price.toFixed(3); return price.toFixed(4); }
        _getChartOptions() {
            const styles = getComputedStyle(document.body);
            return {
                width: this.chartContainer.clientWidth, height: this.chartContainer.clientHeight,
                layout: { backgroundColor: 'transparent', textColor: styles.getPropertyValue('--text-main').trim(), fontFamily: "'Roboto Mono', monospace" },
                grid: { vertLines: { color: styles.getPropertyValue('--border-color').trim() }, horzLines: { color: styles.getPropertyValue('--border-color').trim() } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: styles.getPropertyValue('--border-color').trim(), timeVisible: true, secondsVisible: false, rightOffset: 10 }
            };
        }
        _getCandlestickOptions() {
             const styles = getComputedStyle(document.body);
             return { upColor: styles.getPropertyValue('--positive').trim(), downColor: styles.getPropertyValue('--negative').trim(), borderVisible: false, wickUpColor: styles.getPropertyValue('--positive').trim(), wickDownColor: styles.getPropertyValue('--negative').trim() };
        }
        _getVolumeOptions() { return { priceFormat: { type: 'volume' }, priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 } }; }
    }

    class HeatmapManager {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            if (!this.canvas) throw new Error("Heatmap canvas bulunamadı!");
            this.ctx = this.canvas.getContext('2d');
            this._resizeCanvas();
            window.addEventListener('resize', () => this._resizeCanvas());
        }
        draw(orderBook, symbolPrice) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); return; };
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            const asks = orderBook.asks.slice().reverse(); const bids = orderBook.bids;
            const allLevels = [...bids, ...asks]; const maxQty = Math.max(...allLevels.map(l => l[1]));
            this._drawSection(asks, 'asks', maxQty, symbolPrice); this._drawSection(bids, 'bids', maxQty, symbolPrice);
        }
        updateTheme() { /* No action needed */ }
        _drawSection(levels, type, maxQty, symbolPrice) {
            const styles = getComputedStyle(document.body);
            const baseColor = type === 'asks' ? styles.getPropertyValue('--negative').trim() : styles.getPropertyValue('--positive').trim();
            const heightPerLevel = (this.canvas.height / 2) / levels.length;
            const priceDecimals = this._getDecimalPlaces(symbolPrice);
            levels.forEach((level, index) => {
                const [price, qty] = level;
                const intensity = Math.min(Math.sqrt(qty / maxQty), 1.0);
                this.ctx.fillStyle = this._hexToRgba(baseColor, intensity * 0.6 + 0.1);
                const y = type === 'asks' ? index * heightPerLevel : (this.canvas.height / 2) + (index * heightPerLevel);
                const barWidth = this.canvas.width * intensity;
                this.ctx.fillRect(0, y, barWidth, heightPerLevel);
                this.ctx.fillStyle = intensity > 0.5 ? '#FFFFFF' : styles.getPropertyValue('--text-secondary').trim();
                this.ctx.font = '10px "Roboto Mono"'; this.ctx.textAlign = 'left';
                this.ctx.fillText(`${(qty).toFixed(2)} @ ${price.toFixed(priceDecimals)}`, 10, y + heightPerLevel - 3);
            });
        }
        _getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _hexToRgba(hex, alpha) {
            if(!hex.startsWith('#')) return `rgba(120,120,120,${alpha})`;
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        _resizeCanvas() { this.canvas.width = this.canvas.parentElement.clientWidth; this.canvas.height = this.canvas.parentElement.clientHeight; }
    }

    /**
     * =================================================================
     * STRATEJİ MOTORLARI & CONFLUENCE ENGINE
     * =================================================================
     */
    class Strategy {
        constructor(bot, name) { this.bot = bot; this.name = name; this.displayName = this._getDisplayName(name); this.lastProposalTime = {}; this.PROPOSAL_COOLDOWN_MS = 10000; }
        propose(symbol, direction, reason, score = 1) {
            const now = Date.now(); const key = `${symbol}-${direction}`;
            if (now - (this.lastProposalTime[key] || 0) < this.PROPOSAL_COOLDOWN_MS) return;
            this.bot.confluenceEngine.propose(this.name, direction, reason, score);
            this.lastProposalTime[key] = now;
        }
        _getDisplayName(name) { return name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); }
        analyzeOrderBook(orderBook) {}
        processTrade(trade) {}
        periodicAnalyze() {}
    }

    class WallBounceStrategy extends Strategy {
        constructor(bot) { super(bot, 'wallBounce'); this.DISTANCE_THRESHOLD_PERCENT = 0.05 / 100; }
        analyzeOrderBook(orderBook) {
            const currentPrice = this.bot.marketData.price; if (!currentPrice) return;
            const btcPrice = this.bot.marketData.btcPrice || 70000;
            const wallQuantityThreshold = (this.bot.settings.params.wallBtc * btcPrice) / currentPrice;
            for (const [price, qty] of orderBook.asks) { if (qty > wallQuantityThreshold) { const distance = (price - currentPrice) / currentPrice; if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { this.propose(this.bot.currentSymbol, 'sell', `Satış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; } } }
            for (const [price, qty] of orderBook.bids) { if (qty > wallQuantityThreshold) { const distance = (currentPrice - price) / currentPrice; if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { this.propose(this.bot.currentSymbol, 'buy', `Alış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; } } }
        }
    }
    class VelocityScalpingStrategy extends Strategy {
        constructor(bot) { super(bot, 'velocityScalping'); this.pricePoints = []; this.VELOCITY_WINDOW_MS = 2000; this.MIN_POINTS = 20; this.VELOCITY_THRESHOLD_PERCENT = 0.10 / 100; }
        processTrade(trade) {
            const now = Date.now(); this.pricePoints.push({ time: now, price: trade.price }); this.pricePoints = this.pricePoints.filter(p => now - p.time < this.VELOCITY_WINDOW_MS); if (this.pricePoints.length < this.MIN_POINTS) return;
            const firstPoint = this.pricePoints[0]; const lastPoint = this.pricePoints[this.pricePoints.length - 1]; const priceChange = (lastPoint.price - firstPoint.price) / firstPoint.price;
            if (priceChange > this.VELOCITY_THRESHOLD_PERCENT) { this.propose(this.bot.currentSymbol, 'buy', `Fiyat Hızı: +${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; } 
            else if (priceChange < -this.VELOCITY_THRESHOLD_PERCENT) { this.propose(this.bot.currentSymbol, 'sell', `Fiyat Hızı: ${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; }
        }
    }
    class RsiDivergenceStrategy extends Strategy {
        constructor(bot) { super(bot, 'rsiDivergence'); }
        periodicAnalyze() {
            const candles = this.bot.candles; const rsiValues = this.bot.indicators.rsi; const lookback = this.bot.settings.params.rsiPeriod;
            if (!rsiValues || rsiValues.length < lookback || !candles || candles.length < lookback) return;
            const lastCandle = candles[candles.length - 1]; const prevCandle = candles[candles.length - lookback]; 
            const lastRsi = rsiValues[rsiValues.length - 1]; const prevRsi = rsiValues[rsiValues.length - lookback];
            if (!lastCandle || !prevCandle || !lastRsi || !prevRsi) return;
            if (lastCandle.high > prevCandle.high && lastRsi < prevRsi) { this.propose(this.bot.currentSymbol, 'sell', 'RSI Ayı Uyuşmazlığı', 5); }
            if (lastCandle.low < prevCandle.low && lastRsi > prevRsi) { this.propose(this.bot.currentSymbol, 'buy', 'RSI Boğa Uyuşmazlığı', 5); }
        }
    }
    class OrderFlowMomentumStrategy extends Strategy {
        constructor(bot) { super(bot, 'orderFlowMomentum'); this.trades = []; this.WINDOW_MS = 5000; }
        processTrade(trade) {
            const now = Date.now(); this.trades.push(trade); this.trades = this.trades.filter(t => now - t.timestamp < this.WINDOW_MS); if (this.trades.length < 50) return;
            const buys = this.trades.filter(t => !t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0); const sells = this.trades.filter(t => t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0);
            const total = buys + sells; if (total === 0) return; if (buys / total > 0.7) { this.propose(this.bot.currentSymbol, 'buy', `Alıcı Akışı: %${(buys / total * 100).toFixed(0)}`, 4); this.trades = []; }
            else if (sells / total > 0.7) { this.propose(this.bot.currentSymbol, 'sell', `Satıcı Akışı: %${(sells / total * 100).toFixed(0)}`, 4); this.trades = []; }
        }
    }
    class LiquidityGapsStrategy extends Strategy {
        constructor(bot) { super(bot, 'liquidityGaps'); this.GAP_THRESHOLD_PERCENT = 0.1 / 100; }
        analyzeOrderBook(orderBook) {
            for (let i = 0; i < orderBook.asks.length - 1; i++) { const gap = orderBook.asks[i + 1][0] - orderBook.asks[i][0]; if ((gap / orderBook.asks[i][0]) > this.GAP_THRESHOLD_PERCENT) { this.propose(this.bot.currentSymbol, 'buy', `Likidite Boşluğu ${orderBook.asks[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.asks[i][0]))}`, 3); return; } }
            for (let i = 0; i < orderBook.bids.length - 1; i++) { const gap = orderBook.bids[i][0] - orderBook.bids[i + 1][0]; if ((gap / orderBook.bids[i][0]) > this.GAP_THRESHOLD_PERCENT) { this.propose(this.bot.currentSymbol, 'sell', `Likidite Boşluğu ${orderBook.bids[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.bids[i][0]))}`, 3); return; } }
        }
    }
    // Diğer stratejilerin iskeletleri (henüz içleri boş)
    class FibonacciRetracementStrategy extends Strategy { constructor(bot) { super(bot, 'fibonacciRetracement'); } periodicAnalyze() {} }
    class VolumeProfileStrategy extends Strategy { constructor(bot) { super(bot, 'volumeProfile'); } periodicAnalyze() {} }
    class SmartMoneyConceptsStrategy extends Strategy { constructor(bot) { super(bot, 'smartMoneyConcepts'); } processTrade(trade){} }
    class DivergenceDetectionStrategy extends Strategy { constructor(bot) { super(bot, 'divergenceDetection'); } periodicAnalyze() {} }
    class BreakoutPatternStrategy extends Strategy { constructor(bot) { super(bot, 'breakoutPattern'); } periodicAnalyze() {} }
    class SupportResistanceStrategy extends Strategy { constructor(bot) { super(bot, 'supportResistance'); } periodicAnalyze() {} }
    class MarketStructureStrategy extends Strategy { constructor(bot) { super(bot, 'marketStructure'); } periodicAnalyze() {} }
    class InstitutionalOrderFlowStrategy extends Strategy { constructor(bot) { super(bot, 'institutionalOrderFlow'); } analyzeOrderBook(orderBook){} }
    class MicroSpreadArbitrageStrategy extends Strategy { constructor(bot) { super(bot, 'microSpreadArbitrage'); } analyzeOrderBook(orderBook){} }

    class ConfluenceEngine {
        constructor(bot) { this.bot = bot; this.proposals = []; this.PROPOSAL_TIMEOUT_MS = 3000; this.SIGNAL_COOLDOWN_MS = 15000; this.lastSignalTime = 0; }
        propose(strategy, direction, reason, score) {
            const now = Date.now();
            this.proposals = this.proposals.filter(p => !(p.strategy === strategy));
            this.proposals.push({ strategy, direction, reason, score, timestamp: now });
            this.checkConfluence();
        }
        checkConfluence() {
            const now = Date.now();
            if (now - this.lastSignalTime < this.SIGNAL_COOLDOWN_MS) return;
            this.proposals = this.proposals.filter(p => now - p.timestamp < this.PROPOSAL_TIMEOUT_MS);
            const buyProposals = this.proposals.filter(p => p.direction === 'buy');
            const sellProposals = this.proposals.filter(p => p.direction === 'sell');
            const buyScore = buyProposals.reduce((sum, p) => sum + p.score, 0);
            const sellScore = sellProposals.reduce((sum, p) => sum + p.score, 0);
            const minThreshold = this.bot.settings.confluenceThreshold;
            if (buyScore >= minThreshold && buyScore > sellScore) { this.generateFinalSignal('buy', buyProposals); }
            else if (sellScore >= minThreshold && sellScore > buyScore) { this.generateFinalSignal('sell', sellProposals); }
        }
        generateFinalSignal(direction, proposals) {
            const totalScore = proposals.reduce((sum, p) => sum + p.score, 0);
            const contributingStrats = proposals.map(p => this.bot.strategies[p.strategy].displayName).join(', ');
            const signal = { id: `sig_${Date.now()}`, timestamp: Date.now(), symbol: this.bot.currentSymbol, direction: direction, price: this.bot.marketData.price, score: totalScore, reason: contributingStrats, status: 'active', note: ''};
            this.bot.calculateDynamicTpSl(signal);
            this.bot.addFinalSignal(signal);
            this.proposals = [];
            this.lastSignalTime = Date.now();
        }
    }

    /**
     * =================================================================
     * ANA UYGULAMA SINIFI (ULTIMATE TRADING COMMAND CENTER)
     * =================================================================
     */
    class UltimateTradingCommandCenter {
        constructor() {
            this.isRunning = false; this.sockets = {}; this.currentSymbol = 'BTCUSDT'; this.currentTimeframe = '15m';
            this.marketData = {}; this.orderBook = { bids: [], asks: [], lastUpdateId: null }; this.aggTrades = []; this.candles = [];
            this.indicators = { rsi: [], atr: null }; this.signals = this.loadData('utc_signals') || [];
            this.stats = this.loadData('utc_stats') || { total: 0, tp: 0, sl: 0 };
            this.settings = this.loadSettings();
            this.combatModeActive = false;
            this.chartManager = new ChartManager('live-chart');
            this.heatmapManager = new HeatmapManager('orderbook-heatmap');
            this.strategies = {}; this.activeStrategies = {};
            this.confluenceEngine = new ConfluenceEngine(this);
            this.renderInterval = null; this.analysisInterval = null;
            this.init();
        }

        init() {
            console.log("KOMUTA MERKEZİ BAŞLATILIYOR...");
            this.initStrategies(); this.setupUI(); this.setupEventListeners();
            this.renderSignals(); this.renderStats();
            this.logToJournal('Sistem hazır. "SİSTEMİ BAŞLAT" butonuna tıklayın.');
        }

        initStrategies() {
            const allStrategies = {
                'wallBounce': WallBounceStrategy, 'velocityScalping': VelocityScalpingStrategy, 'rsiDivergence': RsiDivergenceStrategy, 
                'orderFlowMomentum': OrderFlowMomentumStrategy, 'liquidityGaps': LiquidityGapsStrategy, 'fibonacciRetracement': FibonacciRetracementStrategy, 
                'volumeProfile': VolumeProfileStrategy, 'smartMoneyConcepts': SmartMoneyConceptsStrategy, 'divergenceDetection': DivergenceDetectionStrategy, 
                'breakoutPattern': BreakoutPatternStrategy, 'supportResistance': SupportResistanceStrategy, 'marketStructure': MarketStructureStrategy, 
                'institutionalOrderFlow': InstitutionalOrderFlowStrategy, 'microSpreadArbitrage': MicroSpreadArbitrageStrategy
            };
            for (const key in allStrategies) { this.strategies[key] = new allStrategies[key](this); }
            this.updateActiveStrategies();
        }

        updateActiveStrategies() {
            this.activeStrategies = {};
            for (const key in this.strategies) { if (this.settings.activeStrategies[key]) { this.activeStrategies[key] = this.strategies[key]; } }
        }

        setupUI() {
            const commonSymbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT', 'DOGEUSDT', 'LTCUSDT', 'AVAXUSDT'];
            document.getElementById('symbol-select').innerHTML = commonSymbols.map(s => `<option value="${s}">${s.replace('USDT', '/USDT')}</option>`).join('');
            document.getElementById('symbol-select').value = this.currentSymbol;
            document.getElementById('timeframe-select').value = this.currentTimeframe;
            document.getElementById('confluence-threshold').value = this.settings.confluenceThreshold;
            document.getElementById('param-rsi-period').value = this.settings.params.rsiPeriod;
            document.getElementById('param-atr-period').value = this.settings.params.atrPeriod;
            document.getElementById('param-wall-btc').value = this.settings.params.wallBtc;
            document.getElementById('param-rr-ratio').value = this.settings.params.rrRatio;

            const strategyContainer = document.getElementById('strategy-toggles');
            strategyContainer.innerHTML = '';
            for (const key in this.strategies) {
                const strategy = this.strategies[key];
                const isChecked = this.settings.activeStrategies[key];
                const toggleHtml = `<div class="form-group"><label class="checkbox-label"><input type="checkbox" class="strategy-toggle" data-strategy-key="${key}" ${isChecked ? 'checked' : ''}> ${strategy.displayName}</label></div>`;
                strategyContainer.innerHTML += toggleHtml;
            }
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme(); this.heatmapManager.updateTheme();
        }

        setupEventListeners() {
            document.getElementById('start-btn').addEventListener('click', () => this.start());
            document.getElementById('stop-btn').addEventListener('click', () => this.stop());
            document.getElementById('theme-toggle-btn').addEventListener('click', () => this.toggleTheme());
            document.getElementById('symbol-select').addEventListener('change', (e) => this.changeSymbol(e.target.value));
            document.getElementById('timeframe-select').addEventListener('change', (e) => this.changeTimeframe(e.target.value));
            
            document.getElementById('confluence-threshold').addEventListener('input', (e) => this.updateSetting('confluenceThreshold', parseInt(e.target.value)));
            document.getElementById('param-rsi-period').addEventListener('change', (e) => this.updateSetting('params.rsiPeriod', parseInt(e.target.value)));
            document.getElementById('param-atr-period').addEventListener('change', (e) => this.updateSetting('params.atrPeriod', parseInt(e.target.value)));
            document.getElementById('param-wall-btc').addEventListener('change', (e) => this.updateSetting('params.wallBtc', parseInt(e.target.value)));
            document.getElementById('param-rr-ratio').addEventListener('change', (e) => this.updateSetting('params.rrRatio', parseFloat(e.target.value)));
            
            document.getElementById('strategy-toggles').addEventListener('change', (e) => {
                if (e.target.classList.contains('strategy-toggle')) {
                    const key = e.target.dataset.strategyKey;
                    this.settings.activeStrategies[key] = e.target.checked;
                    this.saveSettings(); this.updateActiveStrategies();
                    this.showNotification(`${this.strategies[key].displayName} ${e.target.checked ? 'aktif' : 'pasif'}.`, 'info');
                }
            });
            document.getElementById('signals-body').addEventListener('click', (e) => {
                const target = e.target;
                if(target.classList.contains('signal-feedback-btn')) {
                    const signalId = target.dataset.id;
                    const result = target.dataset.result;
                    this.updateSignalResult(signalId, result);
                }
            });
        }

        updateSetting(key, value) {
            if (key.includes('.')) {
                const [parent, child] = key.split('.');
                this.settings[parent][child] = value;
            } else {
                this.settings[key] = value;
            }
            this.saveSettings();
            this.showNotification('Ayar güncellendi. Canlı analizde geçerli olacak.', 'info');
        }

        async start() {
            if (this.isRunning) return;
            this.isRunning = true; document.getElementById('start-btn').disabled = true; document.getElementById('stop-btn').disabled = false;
            this.showNotification('Sistem Başlatıldı: Canlı veri akışı başlatılıyor...', 'success');
            await this.fetchInitialData(); this.connectWebSockets();
            this.renderInterval = setInterval(() => this.render(), 250);
            this.analysisInterval = setInterval(() => this.runPeriodicAnalysis(), 5000);
        }

        stop() {
            if (!this.isRunning) return;
            this.isRunning = false; document.getElementById('start-btn').disabled = false; document.getElementById('stop-btn').disabled = true; this.disconnectWebSockets();
            if (this.renderInterval) clearInterval(this.renderInterval); if (this.analysisInterval) clearInterval(this.analysisInterval);
            this.updateConnectionStatus(false, "BAĞLANTI KESİLDİ"); if (this.combatModeActive) this.deactivateCombatMode();
            this.showNotification('Sistem Durduruldu.', 'danger');
        }

        async changeSymbol(newSymbol) {
            if (this.currentSymbol === newSymbol) return;
            this.currentSymbol = newSymbol; this.showNotification(`${this.currentSymbol} sembolüne geçildi.`, 'info');
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.disconnectWebSockets(); await this.fetchInitialData(); this.connectWebSockets(); }
        }

        async changeTimeframe(newTimeframe) {
            this.currentTimeframe = newTimeframe; this.showNotification(`Zaman aralığı ${this.currentTimeframe} olarak değiştirildi.`, 'info');
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.disconnectWebSockets(); await this.fetchInitialData(); this.connectWebSockets(); }
        }

        resetDataForNewSymbol() {
            this.candles = []; this.aggTrades = []; this.marketData = {}; this.orderBook = { bids: [], asks: [], lastUpdateId: null };
            this.indicators = { rsi: [], atr: null };
            this.chartManager.setData([]); this.chartManager.clearMarkers(); this.render();
        }

        async fetchInitialData() {
            try {
                this.logToJournal(`${this.currentSymbol} için geçmiş mum verileri çekiliyor...`);
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${this.currentTimeframe}&limit=500`;
                const response = await fetch(url); if (!response.ok) throw new Error(`API Hatası: ${response.statusText}`);
                const data = await response.json();
                this.candles = data.map(d => ({ time: d[0], open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]), }));
                this.chartManager.setData(this.candles); this.logToJournal(`${this.candles.length} adet mum yüklendi.`);
                this.calculateAllIndicators();
            } catch (error) { this.showNotification(`Geçmiş veri alınamadı: ${error.message}`, 'danger'); console.error("Geçmiş veri hatası:", error); }
        }

        connectWebSockets() {
            this.disconnectWebSockets(); const symbolLower = this.currentSymbol.toLowerCase();
            const streams = [`${symbolLower}@ticker`, `${symbolLower}@depth20@100ms`, `${symbolLower}@aggTrade`, `${symbolLower}@kline_${this.currentTimeframe}`];
            const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`); this.sockets['main'] = ws;
            ws.onopen = () => this.updateConnectionStatus(true);
            ws.onmessage = (event) => { const message = JSON.parse(event.data); this.handleMarketData(message.stream, message.data); };
            ws.onerror = (error) => console.error('WebSocket Hatası:', error);
            ws.onclose = () => { if (this.isRunning) { this.updateConnectionStatus(false, 'YENİDEN BAĞLANILIYOR...'); setTimeout(() => this.connectWebSockets(), 3000); } };
        }

        disconnectWebSockets() { if (this.sockets['main']) { this.sockets['main'].close(1000, "İstemci tarafından kapatıldı"); } }

        handleMarketData(stream, data) {
            const streamType = stream.split('@')[1];
            if (streamType === 'ticker') { this.marketData = { price: parseFloat(data.c), change24h: parseFloat(data.P), volume24h: parseFloat(data.q), symbol: data.s }; if (data.s === 'BTCUSDT') this.marketData.btcPrice = parseFloat(data.c); } 
            else if (streamType.startsWith('depth')) {
                this.orderBook = { bids: data.b.map(([p, q]) => [parseFloat(p), parseFloat(q)]), asks: data.a.map(([p, q]) => [parseFloat(p), parseFloat(q)]), lastUpdateId: data.u };
                this.heatmapManager.draw(this.orderBook, this.marketData.price);
                for (const key in this.activeStrategies) { this.activeStrategies[key].analyzeOrderBook(this.orderBook); }
            } else if (streamType === 'aggTrade') {
                const trade = { price: parseFloat(data.p), quantity: parseFloat(data.q), isBuyerMaker: data.m, timestamp: data.T };
                this.aggTrades.unshift(trade); if (this.aggTrades.length > 1000) this.aggTrades.pop();
                for (const key in this.activeStrategies) { this.activeStrategies[key].processTrade(trade); }
            } else if (streamType.startsWith('kline')) {
                if (this.candles.length > 0) {
                    const kline = data.k; this.chartManager.updateRealtime(kline);
                    if (kline.x) {
                        const newCandle = { time: kline.t, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c), volume: parseFloat(kline.v) };
                        const lastCandle = this.candles[this.candles.length - 1];
                        if (lastCandle.time === kline.t) this.candles[this.candles.length - 1] = newCandle; else this.candles.push(newCandle);
                        if (this.candles.length > 500) this.candles.shift(); this.calculateAllIndicators();
                    }
                }
            }
        }
        
        runPeriodicAnalysis() { if (!this.isRunning) return; for (const key in this.activeStrategies) { this.activeStrategies[key].periodicAnalyze(); } }
        
        calculateAllIndicators() {
            const rsiPeriod = this.settings.params.rsiPeriod;
            const closes = this.candles.map(c => c.close);
            if (closes.length < rsiPeriod) return;
            let avgGain = 0, avgLoss = 0;
            for (let i = 1; i <= rsiPeriod; i++) { const diff = closes[i] - closes[i - 1]; if (diff > 0) avgGain += diff; else avgLoss -= diff; }
            avgGain /= rsiPeriod; avgLoss /= rsiPeriod;
            const rsi = []; for (let i = 0; i < rsiPeriod; i++) rsi.push(NaN);
            rsi.push(100 - (100 / (1 + (avgGain / avgLoss))));
            for (let i = rsiPeriod + 1; i < closes.length; i++) {
                const diff = closes[i] - closes[i - 1];
                avgGain = (avgGain * (rsiPeriod - 1) + (diff > 0 ? diff : 0)) / rsiPeriod;
                avgLoss = (avgLoss * (rsiPeriod - 1) + (diff < 0 ? -diff : 0)) / rsiPeriod;
                rsi.push(100 - (100 / (1 + (avgLoss === 0 ? 100 : avgGain / avgLoss))));
            }
            this.indicators.rsi = rsi;

            const atrPeriod = this.settings.params.atrPeriod;
            if (this.candles.length < atrPeriod) return;
            let trs = [];
            for (let i = 1; i < this.candles.length; i++) {
                const c = this.candles[i], p = this.candles[i - 1];
                trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
            }
            if (trs.length === 0) return;
            let atrSum = trs.slice(0, atrPeriod).reduce((a, b) => a + b, 0);
            this.indicators.atr = atrSum / atrPeriod;
        }

        calculateDynamicTpSl(signal) {
            const atr = this.indicators.atr;
            if (!atr || atr === 0) {
                signal.tp = signal.direction === 'buy' ? signal.price * 1.01 : signal.price * 0.99;
                signal.sl = signal.direction === 'buy' ? signal.price * 0.995 : signal.price * 1.005;
                return;
            }
            const rrRatio = this.settings.params.rrRatio;
            const atrMultiplier = 1.5 - (signal.score / 20);
            const slDistance = atr * atrMultiplier;
            const tpDistance = slDistance * rrRatio;

            if (signal.direction === 'buy') {
                signal.sl = signal.price - slDistance;
                signal.tp = signal.price + tpDistance;
            } else {
                signal.sl = signal.price + slDistance;
                signal.tp = signal.price - tpDistance;
            }
        }

        render() { this.renderPriceDisplay(); }
        renderPriceDisplay() {
            const priceEl = document.getElementById('current-price');
            const oldPrice = parseFloat(priceEl.textContent.replace(/,/g, ''));
            if (this.marketData.price) {
                priceEl.textContent = this.formatPrice(this.marketData.price);
                if (!isNaN(oldPrice)) { if (this.marketData.price > oldPrice) priceEl.style.color = 'var(--positive)'; else if (this.marketData.price < oldPrice) priceEl.style.color = 'var(--negative)'; }
            }
            const change = this.marketData.change24h || 0;
            const changeEl = document.getElementById('price-change-24h');
            changeEl.textContent = `${change.toFixed(2)}%`; changeEl.style.color = change >= 0 ? 'var(--positive)' : 'var(--negative)';
            document.getElementById('volume-24h').textContent = this.formatVolume(this.marketData.volume24h);
            document.getElementById('atr-value').textContent = this.indicators.atr ? this.indicators.atr.toFixed(this.getDecimalPlaces(this.indicators.atr)) : '-';
        }
        
        addFinalSignal(signal) {
            this.signals.unshift(signal); if (this.signals.length > 100) this.signals.pop();
            this.saveData('utc_signals', this.signals);
            this.renderSignals(); this.chartManager.addSignalMarker(signal);
            this.showNotification(`YENİ SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol} | Skor: ${signal.score}`, signal.direction === 'buy' ? 'success' : 'danger');
            if (signal.score >= 8) { this.activateCombatMode(); }
        }

        updateSignalResult(signalId, result) {
            const signal = this.signals.find(s => s.id === signalId);
            if(signal && signal.status === 'active') {
                signal.status = result;
                this.stats.total++;
                this.stats[result]++;
                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.renderSignals();
                this.renderStats();
                this.showNotification(`Sinyal ${result.toUpperCase()} olarak işaretlendi.`, 'info');
            }
        }

        renderSignals() {
            const tbody = document.getElementById('signals-body');
            tbody.innerHTML = this.signals.map(s => `
                <tr class="signal-${s.status === 'active' ? s.direction : s.status}">
                    <td>${new Date(s.timestamp).toLocaleTimeString()}</td>
                    <td>${s.direction.toUpperCase()}</td>
                    <td>${this.formatPrice(s.price)}</td>
                    <td>${this.formatPrice(s.tp)}</td>
                    <td>${this.formatPrice(s.sl)}</td>
                    <td>${s.score}</td>
                    <td>${s.status === 'active' ? `<button class="btn-sm btn-success signal-feedback-btn" data-id="${s.id}" data-result="tp">TP</button> <button class="btn-sm btn-danger signal-feedback-btn" data-id="${s.id}" data-result="sl">SL</button>` : s.status.toUpperCase()}</td>
                </tr>`).join('');
        }
        renderStats() {
            const container = document.getElementById('stats-container');
            const winRate = this.stats.total > 0 ? (this.stats.tp / this.stats.total * 100).toFixed(1) : "N/A";
            container.innerHTML = `
                <div class="stat-item"><span class="stat-label">Toplam Sinyal:</span><span class="stat-value">${this.stats.total}</span></div>
                <div class="stat-item"><span class="stat-label">Başarılı (TP):</span><span class="stat-value" style="color:var(--positive)">${this.stats.tp}</span></div>
                <div class="stat-item"><span class="stat-label">Başarısız (SL):</span><span class="stat-value" style="color:var(--negative)">${this.stats.sl}</span></div>
                <div class="stat-item"><span class="stat-label">Başarı Oranı:</span><span class="stat-value" style="color:var(--primary)">${winRate}%</span></div>
            `;
        }

        activateCombatMode() {
            if (this.combatModeActive) return; this.combatModeActive = true; document.documentElement.setAttribute('data-theme', 'war');
            this.chartManager.updateTheme(); this.heatmapManager.updateTheme(); document.getElementById('combat-mode-audio').play().catch(()=>{});
            this.showNotification('!!! SAVAŞ MODU AKTİF !!!', 'warning');
        }
        deactivateCombatMode() {
            this.combatModeActive = false; const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme(); this.heatmapManager.updateTheme();
            const audio = document.getElementById('combat-mode-audio'); audio.pause(); audio.currentTime = 0;
        }

        formatPrice(price) { if(!price) return '-'; return price.toLocaleString('en-US', { minimumFractionDigits: this.getDecimalPlaces(price), maximumFractionDigits: this.getDecimalPlaces(price) }); }
        getDecimalPlaces(price) { if(!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        formatVolume(volume) { if (!volume) return '-'; if (volume >= 1e9) return `${(volume / 1e9).toFixed(2)}B`; if (volume >= 1e6) return `${(volume / 1e6).toFixed(2)}M`; return `${(volume / 1e3).toFixed(1)}K`; }
        toggleTheme() { if (this.combatModeActive) { this.deactivateCombatMode(); return; } const ct = document.documentElement.getAttribute('data-theme'); const nt = (ct === 'dark') ? 'light' : 'dark'; document.documentElement.setAttribute('data-theme', nt); localStorage.setItem('utc_theme', nt); this.chartManager.updateTheme(); this.heatmapManager.updateTheme(); }
        updateConnectionStatus(isConnected, message = 'BAĞLANTI YOK') { const sd = document.getElementById('connection-status'), st = document.getElementById('connection-text'); if(isConnected) { sd.classList.add('online'); st.textContent = `BAĞLI (${this.currentSymbol})`; } else { sd.classList.remove('online'); st.textContent = message; } }
        showNotification(message, type = 'info') { const c=document.getElementById('notifications-container'); if(!c) return; const n = document.createElement('div'); n.className=`notification ${type}`; n.textContent=message; c.prepend(n); setTimeout(() => { n.style.transition='opacity 0.5s ease'; n.style.opacity=0; setTimeout(()=>n.remove(), 500); }, 5000); }
        logToJournal(message) { console.log(`[LOG] ${new Date().toLocaleTimeString()} - ${message}`); }
        
        saveSettings() { localStorage.setItem('utc_settings', JSON.stringify(this.settings)); }
        loadSettings() {
            const allStrategyKeys = ['wallBounce', 'velocityScalping', 'rsiDivergence', 'orderFlowMomentum', 'liquidityGaps', 'fibonacciRetracement', 'volumeProfile', 'smartMoneyConcepts', 'divergenceDetection', 'breakoutPattern', 'supportResistance', 'marketStructure', 'institutionalOrderFlow', 'microSpreadArbitrage'];
            const defaultActive = {};
            allStrategyKeys.forEach((key, i) => defaultActive[key] = i < 5);
            const defaults = {
                confluenceThreshold: 3,
                params: { rsiPeriod: 14, atrPeriod: 14, wallBtc: 20, rrRatio: 1.5 },
                activeStrategies: defaultActive
            };
            const saved = this.loadData('utc_settings');
            if(saved) {
                // Kayıtlı ayarları varsayılanlarla birleştir, eksik parametreleri ekle
                saved.params = {...defaults.params, ...saved.params};
                saved.activeStrategies = {...defaults.activeStrategies, ...saved.activeStrategies};
                return { ...defaults, ...saved };
            }
            return defaults;
        }
        saveData(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); } catch(e) { console.error("Veri kaydedilemedi:", e); } }
        loadData(key) { 
            try {
                const data = localStorage.getItem(key); 
                return data ? JSON.parse(data) : null; 
            } catch(e) {
                console.error("Veri okunamadı:", e);
                return null;
            }
        }
    }
    document.addEventListener('DOMContentLoaded', () => { 
        try {
            window.app = new UltimateTradingCommandCenter(); 
        } catch(e) {
            console.error("Uygulama başlatılırken kritik bir hata oluştu:", e);
            document.body.innerHTML = `<div style="color: red; padding: 20px; font-family: monospace;">Uygulama başlatılamadı. Konsolu kontrol edin. Hata: ${e.message}</div>`;
        }
    });

</script>
</body>
</html>


