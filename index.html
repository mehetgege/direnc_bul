<!DOCTYPE html>
<html lang="tr" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>baysoy süper trader komuta merkezi</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>

    <style>
        :root {
            --background-dark: #0d1117; --panel-bg-dark: #161b22; --text-main-dark: #c9d1d9; --text-secondary-dark: #8b949e; --border-color-dark: #30363d; --input-bg-dark: #010409; --hover-bg-dark: #21262d; --primary-dark: #58a6ff;
            --background-light: #ffffff; --panel-bg: #f6f8fa; --text-main: #24292f; --text-secondary: #57606a; --border-color: #d0d7de; --input-bg: #f0f2f5; --hover-bg: #e8eaed; --primary: #0969da;
            --war-mode-bg: linear-gradient(145deg, #4d0000 0%, #000000 75%); --war-mode-panel-bg: rgba(255, 0, 0, 0.08); --war-mode-border: #8B0000; --war-mode-text: #ff5858; --war-mode-primary: #ffc107;
            --positive: #28a745; --negative: #dc3545; --neutral: #ffc107;
            --ticker-height: 30px; 
            --signal-bar-height: 40px; /* Yeni sinyal barı yüksekliği */
            --header-min-height: 40px;
        }
        /* Fullscreen modda gizlenecek elemanlar */
        body.fullscreen-chart #super-top-ticker,
        body.fullscreen-chart #signal-progress-bar-container,
        body.fullscreen-chart .header,
        body.fullscreen-chart .panel-title {
            display: none !important;
        }

        /* Fullscreen modda chart'ı büyütme */
        body.fullscreen-chart .container {
            padding-top: 0 !important;
            height: 100vh !important;
        }
        body.fullscreen-chart .main-grid {
            height: 100vh !important;
            margin: 0 !important;
        }
        body.fullscreen-chart .center-panel {
            flex-grow: 1 !important;
            height: 100vh !important;
            border-radius: 0 !important;
            margin: 0 !important;
        }
        body.fullscreen-chart .data-container {
            height: 100% !important; /* Data container fills its parent (center-panel) */
        }
        body.fullscreen-chart #chart-container-view,
        body.fullscreen-chart #live-chart {
            height: 100% !important; /* Chart takes full height */
            flex-grow: 1 !important;
        }
        body.fullscreen-chart .heatmap-container {
            display: none !important; /* Hide heatmap in fullscreen */
        }
        body.fullscreen-chart .chart-zoom-controls {
            background: rgba(0,0,0,0.7); /* make controls more visible */
        }
        body.fullscreen-chart #exit-fullscreen-btn {
            display: block !important;
        }
        body.fullscreen-chart #chart-countdown-overlay {
            display: block !important;
        }

        [data-theme="light"] { --background: var(--background-light); --panel-bg: var(--panel-bg-light); --text-main: var(--text-main-light); --text-secondary: var(--text-secondary-light); --border-color: var(--border-color-light); --input-bg: var(--input-bg-light); --hover-bg: var(--hover-bg-light); --primary: var(--primary-light); }
        [data-theme="dark"] { --background: var(--background-dark); --panel-bg: var(--panel-bg-dark); --text-main: var(--text-main-dark); --text-secondary: var(--text-secondary-dark); --border-color: var(--border-color-dark); --input-bg: var(--input-bg-dark); --hover-bg: var(--hover-bg-dark); --primary: var(--primary-dark); }
        [data-theme="war"] { --background: var(--war-mode-bg); --panel-bg: var(--war-mode-panel-bg); --text-main: var(--war-mode-text); --text-secondary: #ffaaaa; --border-color: var(--war-mode-border); --input-bg: rgba(255, 255, 255, 0.05); --hover-bg: rgba(255, 255, 255, 0.1); --primary: var(--war-mode-primary); }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Roboto Mono', monospace; font-size: 12px; background: var(--background); color: var(--text-main); overflow: hidden; transition: background 0.5s, color 0.5s; }
        
        #super-top-ticker { display: flex; position: fixed; top: 0; left: 0; width: 100%; background: var(--panel-bg); border-bottom: 1px solid var(--border-color); padding: 2px 10px; z-index: 1100; align-items: center; justify-content: space-between; font-size: 11px; font-weight: 700; height: var(--ticker-height); }
        .super-top-left { display: flex; align-items: center; gap: 10px; flex-shrink: 0;}
        #ticker-bar-symbol { color: var(--primary); }
        #ticker-bar-price { color: var(--text-main); font-size: 12px; }
        .super-top-right-buttons { display: flex; gap: 5px; }

        .container { display: flex; flex-direction: column; height: 100vh; padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); }

        .header { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; flex-shrink: 0; box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 5px; position: relative; }
        .header-top-bar { display: flex; align-items: center; width: 100%; padding: 5px 15px; min-height: var(--header-min-height); justify-content: space-between; cursor: pointer; font-weight: 700; font-size: 16px; color: var(--primary); }
        .header-collapsible-content { transition: max-height 0.35s ease-in-out, opacity 0.3s ease, padding 0.35s ease, visibility 0.35s; max-height: 300px; opacity: 1; overflow: hidden; visibility: visible; padding: 0 15px 8px 15px; }
        body.header-collapsed .header-collapsible-content { max-height: 0; opacity: 0; visibility: hidden; padding-top: 0; padding-bottom: 0; }

        .main-controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; padding-bottom: 8px; }
        .form-control { background: var(--input-bg); color: var(--text-main); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-family: 'Roboto Mono', monospace; }
        
        .status { display: flex; align-items: center; gap: 5px; font-size: 11px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--negative); transition: background-color 0.5s; }
        .status-dot.online { background: var(--positive); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 #28a745b3; } 70% { box-shadow: 0 0 0 6px #28a74500; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        [data-theme="war"] .status-dot.online { background: var(--war-mode-primary); animation: war-pulse 1s infinite; }
        @keyframes war-pulse { 0% { box-shadow: 0 0 0 0 #ffc107b3; } 70% { box-shadow: 0 0 0 6px #ffc10700; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        .btn { padding: 4px 12px; border: 1px solid var(--border-color); background: var(--panel-bg); color: var(--text-main); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .btn:hover { background: var(--hover-bg); border-color: var(--primary); }
        .btn-success { background: var(--positive); color: white; border-color: var(--positive); } .btn-danger { background: var(--negative); color: white; border-color: var(--negative); }
        .btn-tiny { padding: 2px 6px; font-size: 10px; line-height: 1; min-width: 0; white-space: nowrap; }
        
        .main-grid { display: grid; grid-template-columns: 1fr; gap: 5px; flex-grow: 1; margin: 5px; overflow: hidden; height: calc(100% - var(--header-min-height) - 10px - var(--ticker-height) - var(--signal-bar-height)); }
        body.header-collapsed .main-grid { height: calc(100vh - var(--ticker-height) - var(--signal-bar-height) - 10px); margin-top: 0; } 
        
        .panel { display: flex; flex-direction: column; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; overflow: hidden; position: relative;}
        .panel-title { font-weight: 700; font-size: 13px; color: var(--primary); padding: 8px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;}
        .panel-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
        .settings-group { margin-bottom: 15px; } .form-group { margin-bottom: 8px; } .form-label { display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
        .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 12px; padding: 4px 0;}
        
        .price-display { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; width: 100%; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; font-size: 10px; margin-top: 8px; } 
        .price-item .price-label { color: var(--text-secondary); } 
        .price-item .price-value { font-size: 18px; font-weight: 700; }
        .price-item.countdown { grid-column: 1 / span 2; display: flex; justify-content: center; align-items: center; font-size: 14px; font-weight: 700; color: var(--primary); padding-top: 5px;}
        
        .center-panel { display: grid; grid-template-rows: 1fr; gap: 5px; padding: 0 !important; } 
        .data-container { display: grid; grid-template-rows: 1fr auto; overflow: hidden; height: 100%; } 
        .data-grid { position: relative; overflow: hidden; min-height: 0; } 

        #live-chart { width: 100%; height: 100%; } 
        .heatmap-container { display: grid; grid-template-rows: auto 1fr; border-top: 1px solid var(--border-color); }
        #orderbook-heatmap { width: 100%; height: 100%; display: block; }

        .chart-zoom-controls { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 100; }
        .chart-zoom-controls .btn-tiny { background: rgba(1, 4, 9, 0.7); backdrop-filter: blur(2px); }

        #exit-fullscreen-btn {
            position: absolute; top: 10px; right: 10px; z-index: 101; 
            background: rgba(1, 4, 9, 0.7); color: white; border-radius: 4px; 
            padding: 2px 6px; font-size: 16px; cursor: pointer; border: 1px solid var(--border-color);
            line-height: 1; /* Make X look centered */
        }
        #chart-countdown-overlay {
            position: absolute; top: 10px; left: 10px; z-index: 100; 
            background: rgba(1, 4, 9, 0.7); padding: 4px 8px; border-radius: 4px; 
            color: var(--primary); font-size: 14px; font-weight: bold;
        }

        .data-table-container { width: 100%; height: 100%; overflow: auto; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .data-table th, .data-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap;}
        .data-table th { font-weight: 700; position: sticky; top: 0; background: var(--panel-bg); z-index: 10;}
        .data-table tr:hover { background: var(--hover-bg); }
        .signal-buy { background-color: #28a74514; } .signal-sell { background-color: #dc354514; }
        .signal-tp { background-color: #28a74533; } .signal-sl { background-color: #dc354533; }
        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border-color); font-size: 12px; }
        .stat-item:last-child { border-bottom: none; } .stat-label { color: var(--text-secondary); } .stat-value { font-weight: 700; }
        .btn-sm { padding: 1px 4px; font-size: 9px; margin-left: 4px; border-radius: 3px; cursor: pointer;}
        ::-webkit-scrollbar { width: 6px; height: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--text-secondary); border-radius: 3px; }
        .notifications { position: fixed; bottom: 15px; right: 15px; z-index: 2000; width: 320px; }
        .notification { background: var(--panel-bg); border: 1px solid var(--border-color); border-left-width: 5px; border-radius: 4px; padding: 12px; font-size: 13px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); margin-top: 10px; }
        .notification.success { border-left-color: var(--positive); } .notification.danger { border-left-color: var(--negative); } .notification.warning { border-left-color: var(--neutral); }
        
        aside#settings-panel, aside#analytics-panel { display: none !important; }
        .hidden-view { display: none !important; } 

        #settings-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 2500; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        #settings-modal-overlay.visible { opacity: 1; visibility: visible; }
        .settings-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 90%; max-width: 860px; max-height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); transform: translateY(20px); transition: transform 0.3s ease; }
        #settings-modal-overlay.visible .settings-modal-content { transform: translateY(0); }
        .settings-modal-header { padding: 12px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 15px; color: var(--primary); }
        .settings-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
        .settings-modal-header .close-btn:hover { color: var(--negative); }
        .settings-modal-body { padding: 15px; overflow-y: auto; flex-grow: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .settings-modal-footer { padding: 12px 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; }

        /* Yeni Sinyal Barı */
        #signal-progress-bar-container {
            display: flex; gap: 5px; width: 100%; padding: 5px 10px; background: var(--panel-bg); 
            border-bottom: 1px solid var(--border-color); justify-content: space-around; align-items: center;
            position: fixed; top: var(--ticker-height); left: 0; z-index: 1099;
            height: var(--signal-bar-height); /* Added height */
        }
        .signal-bar-wrapper { flex: 1; text-align: center; }
        .signal-bar-label { font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; }
        .signal-bar { 
            width: 100%; height: 10px; background: var(--input-bg); border: 1px solid var(--border-color); 
            border-radius: 5px; overflow: hidden; position: relative;
        }
        .signal-bar-fill { 
            height: 100%; width: 0%; transition: width 0.2s ease-out; position: absolute; left: 0; top: 0;
            background: linear-gradient(90deg, transparent, var(--positive)); 
        }
        .signal-bar-fill.buy { background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.sell { background: linear-gradient(90deg, transparent, var(--negative)); }
        .signal-score-text { font-size: 9px; margin-top: 2px; color: var(--primary); }

        /* Resizable Handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 8px; /* Slightly larger for easier grab */
            cursor: ns-resize;
            background: var(--border-color);
            z-index: 10;
            border-top: 1px solid var(--border-color);
        }
        .center-panel.resizing {
            user-select: none; /* Prevent text selection during drag */
        }

        @media screen and (max-width: 768px) {
            .container { padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); } /* Sinyal bar için ek boşluk */
            #signal-progress-bar-container { top: var(--ticker-height); }
            .header { order: 2; position: sticky; bottom: 0; top: auto; width: 100%; z-index: 1000; margin: 0; border-radius: 0; border: none; border-top: 1px solid var(--border-color); }
            .header-top-bar { flex-direction: column; align-items: center; gap: 10px; padding: 10px 15px; }
            .header-collapsible-content { padding: 0; }
            .header-collapsible-content .main-controls { flex-direction: column; align-items: center; padding: 0; width: 100%; }
            .form-control, .btn, .status { width: 100%; text-align: center; padding: 8px 10px; font-size: 11px; }
            .status { justify-content: center; }
            .price-display { grid-template-columns: repeat(2, 1fr); margin-top: 10px; }
            .price-item .price-value { font-size: 14px; } 
            .main-grid { order: 1; flex-direction: column; margin: 5px; overflow: visible; padding-bottom: 5px; height: auto; }
            .center-panel { order: 1; flex-grow: 0; height: auto; border: 1px solid var(--border-color); border-radius: 6px; background: var(--panel-bg); box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 0; }
            .center-panel > .panel-title { display: none; }
            .data-container { flex-direction: column; height: auto; padding: 10px; }
            .data-grid { height: 50vh; flex-shrink: 0; }
            #live-chart { height: 100%; width: 100%; } 
            .heatmap-container { height: 150px; flex-shrink: 0; margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 10px; }
            .heatmap-container .panel-title { border-bottom: none; margin-bottom: 5px; }
            .settings-modal-content { width: 95%; margin: 10px; }
            .settings-modal-body { grid-template-columns: 1fr; gap: 15px; }
            .super-top-right-buttons { display: none; }
            .resize-handle { display: none; } /* Disable resize handle on mobile */
            #chart-countdown-overlay { font-size: 12px; padding: 3px 6px; }
        }
    </style>
</head>
<body class="header-collapsed"> 
    <div id="super-top-ticker">
        <div class="super-top-left">
            <span id="ticker-bar-symbol"></span>
            <span id="ticker-bar-price"></span>
        </div>
        <div class="super-top-right-buttons">
            <button id="main-controls-btn" class="btn btn-tiny">Komuta Merkezi</button>
            <button id="chart-view-btn" class="btn btn-tiny">Grafik</button>
            <button id="heatmap-view-btn" class="btn btn-tiny">Isı Haritası</button>
            <button id="fullscreen-chart-btn" class="btn btn-tiny">Tam Ekran Grafik</button> <!-- NEW -->
            <button id="open-settings-modal-btn" class="btn btn-tiny">Ayarlar</button>
        </div>
    </div>

    <!-- Yeni Sinyal İlerleme Barı -->
    <div id="signal-progress-bar-container">
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">BUY SINYAL GÜCÜ</div>
            <div class="signal-bar">
                <div id="buy-signal-bar-fill" class="signal-bar-fill buy"></div>
            </div>
            <div id="buy-signal-score-text" class="signal-score-text">0.0</div>
        </div>
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">SELL SINYAL GÜCÜ</div>
            <div class="signal-bar">
                <div id="sell-signal-bar-fill" class="signal-bar-fill sell"></div>
            </div>
            <div id="sell-signal-score-text" class="signal-score-text">0.0</div>
        </div>
    </div>


    <div class="container">
        <header class="header">
            <div id="header-main-bar" class="header-top-bar" title="Paneli aç/kapatmak için çift tıkla">
                <span>KOMUTA MERKEZİ KONTROLLERİ</span>
            </div>
            <div class="header-collapsible-content">
                <div class="main-controls">
                    <input type="text" id="symbol-input" class="form-control" placeholder="Örn: BTC, ETH, SOL">
                    <select id="timeframe-select" class="form-control">
                        <option value="1m">1m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option>
                    </select>
                    <div class="status">
                        <div id="connection-status" class="status-dot"></div>
                        <span id="connection-text">BAĞLANTI YOK</span>
                    </div>
                    <button id="theme-toggle-btn" class="btn">Tema</button>
                    <button id="start-btn" class="btn btn-success">SİSTEMİ BAŞLAT</button>
                    <button id="stop-btn" class="btn btn-danger" disabled>DURDUR</button>
                    <button id="clear-markers-btn" class="btn">Grafik Sinyallerini Sil</button> 
                </div>
                <div class="price-display">
                    <div class="price-item"><div class="price-label">FİYAT</div><div class="price-value" id="current-price">-</div></div>
                    <div class="price-item"><div class="price-label">24s DEĞİŞİM</div><div class="price-value" id="price-change-24h">-</div></div>
                    <div class="price-item"><div class="price-label">24s HACİM</div><div class="price-value" id="volume-24h">-</div></div>
                    <div class="price-item"><div class="price-label">VOLATİLİTE (ATR)</div><div class="price-value" id="atr-value">-</div></div>
                    <div class="price-item countdown"><span id="candle-countdown">--:--</span></div>
                </div>
            </div>
        </header>

        <main class="main-grid">
            <section class="center-panel panel">
                <div class="data-container">
                    <div class="data-grid" id="chart-container-view">
                        <div id="live-chart"></div>
                        <div class="chart-zoom-controls"> 
                            <button id="chart-zoom-in" class="btn btn-tiny">+</button>
                            <button id="chart-zoom-out" class="btn btn-tiny">-</button>
                            <button id="chart-zoom-reset" class="btn btn-tiny">Sıfırla</button>
                        </div>
                        <button id="exit-fullscreen-btn" class="btn btn-tiny hidden-view" title="Tam Ekrandan Çık">&times;</button> <!-- NEW -->
                        <div id="chart-countdown-overlay" class="hidden-view">--:--</div> <!-- NEW -->
                    </div>
                    <div class="heatmap-container" id="heatmap-container-view">
                        <div class="panel-title" style="border-top: 1px solid var(--border-color); border-bottom: none;">EMİR DEFTERİ ISI HARİTASI</div>
                        <canvas id="orderbook-heatmap"></canvas>
                    </div>
                </div>
                <div class="resize-handle"></div> <!-- NEW RESIZE HANDLE -->
            </section>
        </main>
    </div>
    
    <div id="notifications-container" class="notifications"></div>

    <!-- AYARLAR MODAL -->
    <div id="settings-modal-overlay">
        <div class="settings-modal-content">
            <div class="settings-modal-header">
                <span>AYARLAR & OPTİMİZASYON</span>
                <button class="close-btn" id="close-settings-modal-btn">&times;</button>
            </div>
            <div class="settings-modal-body">
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Temel Parametreler</div>
                    <div class="form-group"><label class="form-label">Min. Uyum Skoru (1-10)</label><input type="range" id="modal-confluence-threshold" class="form-control" min="1" max="10" value="3" step="1"></div>
                    <div class="form-group"><label class="form-label">RSI Periyodu</label><input type="number" id="modal-param-rsi-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">ATR Periyodu</label><input type="number" id="modal-param-atr-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">Duvar Tespiti (BTC Miktarı)</label><input type="number" id="modal-param-wall-btc" class="form-control" value="20"></div>
                    <div class="form-group"><label class="form-label">Risk/Ödül Oranı (R/R)</label><input type="number" id="modal-param-rr-ratio" class="form-control" value="1.5" step="0.1"></div>
                </div>
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Cooldown Ayarları</div>
                    <div class="form-group"><label class="form-label">Genel Sinyal Cooldown (ms)</label><input type="number" id="modal-signal-cooldown-ms" class="form-control" value="15000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Aynı Yön Sinyal Cooldown (ms)</label><input type="number" id="modal-same-direction-cooldown-ms" class="form-control" value="30000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Yön Cooldown (ms)</label><input type="number" id="modal-opposite-direction-cooldown-ms" class="form-control" value="20000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Yön Histerezis (+Puan)</label><input type="number" id="modal-reverse-hysteresis-points" class="form-control" value="2" min="0" step="1"></div>
                    <div class="form-group"><label class="form-label">Proposal Timeout (ms)</label><input type="number" id="modal-proposal-timeout-ms" class="form-control" value="3000" min="500" step="100"></div>
                    <div class="form-group"><label class="form-label">Strateji Teklifi Cooldown (ms)</label><input type="number" id="modal-strategy-proposal-cooldown-ms" class="form-control" value="10000" min="0" step="100"></div>
                </div>
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Gelişmiş Özellikler</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-spoof-detection" class="feature-toggle" checked> Spoof Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-cusum-drift" class="feature-toggle" checked> CUSUM Sapma Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-risk-guardian" class="feature-toggle" checked> Risk Koruyucu (Kill Switch)</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-optimize" class="feature-toggle" checked> Oto-Optimizasyon</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-toggle-strat" class="feature-toggle" checked> Stratejileri Oto-Ayarla</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-breakeven-trail" class="feature-toggle" checked> Maliyete Çek/Takip Eden SL</label></div>
                    <div class="form-group"><label class="form-label">BE R Oranı</label><input type="number" id="modal-be-at-r" class="form-control" value="0.8" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Başlangıç R Oranı</label><input type="number" id="modal-trail-after-r" class="form-control" value="1.5" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Kârı R Oranı</label><input type="number" id="modal-trail-to-r" class="form-control" value="0.5" step="0.1"></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-tts" class="feature-toggle" checked> Sesli Bildirimler</label></div>
                    <div class="form-group">
                        <label class="form-label">Ses Seçimi</label>
                        <select id="modal-tts-voice-select" class="form-control"></select>
                    </div>
                </div>
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Aktif Stratejiler</div>
                    <div id="modal-strategy-toggles"></div>
                </div>
                <div class="settings-group" style="grid-column: 1 / -1;">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Geçmişi ve Analiz</div>
                    <div class="data-table-container" style="max-height: 300px;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Zaman</th><th>Tip</th><th>Fiyat</th><th>TP</th><th>SL</th><th>Skor</th><th>Katkı</th><th>Durum</th>
                                </tr>
                            </thead>
                            <tbody id="modal-signals-body"></tbody>
                        </table>
                    </div>
                    <button id="modal-clear-signals-btn" class="btn btn-danger btn-sm" style="margin-top: 10px;">Tüm Sinyalleri Sil</button>
                    <div id="modal-stats-container" style="margin-top: 15px;"></div>
                </div>
            </div>
            <div class="settings-modal-footer">
                <button id="reset-all-settings-btn" class="btn btn-danger">AYARLARI SIFIRLA</button>
                <button id="save-settings-btn" class="btn btn-success">AYARLARI KAYDET</button>
            </div>
        </div>
    </div>


<script>
    // Sinyal sesleri
    function playSignal(type) {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            if (type === 'buy') {
                oscillator.type = 'triangle'; oscillator.frequency.value = 1000;
            } else if (type === 'sell') {
                oscillator.type = 'square'; oscillator.frequency.value = 400;
            } else if (type === 'combat') {
                oscillator.type = 'sawtooth'; oscillator.frequency.value = 800; 
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
                oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 1);
                return;
            }
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5);
        } catch (error) { console.log('Ses çalınamadı:', error); }
    }

    /* =========================
       GÖRSELLEŞTİRME YÖNETİCİLERİ
       ========================= */
    class ChartManager {
        constructor(chartContainerId) {
            this.chartContainer = document.getElementById(chartContainerId);
            if (!this.chartContainer) throw new Error("Chart container bulunamadı!");
            this.chart = null; this.series = {}; this.signalMarkers = [];
            this._initChart();
        }
        _initChart() {
            this.chart = LightweightCharts.createChart(this.chartContainer, this._getChartOptions());
            this.series.candles = this.chart.addCandlestickSeries(this._getCandlestickOptions());
            this.series.volume = this.chart.addHistogramSeries(this._getVolumeOptions());
            window.addEventListener('resize', () => { 
                if (this.chart && this.chartContainer.clientWidth > 0 && this.chartContainer.clientHeight > 0) {
                    this.chart.resize(this.chartContainer.clientWidth, this.chartContainer.clientHeight);
                }
            });
        }
        updateTheme() {
            if(!this.chart) return;
            this.chart.applyOptions(this._getChartOptions());
            this.series.candles.applyOptions(this._getCandlestickOptions());
            this.series.volume.applyOptions(this._getVolumeOptions());
        }
        setData(candles) {
            if (!this.series.candles) return;
            const candleData = candles.map(c => ({ time: c.time / 1000, open: c.open, high: c.high, low: c.low, close: c.close }));
            const volumeData = candles.map(c => ({ time: c.time / 1000, value: c.volume, color: c.close >= c.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' }));
            this.series.candles.setData(candleData);
            this.series.volume.setData(volumeData);
            this.chart.timeScale().fitContent();
        }
        updateRealtime(kline) {
             if (!this.series.candles) return;
             const candle = { time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c) };
             const volume = { time: kline.t / 1000, value: parseFloat(kline.v), color: candle.close >= candle.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' };
             this.series.candles.update(candle);
             this.series.volume.update(volume);
        }
        addSignalMarker(signal) {
            if (!this.series.candles) return;
            const styles = getComputedStyle(document.body);
            const marker = {
                time: signal.timestamp / 1000,
                position: signal.direction === 'buy' ? 'belowBar' : 'aboveBar',
                color: signal.direction === 'buy' ? styles.getPropertyValue('--positive').trim() : styles.getPropertyValue('--negative').trim(),
                shape: signal.direction === 'buy' ? 'arrowUp' : 'arrowDown',
                text: `Skor: ${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score} @ ${this._formatMarkerPrice(signal.price)}`
            };
            this.signalMarkers.push(marker);
            this.series.candles.setMarkers(this.signalMarkers);
        }
        clearMarkers() { if (!this.series.candles) return; this.signalMarkers = []; this.series.candles.setMarkers([]); }
        zoom(factor) {
            if (!this.chart) return;
            const timeScale = this.chart.timeScale();
            const currentLogicalRange = timeScale.getVisibleLogicalRange();
            if (!currentLogicalRange) return;
            const newLogicalRange = { from: currentLogicalRange.from * factor, to: currentLogicalRange.to * factor };
            timeScale.setVisibleLogicalRange(newLogicalRange);
        }
        zoomIn() { this.zoom(0.9); }
        zoomOut() { this.zoom(1.1); }
        resetZoom() { if (this.chart) this.chart.timeScale().fitContent(); }

        _getDecimalPlacesBasedOnPrice(price) { if(!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _formatMarkerPrice(price) { const d = this._getDecimalPlacesBasedOnPrice(price); return price.toFixed(d); }
        _getChartOptions() {
            const styles = getComputedStyle(document.body);
            return {
                width: this.chartContainer.clientWidth, height: this.chartContainer.clientHeight,
                layout: { backgroundColor: 'transparent', textColor: styles.getPropertyValue('--text-main').trim(), fontFamily: "'Roboto Mono', monospace" },
                grid: { vertLines: { color: styles.getPropertyValue('--border-color').trim() }, horzLines: { color: styles.getPropertyValue('--border-color').trim() } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: styles.getPropertyValue('--border-color').trim(), timeVisible: true, secondsVisible: false, rightOffset: 10 }
            };
        }
        _getCandlestickOptions() {
             const styles = getComputedStyle(document.body);
             return { 
                upColor: styles.getPropertyValue('--positive').trim(), downColor: styles.getPropertyValue('--negative').trim(),
                borderVisible: false, wickUpColor: styles.getPropertyValue('--positive').trim(), wickDownColor: styles.getPropertyValue('--negative').trim(),
                priceFormat: { type: 'price', precision: 6, minMove: 0.000001 }
             };
        }
        _getVolumeOptions() { return { priceFormat: { type: 'volume' }, priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 } }; }
    }

    class HeatmapManager {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            if (!this.canvas) throw new Error("Heatmap canvas bulunamadı!");
            this.ctx = this.canvas.getContext('2d');
            this._resizeCanvas();
            window.addEventListener('resize', () => this._resizeCanvas());
        }
        draw(orderBook, symbolPrice) {
            // Check if orderBook.bids and orderBook.asks are arrays before mapping
            if (!orderBook.bids || !Array.isArray(orderBook.bids) || orderBook.bids.length === 0 || !orderBook.asks || !Array.isArray(orderBook.asks) || orderBook.asks.length === 0) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                return;
            }
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            const asks = orderBook.asks.slice().reverse(); const bids = orderBook.bids;
            const allLevels = [...bids, ...asks]; const maxQty = Math.max(...allLevels.map(l => l[1]));
            this._drawSection(asks, 'asks', maxQty, symbolPrice); this._drawSection(bids, 'bids', maxQty, symbolPrice);
        }
        updateTheme() { this._resizeCanvas(); }
        _drawSection(levels, type, maxQty, symbolPrice) {
            const styles = getComputedStyle(document.body);
            const baseColor = type === 'asks' ? styles.getPropertyValue('--negative').trim() : styles.getPropertyValue('--positive').trim();
            if (levels.length === 0) return;
            const heightPerLevel = (this.canvas.height / 2) / levels.length;
            const priceDecimals = this._getDecimalPlaces(symbolPrice);
            const labelSkipInterval = heightPerLevel < 12 ? Math.ceil(12 / heightPerLevel) : 1;
            levels.forEach((level, index) => {
                const [price, qty] = level;
                const intensity = Math.min(Math.sqrt(qty / maxQty), 1.0);
                this.ctx.fillStyle = this._hexToRgba(baseColor, intensity * 0.6 + 0.1);
                const y = type === 'asks' ? index * heightPerLevel : (this.canvas.height / 2) + (index * heightPerLevel);
                const barWidth = this.canvas.width * intensity;
                this.ctx.fillRect(0, y, barWidth, heightPerLevel);
                if (index % labelSkipInterval === 0) {
                    this.ctx.fillStyle = intensity > 0.5 ? '#FFFFFF' : styles.getPropertyValue('--text-secondary').trim();
                    this.ctx.font = '10px "Roboto Mono"'; this.ctx.textAlign = 'left';
                    this.ctx.fillText(`${(qty).toFixed(2)} @ ${price.toFixed(priceDecimals)}`, 10, y + heightPerLevel - 3);
                }
            });
        }
        _getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _hexToRgba(hex, alpha) {
            if(!hex.startsWith('#')) return `rgba(120,120,120,${alpha})`;
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        _resizeCanvas() { 
            if(this.canvas.parentElement) {
                this.canvas.width = this.canvas.parentElement.clientWidth; 
                this.canvas.height = this.canvas.parentElement.clientHeight; 
            }
        }
    }

    /* =========================
       GELİŞMİŞ ÖZELLİK YÖNETİCİLERİ
       ========================= */

    // Çoklu Zaman Dilimi Yöneticisi (Multi-Timeframe Manager) - Temel Yapı
    class MultiTimeframeManager {
        constructor(bot) {
            this.bot = bot;
            this.dataStreams = {}; // { '1h': { candles: [], indicators: {} }, '4h': {...} }
        }

        async initialize(symbol) {
            this.bot.logToJournal("Multi-Timeframe Manager başlatıldı (temel).");
        }
        fetchHistoricalData(symbol, timeframe) { /* ... */ }
        connectWebSocketStream(symbol, timeframe) { /* ... */ }
        getIndicator(timeframe, indicatorName) { /* ... */ return null; }
        cleanup() { this.bot.logToJournal("Multi-Timeframe Manager durduruldu."); }
    }

    // Sahte Emir Tespiti (Spoof Detector)
    class SpoofDetector {
        constructor(bot) {
            this.bot = bot;
            this.largeOrderThreshold = 10; // BTC cinsinden büyük emir eşiği (BTCUSDT için 10 BTC)
            this.recentOrders = [];
            this.CHECK_WINDOW_MS = 5000; // Son 5 saniyedeki değişiklikleri kontrol et
        }

        trackOrderBook(orderBook) {
            const now = Date.now();
            // Yalnızca aktif (status = 0) emirleri takip et (Binance diff stream'de statü yok, bu bir varsayım olabilir)
            this.recentOrders = this.recentOrders.filter(o => now - o.timestamp < this.CHECK_WINDOW_MS);

            // Yeni büyük emirleri ekle
            // orderBook.bids ve asks artık güncel, tam listeyi tutuyor
            orderBook.bids.forEach(([price, qty]) => {
                const usdValue = qty * price;
                if (this.bot.currentSymbol === 'BTCUSDT' && qty > this.largeOrderThreshold) {
                    this.recentOrders.push({ type: 'bid', price, qty, timestamp: now });
                } else if (this.bot.currentSymbol !== 'BTCUSDT' && usdValue / (this.bot.marketData.btcPrice || 70000) > this.largeOrderThreshold) {
                    this.recentOrders.push({ type: 'bid', price, qty, timestamp: now });
                }
            });
            orderBook.asks.forEach(([price, qty]) => {
                const usdValue = qty * price;
                 if (this.bot.currentSymbol === 'BTCUSDT' && qty > this.largeOrderThreshold) {
                    this.recentOrders.push({ type: 'ask', price, qty, timestamp: now });
                } else if (this.bot.currentSymbol !== 'BTCUSDT' && usdValue / (this.bot.marketData.btcPrice || 70000) > this.largeOrderThreshold) {
                    this.recentOrders.push({ type: 'ask', price, qty, timestamp: now });
                }
            });

            this._detectSpoofing();
        }

        _detectSpoofing() {
            const now = Date.now();
            const minTimeDiff = 1000; // 1 saniye içinde kaybolursa spoof sayılır

            this.recentOrders.forEach(order => {
                if (now - order.timestamp > minTimeDiff) {
                    // Kontrolü yerel orderBook'a göre yap
                    const exists = (order.type === 'bid' ? this.bot.orderBook.bids : this.bot.orderBook.asks)
                        .some(([p, q]) => p === order.price && q === order.qty);
                    
                    if (!exists) {
                        this.bot.showNotification(`Sahte Emir Tespiti: ${order.type.toUpperCase()} ${order.qty.toFixed(2)} @ ${order.price.toFixed(this.bot.getDecimalPlaces(order.price))} aniden kayboldu!`, 'warning');
                    }
                }
            });
            // recentOrders listesini güncel tut, çok eskileri çıkar
            this.recentOrders = this.recentOrders.filter(o => now - o.timestamp < this.CHECK_WINDOW_MS);
        }
    }

    // CUSUM Sapma Tespiti (CUSUM Drift Detector)
    class CUSUMDriftDetector {
        constructor() {
            this.K = 0.5; // Referans değeri (Hedef kazanma oranı - 0.5 = %50)
            this.H = 3;   // Kontrol eşiği (H ne kadar yüksekse, sapma tespiti o kadar geç olur)
            this.Cp = 0;  // Pozitif kümülatif toplam
            this.Cn = 0;  // Negatif kümülatif toplam
            this.dataPoints = 0; 
        }

        update(isWin) {
            this.dataPoints++;
            const Xn = isWin ? 1 : 0;

            this.Cp = Math.max(0, this.Cp + (Xn - this.K));
            this.Cn = Math.max(0, this.Cn + ((1 - Xn) - this.K));

            let driftDetected = false;
            if (this.Cp > this.H) {
                // Pozitif sapma: performans beklentinin üzerinde
                driftDetected = false; 
                this.reset(); // Sapma tespit edildiğinde sayaçları sıfırla
            }
            if (this.Cn > this.H) {
                // Negatif sapma: performans beklentinin altında
                driftDetected = true;
                this.reset(); 
            }
            return driftDetected;
        }
        reset() {
            this.Cp = 0;
            this.Cn = 0;
            this.dataPoints = 0;
        }
    }

    // Piyasa Seans Profilleri (Session Profiler)
    class SessionProfiler {
        constructor() {
            this.sessions = {
                'asia': { start: 0, end: 8, name: 'Asya' },    // UTC 00:00 - 08:00
                'europe': { start: 8, end: 13, name: 'Avrupa' }, // UTC 08:00 - 13:00
                'america': { start: 13, end: 22, name: 'Amerika' },// UTC 13:00 - 22:00
                'overlap': { start: 13, end: 16, name: 'Avr-Ame Çakışması' }, // UTC 13:00 - 16:00 (overlap)
                'transition': { start: 22, end: 24, name: 'Geçiş' } // UTC 22:00 - 00:00
            };
        }

        getCurrentSession() {
            const now = new Date();
            const utcHour = now.getUTCHours();

            if (utcHour >= this.sessions.overlap.start && utcHour < this.sessions.overlap.end) {
                return this.sessions.overlap.name;
            } else if (utcHour >= this.sessions.america.start && utcHour < this.sessions.america.end) {
                return this.sessions.america.name;
            } else if (utcHour >= this.sessions.europe.start && utcHour < this.sessions.europe.end) {
                return this.sessions.europe.name;
            } else if (utcHour >= this.sessions.asia.start && utcHour < this.sessions.asia.end) {
                return this.sessions.asia.name;
            } else {
                return this.sessions.transition.name;
            }
        }
    }

    // Risk Koruyucu (Risk Guardian - Kill Switch)
    class RiskGuardian {
        constructor(bot) {
            this.bot = bot;
            this.killSwitchActivated = false;
        }

        checkKillSwitch() {
            if (!this.bot.settings.features.enableRiskGuardian) {
                this.killSwitchActivated = false;
                return;
            }

            const totalSignals = this.bot.stats.total;
            const tpSignals = this.bot.stats.tp;
            const slSignals = this.bot.stats.sl;

            const winRate = totalSignals > 0 ? (tpSignals / totalSignals) * 100 : 0;
            const drawdownWinRateThreshold = this.bot.settings.riskGuardian.killSwitchWinRate;

            if (totalSignals >= 5 && winRate < drawdownWinRateThreshold && !this.killSwitchActivated) {
                this.killSwitchActivated = true;
                this.bot.showNotification(`!!! ACİL DURDURMA !!! Kazanma oranı ${winRate.toFixed(1)}% (${drawdownWinRateThreshold}% altı). Sistem durduruldu.`, 'danger');
                this.bot.speak(`Uyarı! Acil durdurma Protokolü aktif edildi. Kazanma oranı eşiğin altında. Sistemi acilen kontrol edin.`);
                this.bot.stop();
                return true;
            }
            return false;
        }
    }


    /* =========================
       STRATEJİLER
       ========================= */
    class Strategy {
        constructor(bot, name) { 
            this.bot = bot; this.name = name; this.displayName = this._getDisplayName(name); 
            this.lastProposalTime = {};
            this.DEFAULT_PROPOSAL_COOLDOWN_MS = 10000; // dynamic baseline
            this._isLive = false; // NEW: Stratejinin aktif olup olmadığını belirten flag
        }

        // NEW: Bu metot, UTC tarafından çağrılacak ve stratejinin canlı sinyal gönderip göndermeyeceğini belirleyecek.
        setIsLive(status) {
            this._isLive = status;
        }

        propose(symbol, direction, reason, score) {
            // Her durumda, stratejinin öneri sayacını artır. Bu, pasif stratejilerin bile "veri toplamasını" sağlar.
            const s = this.bot.strategyStats[this.name] || { alpha:3, beta:2, proposals:0, contrib:0, wins:0, losses:0, lastUpdate: Date.now() };
            s.proposals = (s.proposals || 0) + 1; 
            s.lastUpdate = Date.now();
            this.bot.strategyStats[this.name] = s;
            this.bot.saveStrategyStats(); // Her öneride kaydetmek yerine periyodik kaydetme daha iyi olabilir, şimdilik böyle kalsın.

            // Eğer strateji "canlı" değilse, yani aktif olarak sinyal üretmiyorsa, burada dur.
            if (!this._isLive) {
                return;
            }

            // Eğer risk koruyucu aktifse ve sinyal vermeyi engelliyorsa, propose etme
            if (this.bot.settings.features.enableRiskGuardian && this.bot.riskGuardian.killSwitchActivated) {
                return;
            }

            const now = Date.now(); 
            const key = `${symbol}-${direction}`;
            const cooldown = (this.DEFAULT_PROPOSAL_COOLDOWN_MS ?? 10000);
            // Sadece canlı sinyaller için cooldown kontrolü
            if (now - (this.lastProposalTime[key] || 0) < cooldown) return;
            
            this.bot.confluenceEngine.propose(this.name, direction, reason, score);
            this.lastProposalTime[key] = now;
        }
        _getDisplayName(name) { return name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); }
        analyzeOrderBook(orderBook) {}
        processTrade(trade) {}
        periodicAnalyze() {}
    }

    class WallBounceStrategy extends Strategy {
        constructor(bot) { super(bot, 'wallBounce'); this.DISTANCE_THRESHOLD_PERCENT = 0.05 / 100; }
        analyzeOrderBook(orderBook) {
            const currentPrice = this.bot.marketData.price; if (!currentPrice) return;
            const btcPrice = this.bot.marketData.btcPrice || 70000;
            const wallQuantityThreshold = (this.bot.settings.params.wallBtc * btcPrice) / currentPrice;
            for (const [price, qty] of orderBook.asks) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (price - currentPrice) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'sell', `Satış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
            for (const [price, qty] of orderBook.bids) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (currentPrice - price) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'buy', `Alış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
        }
    }
    class VelocityScalpingStrategy extends Strategy {
        constructor(bot) { super(bot, 'velocityScalping'); this.pricePoints = []; this.VELOCITY_WINDOW_MS = 2000; this.MIN_POINTS = 20; this.VELOCITY_THRESHOLD_PERCENT = 0.10 / 100; }
        processTrade(trade) {
            const now = Date.now(); 
            this.pricePoints.push({ time: now, price: trade.price }); 
            this.pricePoints = this.pricePoints.filter(p => now - p.time < this.VELOCITY_WINDOW_MS); 
            if (this.pricePoints.length < this.MIN_POINTS) return;
            const firstPoint = this.pricePoints[0]; const lastPoint = this.pricePoints[this.pricePoints.length - 1]; 
            const priceChange = (lastPoint.price - firstPoint.price) / firstPoint.price;
            if (priceChange > this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'buy', `Fiyat Hızı: +${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            } else if (priceChange < -this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'sell', `Fiyat Hızı: ${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            }
        }
    }
    class RsiDivergenceStrategy extends Strategy {
        constructor(bot) { super(bot, 'rsiDivergence'); }
        periodicAnalyze() {
            const candles = this.bot.candles; const rsiValues = this.bot.indicators.rsi; const lookback = this.bot.settings.params.rsiPeriod;
            // RSI değerlerinin son lookback kadarını alalım
            const recentRsi = rsiValues.slice(-lookback);
            if (!rsiValues || recentRsi.length < lookback || !candles || candles.length < lookback) return;
            
            const lastCandle = candles[candles.length - 1]; 
            const prevCandle = candles[candles.length - lookback]; 
            const lastRsi = recentRsi[recentRsi.length - 1]; 
            const prevRsi = recentRsi[0]; // lookback döneminin başındaki RSI

            if (!lastCandle || !prevCandle || !isFinite(lastRsi) || !isFinite(prevRsi)) return;

            // Ayı Uyuşmazlığı: Fiyat daha yüksek tepe yaparken, RSI daha düşük tepe yapar.
            if (lastCandle.high > prevCandle.high && lastRsi < prevRsi) { 
                this.propose(this.bot.currentSymbol, 'sell', 'RSI Ayı Uyuşmazlığı', 5); 
            }
            // Boğa Uyuşmazlığı: Fiyat daha düşük dip yaparken, RSI daha yüksek dip yapar.
            if (lastCandle.low < prevCandle.low && lastRsi > prevRsi) { 
                this.propose(this.bot.currentSymbol, 'buy', 'RSI Boğa Uyuşmazlığı', 5); 
            }
        }
    }
    class OrderFlowMomentumStrategy extends Strategy {
        constructor(bot) { super(bot, 'orderFlowMomentum'); this.trades = []; this.WINDOW_MS = 5000; }
        processTrade(trade) {
            const now = Date.now(); 
            this.trades.push(trade); 
            this.trades = this.trades.filter(t => now - t.timestamp < this.WINDOW_MS); 
            if (this.trades.length < 50) return;
            const buys = this.trades.filter(t => !t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0); 
            const sells = this.trades.filter(t => t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0);
            const total = buys + sells; if (total === 0) return; 
            if (buys / total > 0.7) { this.propose(this.bot.currentSymbol, 'buy', `Alıcı Akışı: %${(buys / total * 100).toFixed(0)}`, 4); this.trades = []; }
            else if (sells / total > 0.7) { this.propose(this.bot.currentSymbol, 'sell', `Satıcı Akışı: %${(sells / total * 100).toFixed(0)}`, 4); this.trades = []; }
        }
    }
    class LiquidityGapsStrategy extends Strategy {
        constructor(bot) { super(bot, 'liquidityGaps'); this.GAP_THRESHOLD_PERCENT = 0.1 / 100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.asks || orderBook.asks.length === 0 || !orderBook.bids || orderBook.bids.length === 0) return;

            for (let i = 0; i < orderBook.asks.length - 1; i++) { 
                const gap = orderBook.asks[i + 1][0] - orderBook.asks[i][0]; 
                if ((gap / orderBook.asks[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'buy', `Likidite Boşluğu ${orderBook.asks[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.asks[i][0]))}`, 3); return; 
                } 
            }
            for (let i = 0; i < orderBook.bids.length - 1; i++) { 
                const gap = orderBook.bids[i][0] - orderBook.bids[i + 1][0]; 
                if ((gap / orderBook.bids[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'sell', `Likidite Boşluğu ${orderBook.bids[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.bids[i][0]))}`, 3); return; 
                } 
            }
        }
    }
    class BreakoutPatternStrategy extends Strategy {
        constructor(bot) { super(bot, 'breakoutPattern'); this.LOOKBACK = 30; this.VOL_SPIKE = 1.4; this.BREAK_PCT = 0.03/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK + 1) return;
            const recent = c.slice(-this.LOOKBACK-1);
            const highs = recent.map(x=>x.high), lows = recent.map(x=>x.low), vols = recent.map(x=>x.volume);
            const last = recent[recent.length-1]; 
            const maxH = Math.max(...highs.slice(0, -1)); const minL = Math.min(...lows.slice(0, -1));
            const volSma = vols.reduce((a,b)=>a+b,0) / (vols.length-1); // Moved outside if/else
            if (last.close > maxH * (1 + this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'buy', 'Aralık Üstü Hacimli Kırılım', 4);
            } else if (last.close < minL * (1 - this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'sell', 'Aralık Altı Hacimli Kırılım', 4);
            }
        }
    }
    class SupportResistanceStrategy extends Strategy {
        constructor(bot) { super(bot, 'supportResistance'); this.LOOKBACK = 60; this.THRESH = 0.15/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            const last = slice[slice.length-1];
            const maxH = Math.max(...slice.map(x=>x.high)); const minL = Math.min(...slice.map(x=>x.low));
            const distTop = (maxH - last.close)/last.close; const distBot = (last.close - minL)/last.close;
            if (distTop >= 0 && distTop < this.THRESH && last.close < last.open) { // Direnç bölgesinde reddedilme (ayı sinyali)
                this.propose(this.bot.currentSymbol, 'sell', 'Direnç Bölgesi Reddi', 3);
            }
            if (distBot >= 0 && distBot < this.THRESH && last.close > last.open) { // Destek bölgesinde tepki (boğa sinyali)
                this.propose(this.bot.currentSymbol, 'buy', 'Destek Bölgesi Tepkisi', 3);
            }
        }
    }
    class FibonacciRetracementStrategy extends Strategy {
        constructor(bot) { super(bot, 'fibonacciRetracement'); this.LOOKBACK = 120; this.TOL = 0.2/100; this.levels = [0.382, 0.5, 0.618]; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            let high = -Infinity, low = Infinity, hT=0, lT=0;
            slice.forEach(k => { if(k.high > high){high=k.high; hT=k.time;} if(k.low < low){low=k.low; lT=k.time;} });
            if (!isFinite(high) || !isFinite(low) || high===low) return;
            const last = slice[slice.length-1];
            if (hT > lT) { // uptrend: low -> high
                const retr = (high - last.close) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'buy', `Fibo ${Math.round(L*100)}% Bölgesi`, 3); break; }
                }
            } else { // downtrend: high -> low
                const retr = (last.close - low) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'sell', `Fibo ${Math.round(L*100)}% Bölgesi`, 3); break; }
                }
            }
        }
    }
    class VolumeProfileStrategy extends Strategy {
        constructor(bot) { super(bot, 'volumeProfile'); this.PERIOD = 20; this.SPIKE = 2.0; this.CLOSE_POS = 0.7; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.PERIOD + 1) return;
            const last = c[c.length-1];
            const vols = c.slice(-this.PERIOD-1, -1).map(x=>x.volume);
            const volSma = vols.reduce((a,b)=>a+b,0)/vols.length;
            if (last.volume > volSma * this.SPIKE && (last.close - last.low) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'buy', 'Hacim Spike - Üst Kapanış', 3);
            } else if (last.volume > volSma * this.SPIKE && (last.high - last.close) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'sell', 'Hacim Spike - Alt Kapanış', 3);
            }
        }
    }
    class SmartMoneyConceptsStrategy extends Strategy {
        constructor(bot) { super(bot, 'smartMoneyConcepts'); this.GAP_MIN_PCT = 0.05/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 3) return;
            const a = c[c.length-3], b = c[c.length-2], d = c[c.length-1];
            // Fair Value Gap (FVG) - Bullish
            if ((d.low - b.high > 0) && (b.low - a.high > 0) && ((d.low - a.high)/Math.max(1e-8, d.low) > this.GAP_MIN_PCT)) {
                 this.propose(this.bot.currentSymbol, 'buy', 'Bullish FVG (IMB)', 4);
            }
            // Fair Value Gap (FVG) - Bearish
            if ((a.low - b.high > 0) && (b.low - d.high > 0) && ((a.low - d.high)/Math.max(1e-8, d.high) > this.GAP_MIN_PCT)) {
                this.propose(this.bot.currentSymbol, 'sell', 'Bearish FVG (IMB)', 4);
            }
        }
    }
    class DivergenceDetectionStrategy extends Strategy {
        constructor(bot) { super(bot, 'divergenceDetection'); this.LOOKBACK = 40; this.SWING_PERIOD = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; const rsi = this.bot.indicators.rsi; 
            if (!rsi || c.length < this.LOOKBACK || rsi.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK), r = rsi.slice(-this.LOOKBACK);
            const pivLows = []; const pivHighs = [];
            
            // Pivot noktalarını belirle
            for (let i = this.SWING_PERIOD; i < slice.length - this.SWING_PERIOD; i++) {
                const isPivotLow = slice[i].low < Math.min(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.low)) && 
                                   slice[i].low < Math.min(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.low));
                const isPivotHigh = slice[i].high > Math.max(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.high)) && 
                                    slice[i].high > Math.max(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.high));
                if (isPivotLow) pivLows.push(i);
                if (isPivotHigh) pivHighs.push(i);
            }

            // Boğa Sapması (Bullish Divergence): Fiyat daha düşük dip, RSI daha yüksek dip
            if (pivLows.length >= 2) {
                const i1 = pivLows[pivLows.length-2], i2 = pivLows[pivLows.length-1];
                if (slice[i2].low < slice[i1].low && r[i2] > r[i1]) {
                    this.propose(this.bot.currentSymbol, 'buy', 'Boğa Sapması (RSI)', 5);
                }
            }
            // Ayı Sapması (Bearish Divergence): Fiyat daha yüksek tepe, RSI daha düşük tepe
            if (pivHighs.length >= 2) {
                const i1 = pivHighs[pivHighs.length-2], i2 = pivHighs[pivHighs.length-1];
                if (slice[i2].high > slice[i1].high && r[i2] < r[i1]) {
                    this.propose(this.bot.currentSymbol, 'sell', 'Ayı Sapması (RSI)', 5);
                }
            }
        }
    }
    class MarketStructureStrategy extends Strategy {
        constructor(bot) { super(bot, 'marketStructure'); this.SWING = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 2*this.SWING+5) return;
            const pivotHighs = [], pivotLows = [];
            for (let i = this.SWING; i < c.length - this.SWING; i++) {
                if (c[i].high > Math.max(...c.slice(i-this.SWING, i).map(x=>x.high)) && c[i].high > Math.max(...c.slice(i+1, i+1+this.SWING).map(x=>x.high))) pivotHighs.push(i);
                if (c[i].low < Math.min(...c.slice(i-this.SWING, i).map(x=>x.low)) && c[i].low < Math.min(...c.slice(i+1, i+1+this.SWING).map(x=>x.low))) pivotLows.push(i);
            }
            const last = c[c.length-1];
            if (pivotHighs.length) {
                const ph = c[pivotHighs[pivotHighs.length-1]].high;
                if (last.close > ph) this.propose(this.bot.currentSymbol, 'buy', 'Yapı Kırılımı (BOS Up)', 4);
            }
            if (pivotLows.length) {
                const pl = c[pivotLows[pivotLows.length-1]].low;
                if (last.close < pl) this.propose(this.bot.currentSymbol, 'sell', 'Yapı Kırılımı (BOS Down)', 4);
            }
        }
    }
    class InstitutionalOrderFlowStrategy extends Strategy {
        constructor(bot) { super(bot, 'institutionalOrderFlow'); this.TOP_N = 5; this.IMB_THRESHOLD = 2.0; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const topB = orderBook.bids.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            const topA = orderBook.asks.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            if (topB / Math.max(1e-8, topA) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'buy', 'Orderbook İmbalansı (Bid Ağırlık)', 3);
            } else if (topA / Math.max(1e-8, topB) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'sell', 'Orderbook İmbalansı (Ask Ağırlık)', 3);
            }
        }
    }
    class MicroSpreadArbitrageStrategy extends Strategy {
        constructor(bot) { super(bot, 'microSpreadArbitrage'); this.SPREAD_PCT = 0.08/100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const bestBid = orderBook.bids[0][0], bestAsk = orderBook.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            if (spreadPct > this.SPREAD_PCT) {
                const current = this.bot.marketData.price || mid;
                if (current < mid) this.propose(this.bot.currentSymbol, 'buy', 'Geniş Spread - Mean Reversion', 2);
                else this.propose(this.bot.currentSymbol, 'sell', 'Geniş Spread - Mean Reversion', 2);
            }
        }
    }
    class VWAPReversionStrategy extends Strategy {
        constructor(bot) { super(bot, 'vwapReversion'); this.MULT = 1.0; }
        periodicAnalyze() {
            const price = this.bot.marketData.price, vwap = this.bot.indicators.vwap, atr = this.bot.indicators.atr;
            if (!price || !vwap || !atr) return;
            const dev = atr / price; 
            const diffPct = (price - vwap) / vwap;
            if (diffPct > this.MULT * dev) this.propose(this.bot.currentSymbol, 'sell', 'VWAP Üstü Aşırı Sapma', 3);
            if (diffPct < -this.MULT * dev) this.propose(this.bot.currentSymbol, 'buy', 'VWAP Altı Aşırı Sapma', 3);
        }
    }
    class SuperTrendStrategy extends Strategy {
        constructor(bot) { super(bot, 'superTrend'); this.MULT = 3.0; this.PERIOD = 14; }
        periodicAnalyze() {
            const c = this.bot.candles; const atr = this.bot.indicators.atr;
            if (!atr || c.length < 2) return;
            const last = c[c.length-1];
            const m = (last.high + last.low) / 2;
            const upper = m + this.MULT * atr, lower = m - this.MULT * atr;
            if (last.close > upper) this.propose(this.bot.currentSymbol, 'buy', 'ATR Kanal Üstü Kırılım (SuperTrend)', 4);
            else if (last.close < lower) this.propose(this.bot.currentSymbol, 'sell', 'ATR Kanal Altı Kırılım (SuperTrend)', 4);
        }
    }

    /* =========================
       UYUM MOTORU (CONFLUENCE)
       ========================= */
    class ConfluenceEngine {
        constructor(bot) { 
            this.bot = bot; 
            this.proposals = []; 
            this.lastSignalTime = 0; 
            this.lastSignalTimeByDirection = { buy: 0, sell: 0 };
            this.lastDirection = null;
            this.buyScore = 0; // Canlı sinyal barı için
            this.sellScore = 0; // Canlı sinyal barı için
        }
        propose(strategy, direction, reason, score) {
            const now = Date.now();
            // Aynı stratejinin aynı yönde ardışık tekliflerini güncelle, yinelenenleri önle
            this.proposals = this.proposals.filter(p => !(p.strategy === strategy && p.direction === direction));
            this.proposals.push({ strategy, direction, reason, score, timestamp: now });
            // strategyStats.proposals burada artık Strategy sınıfı içinden güncelleniyor, çünkü tüm öneriler takip ediliyor.
            // Sadece confluence engine'e gelen (yani aktif stratejiden gelen) önerilerin cooldown kontrolünü yap.
            this.checkConfluence();
        }

        _computeDirectional(direction) {
            const now = Date.now();
            const decaySec = this.bot.settings.optimization.timeDecaySec || 3;
            const groupSums = { trending: 0, meanReversion: 0, neutral: 0 };
            const used = [];

            // Sadece canlı (active) stratejilerin tekliflerini değerlendir.
            const activeProposals = this.proposals.filter(p => {
                const strategyInstance = this.bot.strategies[p.strategy];
                return strategyInstance && strategyInstance._isLive && p.direction === direction;
            });

            for (const p of activeProposals) {
                const w = this.bot.getStrategyWeight(p.strategy);
                const ageSec = (now - p.timestamp)/1000;
                const decay = Math.exp(-ageSec / decaySec);
                const eff = p.score * w * decay;
                const grp = this.bot.getStrategyGroup(p.strategy);
                groupSums[grp] = (groupSums[grp] || 0) + eff;
                used.push({ strategy: p.strategy, baseScore: p.score, weight: w, decay, effScore: eff });
            }
            const score = Object.values(groupSums).reduce((sum, val) => sum + val, 0); 
            
            return { score, contributors: used, groupSums };
        }

        checkConfluence() {
            const now = Date.now();
            const cd = this.bot.settings?.cooldowns || {};
            const proposalTimeout = cd.proposalTimeoutMs ?? 3000;
            const signalCooldown = cd.signalMs ?? 15000;
            const sameDirCooldown = cd.sameDirectionMs ?? 30000;
            const oppCooldown = cd.oppositeDirectionMs ?? 20000;
            const reverseHys = cd.reverseHysteresisPoints ?? 2;
            const dirMargin = this.bot.settings.optimization.dirMargin ?? 0.5; // Yönler arası minimum fark
            const minThreshold = this.bot.getEffectiveThreshold();

            // Sinyal genel cooldown kontrolü
            if (now - this.lastSignalTime < signalCooldown) return;
            
            // Eski teklifleri temizle
            this.proposals = this.proposals.filter(p => now - p.timestamp < proposalTimeout);

            const buy = this._computeDirectional('buy');
            const sell = this._computeDirectional('sell');

            const buyPenalty = this.bot.settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('buy') : 0;
            const sellPenalty = this.bot.settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('sell') : 0;

            const buyScoreAdj = buy.score - buyPenalty;
            const sellScoreAdj = sell.score - sellPenalty;

            // Güncel skorları sinyal barı için tut
            this.buyScore = buyScoreAdj;
            this.sellScore = sellScoreAdj;

            if (buyScoreAdj >= minThreshold && (buyScoreAdj > sellScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.buy < sameDirCooldown) return;
                // Ters yönden geliyorsak ek histerezis kontrolü
                if (this.lastDirection === 'sell' && (now - this.lastSignalTime) < oppCooldown) {
                    if (buyScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('buy', buy.contributors, buyScoreAdj);
            } else if (sellScoreAdj >= minThreshold && (sellScoreAdj > buyScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.sell < sameDirCooldown) return;
                if (this.lastDirection === 'buy' && (now - this.lastSignalTime) < oppCooldown) {
                    if (sellScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('sell', sell.contributors, sellScoreAdj);
            }
        }

        generateFinalSignal(direction, contributors, finalScore) {
            const contributingStrats = contributors.map(c => this.bot.strategies[c.strategy]?.displayName || c.strategy).join(', ');

            const signal = { 
                id: `sig_${Date.now()}`, timestamp: Date.now(), symbol: this.bot.currentSymbol, 
                direction, price: this.bot.marketData.price, score: finalScore, 
                reason: contributingStrats, contributors, status: 'active', note: '',
                mfeR: 0, beDone: false, trailingStage: 0, entrySlDistance: 0, entryTpDistance: 0
            };
            this.bot.calculateDynamicTpSl(signal);
            this.bot.addFinalSignal(signal);

            this.proposals = []; // Sinyal üretildikten sonra tüm teklifleri temizle
            const now = Date.now();
            this.lastSignalTime = now;
            this.lastSignalTimeByDirection[direction] = now;
            this.lastDirection = direction;
        }
    }

    /* =========================
       ANA UYGULAMA
       ========================= */
    class UltimateTradingCommandCenter {
        constructor() {
            this.allStrategiesMap = {
                'wallBounce': WallBounceStrategy, 'velocityScalping': VelocityScalpingStrategy, 'rsiDivergence': RsiDivergenceStrategy, 
                'orderFlowMomentum': OrderFlowMomentumStrategy, 'liquidityGaps': LiquidityGapsStrategy, 'fibonacciRetracement': FibonacciRetracementStrategy, 
                'volumeProfile': VolumeProfileStrategy, 'smartMoneyConcepts': SmartMoneyConceptsStrategy, 'divergenceDetection': DivergenceDetectionStrategy, 
                'breakoutPattern': BreakoutPatternStrategy, 'supportResistance': SupportResistanceStrategy, 'marketStructure': MarketStructureStrategy, 
                'institutionalOrderFlow': InstitutionalOrderFlowStrategy, 'microSpreadArbitrage': MicroSpreadArbitrageStrategy,
                'vwapReversion': VWAPReversionStrategy, 'superTrend': SuperTrendStrategy
            };
            this.allStrategyKeys = Object.keys(this.allStrategiesMap); 

            this.isRunning = false; 
            this.sockets = {}; 
            
            this.currentSymbol = this.loadData('utc_current_symbol') || 'BTCUSDT'; 
            this.currentTimeframe = this.loadData('utc_current_timeframe') || '15m';
            this.headerCollapsed = this.loadData('utc_header_collapsed') !== null ? (this.loadData('utc_header_collapsed') === 'true') : true; 
            this.currentMainView = this.loadData('utc_current_view') || 'chart';

            this.marketData = { price: 0, change24h: 0, volume24h: 0, symbol: this.currentSymbol, btcPrice: 70000 }; 
            // Previous structure which receives snapshots directly.
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 

            this.aggTrades = []; 
            this.candles = [];
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null }; 
            this.signals = this.loadData('utc_signals') || [];
            this.stats = this.loadData('utc_stats') || { total: 0, tp: 0, sl: 0 };

            // Performans öğrenme
            this.strategyStats = this.loadData('utc_strategy_stats') || this.initDefaultStrategyStats();
            this.marketRegime = 'unknown'; // trend, range, unknown
            this.riskState = 'neutral'; // conservative, neutral, aggressive
            this.sessionState = 'unknown'; // Asia, Europe, America, Overlap, Transition

            this.strategyGroups = {
                trending: ['breakoutPattern','orderFlowMomentum','marketStructure','volumeProfile','smartMoneyConcepts','superTrend'],
                meanReversion: ['vwapReversion','wallBounce','liquidityGaps','fibonacciRetracement','supportResistance','microSpreadArbitrage','divergenceDetection','rsiDivergence','institutionalOrderFlow']
            };
            
            this.settings = this.loadSettings();
            this.strategies = {}; 
            
            this.combatModeActive = false;
            this.reconnectAttempts = 0;
            this.reconnectDelay = 3000;

            // Gelişmiş Özelliklerin Başlatılması
            this.chartManager = new ChartManager('live-chart');
            this.heatmapManager = new HeatmapManager('orderbook-heatmap');
            this.confluenceEngine = new ConfluenceEngine(this);
            this.multiTimeframeManager = new MultiTimeframeManager(this); 
            this.spoofDetector = new SpoofDetector(this);               
            this.cusumDetector = new CUSUMDriftDetector();               
            this.sessionProfiler = new SessionProfiler();                 
            this.riskGuardian = new RiskGuardian(this);                   
            
            this.renderInterval = null; 
            this.analysisInterval = null;
            this.cooldownTuneInterval = null;
            this.thresholdTuneInterval = null;
            this.sessionUpdateInterval = null;
            this.countdownInterval = null; 

            this.lastAutoToggleTs = 0;
            this.runtimeThresholdOffset = 0; 

            // TTS (Text-to-Speech) için
            this.synth = window.speechSynthesis || null; 
            this.speechQueue = [];
            this.isSpeaking = false;
            this.voices = []; // Ses listesini burada tutacağız
            
            // Konuşma metinleri veritabanı - Sadeleştirilmiş ve düzenlenmiş metinler
            this.speechTexts = {
                buy: [
                    "Harika bir fırsat! [Sembol] için alım sinyali geldi. Yeşil ışık yanıyor! Skor [Skor].",
                    "Piyasa nefes aldı, [Sembol] yükselişe geçiyor. Bu trene binmek ister misin? Skor [Skor].",
                    "Komutanım, hesaplamalar net: [Sembol] için güçlü bir alım. Devler uyanıyor! Skor [Skor].",
                    "Cüzdanlarınıza dikkat, [Sembol] için bir yükseliş trendi başlangıcı. Fırsat kapınızı çaldı! Skor [Skor].",
                    "Gözünü dört aç! [Sembol] için büyük bir potansiyel görüyorum. Roket kalkışa hazır! Skor [Skor].",
                    "Bugün şanslı günün olabilir! [Sembol] alım için çağırıyor. İç sesine kulak ver! Skor [Skor].",
                    "Duy sesimi Komutanım! [Sembol] için alım sinyali. Hadi, pazarın nabzını tutalım! Skor [Skor].",
                    "Piyasa dans etmeye başladı, [Sembol] yükselişle eşlik ediyor. Katılmak ister misin? Skor [Skor].",
                    "Bana güven, [Sembol] için enerji pozitif. Bu işlemi kaçırmak istemezsin. Skor [Skor].",
                    "Ulan [Sembol] için alım sinyali patladı, hala ne bekliyorsun lanet olası! Kalk ve parayı kap, yoksa pişmanlık seni yer bitirir! Skor [Skor]."
                ],
                sell: [
                    "Piyasa biraz yorulmuş gibi, [Sembol] için satış sinyali geldi. Karları garantiye alalım! Skor [Skor].",
                    "Komutanım, [Sembol] için aşağı yönlü bir hareketlilik bekliyorum. Tetikte ol! Skor [Skor].",
                    "Bazen geri çekilmek de kazanmaktır. [Sembol] için satış vakti. Parçaları topluyoruz! Skor [Skor].",
                    "Bir fırtına yaklaşıyor olabilir, [Sembol] için satış sinyali. Kendini güvende tut! Skor [Skor].",
                    "Akıllıca bir adım! [Sembol] için kazançları koruma zamanı. Hızlı ve isabetli olalım. Skor [Skor].",
                    "Piyasa nazikçe fısıldıyor: [Sembol] için biraz ara ver. Karını koru! Skor [Skor].",
                    "Riskleri minimize etmenin zamanı geldi. [Sembol] için satış önerisi. Gerekirse tekrar gireriz. Skor [Skor].",
                    "Satış sinyali geldi. Umarım boğalar çimlere basmamıştır! [Sembol] için. Skor [Skor].",
                    "Ulan [Sembol] düşüyor, hala mı tutuyorsun lanet olası aptal! Sat da kurtul, yoksa cebin boşalır sinirlenme bana! Skor [Skor].",
                    "Siktir et o umudunu, [Sembol] satış sinyali verdi! Sert ol, çık ve karı kap, motive ol lan yoksa kaybedersin! Skor [Skor]."
                ],
                combatModeActivate: [
                    "Kumandanım, Kırmızı Alarm! Savaş Modu aktive edildi! Piyasanın kalbi şimdi elimizde!",
                    "Sistem uyarısı: Ultra savaş modu devrede! Piyasa savaşı başlıyor! Her bir strateji tam kapasite!",
                    "Savaş Modu Başladı! İleri Komutanım! Tüm güçler hazır, her anı avantaja çevireceğiz!",
                    "Hazırlanın! Savaş Modu aktive edildi. Bu bir zihin oyunu ve biz kazanacağız! Odaklanma ve hız, anahtarımız!",
                    "Ulan savaş modu aktive! Piyasa seni ezmeye çalışıyor ama biz daha sertiz lan, kalk ayağa ve piyasayı sikert! Zafer bizim olacak!"
                ],
                combatModeDeactivate: [
                    "Savaş modu başarıyla sonlandırıldı. Piyasa koşulları normale dönüyor, normal operasyonlara geri dönüyoruz. İyi iş çıkardınız.",
                    "Operasyon sonu. Savaş modu kapatıldı. Şimdi piyasanın sakin sularında yüzme zamanı.",
                    "Savaş modu devre dışı. Riskler azaldı, piyasa sakinleşiyor. Sakin sularda bile fırsatlar vardır, unutmayın.",
                    "Kumandanım, savaş bitti. Kazanılmış bir zaferin ardından dinlenme vakti. Bir sonraki mücadeleye kadar hazırız.",
                    "Ulan savaş modu kapandı, hala mı sinirli duruyorsun lan? Rahatla Komutanım, zaferi kutla yoksa ben sinirlenirim sana da!"
                ],
                signalTP: [
                    "Hedef vuruldu! TP geldi, Komutanım! Bu başarı sizin stratejik dehanızın kanıtı!",
                    "Tebrikler! Kar realizasyonu gerçekleşti. Şimdi kahve içme zamanı, zafer sizin!",
                    "TP alarmı! Kazanç cebinizde, piyasa artık bizim kontrolümüzde. Harika iş!",
                    "Boom! TP hedefi tutturuldu. Strateji kusursuz, Komutanım lider!",
                    "Kar alındı! Zekânız ve disiplininizle piyasanın kalbini fethettiniz!",
                    "Ulan TP vuruldu, para cebinde lan! Sinirliydim piyasaya ama sen ezerdin, motive ol da kutla zaferi Komutanım!"
                ],
                signalSL: [
                    "SL tetiklendi! Savaş kaybedilmiş değil, ders alınmış! Komutanım, hazırlanın ve tekrar saldırın!",
                    "Stop Loss aktif. Kaybedilen bir savaş değil, bir sonraki zaferin başlangıcı!",
                    "SL geldi, ama moral bozulmasın. Bu sadece piyasanın egonuzu test etmesi!",
                    "Kaybı kabul et, ama pes etme. SL tetiklendi, stratejiyi yeniden şekillendiriyoruz!",
                    "SL alarmı! Hedefi kaybettik ama deneyim kazandık, Komutanım!",
                    "Ulan SL tetiklendi, para gitti lan! Sinirliyim piyasaya ama sen pes etme, motive ol da tekrar saldır Komutanım!"
                ],
                cusumDriftDetected: [
                    "CUSUM drift tespit edildi! Komutanım, piyasa dalgalanıyor ama biz her zaman hazırız!",
                    "Sinyal değişimi geldi, dikkat! Bu bir fırsat ya da ders, sizin kararınız!",
                    "CUSUM alarmı! Strateji tetikte, piyasa bizi test ediyor ama biz kazanmaya odaklıyız!",
                    "Drift detected! Piyasa kıvılcımları uçuşuyor, Komutanım, kontrol sizde!",
                    "Ulan CUSUM drift patladı, piyasa dalgalanıyor lan! Sinirliyim ulan, ama motive ol da hazır ol, fırsat mı ders mi sen karar ver!"
                ],
                autoToggleDeactivate: [
                    "Optimizasyon uyarısı: [Strateji Adı] stratejisi beklenen performansı göstermedi. Geçici olarak pasif edildi.",
                    "[Strateji Adı] stratejisi, performans testinden geçemedi. Geçici olarak emekli edildi. Dikkatli olalım.",
                    "Bir strateji daha devredışı. [Strateji Adı] şu an için dinlenmeye alındı. Daha iyi günler için bekliyoruz.",
                    "Ulan [Strateji Adı] performansı sıçtı, pasif edildi lan! Sinirliyim ulan, ama motive ol da bekle, en iyisi bu!"
                ],
                autoToggleActivate: [
                    "Optimizasyon başarıyla tamamlandı: [Strateji Adı] stratejisi tekrar aktif edildi. Yeni veriler çok umut verici!",
                    "Müjde! [Strateji Adı] stratejisi tekrar göreve hazır! Performansı yükselişte. Hadi bakalım, piyasayı sallayalım!",
                    "Hoş geldin geri [Strateji Adı]! Kendini toparlamışsın. Tekrar aktif edildi. Şimdi bize neler göstereceksin merak ediyorum.",
                    "Ulan [Strateji Adı] geri döndü, aktif edildi lan! Sinirliydim yokluğunda ama motive ol da sallayalım piyasayı, zafer yakın ulan!"
                ],
                cooldownOptimize: [
                    "Sistem, soğuma sürelerini başarıyla yeniden ayarladı. Piyasanın nabzına göre şimdiden optimize edildik Komutanım.",
                    "Cooldown ayarları güncellendi. Artık sinyaller arasında daha zeki bir denge kuruyoruz. Ben bu işi biliyorum!",
                    "Piyasa ritmini değiştirdi, biz de cooldown sürelerimizi. Tam senkronizasyon için her şey ayarlandı Komutanım.",
                    "Ulan cooldown süreleri ayarlandı lan! Sinirliydim piyasanın ritmine ama optimize ettik, motive ol da dans pistinde ezeriz hepsini Komutanım!"
                ],
                systemStart: [
                    "Sistem başlatıldı. Canlı veri akışı başlıyor. Gözlerim ve kulaklarım piyasada Komutanım.",
                    "Başlatma tamamlandı. Piyasa analizine başlıyorum. Bana güvenebilirsin.",
                    "Uyanıyorum... Tüm sensörler aktif. Piyasa maceramız şimdi başlıyor!",
                    "Ulan sistem başladı lan! Sinirliydim uykuda ama şimdi canlı veri akıyor, motive ol da piyasayı ezeriz Komutanım!"
                ],
                systemStop: [
                    "Sistem durduruldu. Operasyonlar askıya alındı. Bir mola verelim Komutanım.",
                    "Kapanış prosedürü aktif. Veri akışı durduruldu. Daha sonra görüşmek üzere!",
                    "Enerji tasarrufu modu. Sistem kapanıyor. İhtiyaç duyduğunuzda beni tekrar başlatabilirsiniz.",
                    "Ulan sistem durduruldu lan! Sinirliydim piyasaya ama şimdi mola ver, motive ol da dinlen Komutanım yoksa ezerim seni yorgunlukla!"
                ],
                symbolChange: [
                    "Sembol [Sembol] olarak değiştirildi. Yeni bir maceraya hazırız.",
                    "Hedef [Sembol] olarak güncellendi. Adaptasyon tamamlandı. Şimdi bu sembole odaklanıyoruz.",
                    "Sembol değişimi: [Sembol]. Her zaman yeni bir meydan okumaya açığım.",
                    "Ulan sembol [Sembol] oldu lan! Sinirliydim eskisine ama şimdi motive ol da yeni maceraya atıl, ezeriz piyasayı Komutanım!"
                ],
                timeframeChange: [
                    "Zaman aralığı [Timeframe] olarak değiştirildi. Daha büyük veya küçük resme odaklanıyoruz.",
                    "Mum çubuğu zaman dilimi [Timeframe] olarak ayarlandı. Bakış açımızı güncelledik.",
                    "[Timeframe] zaman dilimindeyiz. Piyasanın farklı bir yüzünü keşfediyoruz.",
                    "Ulan zaman aralığı [Timeframe] oldu lan! Sinirliydim eskisine ama şimdi motive ol da büyük resme odaklan, ezeriz piyasayı Komutanım!"
                ],
                resetAll: [
                    "Tüm ayarlar sıfırlandı. Sistem yeniden başlatılmaya hazır. Temiz bir sayfa açtık Komutanım.",
                    "Ulan tüm ayarlar sıfırlandı lan! Sinirliydim karmaşaya ama şimdi motive ol da temiz sayfaya atıl, ezeriz piyasayı Komutanım!"
                ]
            };

            this.init();
        }

        initDefaultStrategyStats() {
            const stats = {};
            (this.allStrategyKeys || []).forEach(k => {
                stats[k] = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, lastUpdate: Date.now() };
            });
            return stats;
        }
        saveStrategyStats() { this.saveData('utc_strategy_stats', this.strategyStats); }

        getStrategyGroup(key) {
            if (this.strategyGroups.trending.includes(key)) return 'trending';
            if (this.strategyGroups.meanReversion.includes(key)) return 'meanReversion';
            return 'neutral';
        }
        getGroupBoost(key) {
            const grp = this.getStrategyGroup(key);
            let boost = 1.0;
            // Rejim boost
            if (this.marketRegime === 'trend' && grp === 'trending') boost *= 1.15;
            if (this.marketRegime === 'range' && grp === 'meanReversion') boost *= 1.15;
            // ATR göre adaptif boost
            const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0;
            if (atrPct < 0.005) { // düşük vol
                if (grp === 'trending') boost *= 0.9;
                if (grp === 'meanReversion') boost *= 1.05;
            } else if (atrPct > 0.02) { // yüksek vol
                if (grp === 'trending') boost *= 1.05;
                if (grp === 'meanReversion') boost *= 0.95;
            }
            return boost;
        }
        getStrategyWeight(name) {
            const s = this.strategyStats[name] || { alpha: 3, beta: 2 };
            const mean = s.alpha / (s.alpha + s.beta);
            const totalObservations = s.alpha + s.beta;
            // Stratejinin yeterince veri toplayıp toplamadığına dair güvenilirlik cezası
            const uncertaintyPenalty = totalObservations < 10 ? 0.5 + (totalObservations / 10) * 0.5 : 1.0; 

            let w = (0.5 + mean) * uncertaintyPenalty; 
            w *= this.getGroupBoost(name);
            w = Math.max(0.3, Math.min(2.0, w)); 
            return w;
        }

        init() {
            this.initStrategies(); 
            this.setupUI(); 
            this.setupEventListeners();
            this.renderSignals(true); 
            this.renderStats(true);
            this.logToJournal('Sistem hazır. "SİSTEMİ BAŞLAT" butonuna tıklayın.');
            
            if (this.headerCollapsed) document.body.classList.add('header-collapsed'); else document.body.classList.remove('header-collapsed');
            this.switchMainView(this.currentMainView);
            this.sessionUpdateInterval = setInterval(() => this.updateSession(), 60000); 
            this.updateSession(); 

            this.countdownInterval = setInterval(() => this.updateCandleCountdown(), 1000);

            // TTS API desteği varsa sesleri yükle
            if (this.synth) {
                this.loadVoices();
            } else {
                console.warn('SpeechSynthesis API bu tarayıcı/cihazda desteklenmiyor.');
                // UI'daki TTS düğmesini devre dışı bırak
                document.addEventListener('DOMContentLoaded', () => {
                    const ttsToggle = document.getElementById('modal-enable-tts');
                    if (ttsToggle) {
                        ttsToggle.checked = false; // Ayarı kapat
                        ttsToggle.disabled = true; // Kontrolü devre dışı bırak
                        ttsToggle.closest('.form-group').querySelector('.checkbox-label').style.color = 'var(--text-secondary)'; // Grileştir
                    }
                });
            }
        }

        initStrategies() { 
            // Tüm strateji örneklerini oluştur ve this.strategies'e kaydet
            for (const key in this.allStrategiesMap) { 
                this.strategies[key] = new this.allStrategiesMap[key](this); 
            } 
            // Aktif stratejiler flag'ini ayarla
            this.updateActiveStrategies(); 
        }

        updateActiveStrategies() { 
            // Tüm stratejilerin varsayılan öneri cooldown'ını ayarla
            for (const key in this.strategies) { 
                this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = this.settings.cooldowns.strategyProposalMs; 
                // Stratejinin aktiflik durumunu güncelle
                this.strategies[key].setIsLive(this.settings.activeStrategies[key] || false);
            } 
        }

        setupUI() {
            document.getElementById('symbol-input').value = this.currentSymbol.replace('USDT', '');
            document.getElementById('timeframe-select').value = this.currentTimeframe;

            this.updateSettingsModalUI();
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme(); 
            this.heatmapManager.updateTheme();
            this.updateSuperTopTicker();
        }
        updateSuperTopTicker() { document.getElementById('ticker-bar-symbol').textContent = this.currentSymbol.replace('USDT', '/USDT'); }

        updateSettingsModalUI() {
            document.getElementById('modal-confluence-threshold').value = this.settings.confluenceThreshold;
            document.getElementById('modal-param-rsi-period').value = this.settings.params.rsiPeriod;
            document.getElementById('modal-param-atr-period').value = this.settings.params.atrPeriod;
            document.getElementById('modal-param-wall-btc').value = this.settings.params.wallBtc;
            document.getElementById('modal-param-rr-ratio').value = this.settings.params.rrRatio;
            document.getElementById('modal-signal-cooldown-ms').value = this.settings.cooldowns.signalMs;
            document.getElementById('modal-same-direction-cooldown-ms').value = this.settings.cooldowns.sameDirectionMs;
            document.getElementById('modal-opposite-direction-cooldown-ms').value = this.settings.cooldowns.oppositeDirectionMs;
            document.getElementById('modal-reverse-hysteresis-points').value = this.settings.cooldowns.reverseHysteresisPoints;
            document.getElementById('modal-proposal-timeout-ms').value = this.settings.cooldowns.proposalTimeoutMs;
            document.getElementById('modal-strategy-proposal-cooldown-ms').value = this.settings.cooldowns.strategyProposalMs;
            // Yeni özellikler için
            document.getElementById('modal-enable-spoof-detection').checked = this.settings.features.enableSpoofDetection;
            document.getElementById('modal-enable-cusum-drift').checked = this.settings.features.enableCUSUMDrift;
            document.getElementById('modal-enable-risk-guardian').checked = this.settings.features.enableRiskGuardian;
            document.getElementById('modal-enable-auto-optimize').checked = this.settings.optimization.enabled;
            document.getElementById('modal-enable-auto-toggle-strat').checked = this.settings.optimization.autoToggle;
            document.getElementById('modal-enable-breakeven-trail').checked = this.settings.optimization.breakeven.enabled;
            document.getElementById('modal-be-at-r').value = this.settings.optimization.breakeven.beAtR;
            document.getElementById('modal-trail-after-r').value = this.settings.optimization.breakeven.trailAfterR;
            document.getElementById('modal-trail-to-r').value = this.settings.optimization.breakeven.trailToR;
            
            // TTS ayarı
            const ttsToggle = document.getElementById('modal-enable-tts');
            if(ttsToggle) {
                ttsToggle.checked = this.settings.features.enableTTS;
                // Eğer TTS API desteklenmiyorsa veya etkin değilse, kontrolü devre dışı bırak
                if (!this.synth || !this.settings.features.enableTTS) {
                    ttsToggle.disabled = true;
                    ttsToggle.closest('.form-group').querySelector('.checkbox-label').style.color = 'var(--text-secondary)';
                } else {
                    ttsToggle.disabled = false;
                    ttsToggle.closest('.form-group').querySelector('.checkbox-label').style.color = 'var(--text-main)';
                }
            }

            // Ses Seçimi dropdown'ını güncellemek için özel fonksiyonu çağır
            this.updateTTSVoiceSelectUI(); 

            const strategyModalContainer = document.getElementById('modal-strategy-toggles');
            strategyModalContainer.innerHTML = '';
            this.allStrategyKeys.forEach(key => { 
                const strategy = this.strategies[key];
                const isChecked = this.settings.activeStrategies[key];
                const toggleHtml = `<div class="form-group"><label class="checkbox-label"><input type="checkbox" class="strategy-toggle" data-strategy-key="${key}" ${isChecked ? 'checked' : ''}> ${strategy.displayName}</label></div>`;
                strategyModalContainer.innerHTML += toggleHtml;
            });
            this.renderSignals(true); 
            this.renderStats(true);   
        }

        setupEventListeners() {
            document.getElementById('start-btn').addEventListener('click', () => this.start());
            document.getElementById('stop-btn').addEventListener('click', () => this.stop());
            document.getElementById('theme-toggle-btn').addEventListener('click', () => this.toggleTheme());
            document.getElementById('symbol-input').addEventListener('change', async (e) => { // async eklendi
                let newSymbol = e.target.value.toUpperCase();
                if (!newSymbol.endsWith('USDT')) newSymbol += 'USDT';
                await this.changeSymbol(newSymbol); // await eklendi
                this.saveData('utc_current_symbol', newSymbol);
            });
            document.getElementById('timeframe-select').addEventListener('change', async (e) => { // async eklendi
                this.changeTimeframe(e.target.value);
                this.saveData('utc_current_timeframe', e.target.value);
            });
            document.getElementById('header-main-bar').addEventListener('dblclick', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('main-controls-btn').addEventListener('click', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
            document.getElementById('heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
            
            // NEW Fullscreen Chart buttons
            document.getElementById('fullscreen-chart-btn').addEventListener('click', () => this.enterFullscreenChart());
            document.getElementById('exit-fullscreen-btn').addEventListener('click', () => this.exitFullscreenChart());

            document.getElementById('open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
            document.getElementById('clear-markers-btn').addEventListener('click', () => this.clearChartMarkers()); 
            document.getElementById('chart-zoom-in').addEventListener('click', () => this.chartManager.zoomIn());
            document.getElementById('chart-zoom-out').addEventListener('click', () => this.chartManager.zoomOut());
            document.getElementById('chart-zoom-reset').addEventListener('click', () => this.chartManager.resetZoom());
            document.getElementById('close-settings-modal-btn').addEventListener('click', () => this.closeSettingsModal());
            document.getElementById('settings-modal-overlay').addEventListener('click', (e) => { if (e.target.id === 'settings-modal-overlay') this.closeSettingsModal(); });

            document.getElementById('modal-confluence-threshold').addEventListener('input', (e) => this.settings.confluenceThreshold = parseInt(e.target.value));
            document.getElementById('modal-param-rsi-period').addEventListener('change', (e) => this.settings.params.rsiPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-atr-period').addEventListener('change', (e) => this.settings.params.atrPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-wall-btc').addEventListener('change', (e) => this.settings.params.wallBtc = parseInt(e.target.value));
            document.getElementById('modal-param-rr-ratio').addEventListener('change', (e) => this.settings.params.rrRatio = parseFloat(e.target.value));
            document.getElementById('modal-signal-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.signalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-same-direction-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.sameDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-opposite-direction-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.oppositeDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-reverse-hysteresis-points').addEventListener('change', (e) => this.settings.cooldowns.reverseHysteresisPoints = parseInt(e.target.value) || 0);
            document.getElementById('modal-proposal-timeout-ms').addEventListener('change', (e) => this.settings.cooldowns.proposalTimeoutMs = parseInt(e.target.value) || 1000);
            document.getElementById('modal-strategy-proposal-cooldown-ms').addEventListener('change', (e) => this.settings.cooldowns.strategyProposalMs = parseInt(e.target.value) || 0);
            // Yeni özelliklerin Event Listener'ları
            document.getElementById('modal-enable-spoof-detection').addEventListener('change', (e) => this.settings.features.enableSpoofDetection = e.target.checked);
            document.getElementById('modal-enable-cusum-drift').addEventListener('change', (e) => this.settings.features.enableCUSUMDrift = e.target.checked);
            document.getElementById('modal-enable-risk-guardian').addEventListener('change', (e) => this.settings.features.enableRiskGuardian = e.target.checked);
            document.getElementById('modal-enable-auto-optimize').addEventListener('change', (e) => this.settings.optimization.enabled = e.target.checked);
            document.getElementById('modal-enable-auto-toggle-strat').addEventListener('change', (e) => this.settings.optimization.autoToggle = e.target.checked);
            document.getElementById('modal-enable-breakeven-trail').addEventListener('change', (e) => this.settings.optimization.breakeven.enabled = e.target.checked);
            document.getElementById('modal-be-at-r').addEventListener('change', (e) => this.settings.optimization.breakeven.beAtR = parseFloat(e.target.value));
            document.getElementById('modal-trail-after-r').addEventListener('change', (e) => this.settings.optimization.breakeven.trailAfterR = parseFloat(e.target.value));
            document.getElementById('modal-trail-to-r').addEventListener('change', (e) => this.settings.optimization.breakeven.trailToR = parseFloat(e.target.value));
            document.getElementById('modal-enable-tts').addEventListener('change', (e) => {
                this.settings.features.enableTTS = e.target.checked;
                // TTS açıldığında veya kapatıldığında ses seçimi dropdown'ının durumunu güncelle
                this.updateTTSVoiceSelectUI();
            });
            document.getElementById('modal-tts-voice-select').addEventListener('change', (e) => {
                this.settings.features.preferredVoiceName = e.target.value === "" ? null : e.target.value; // Boş değer null olarak kaydedilir
                this.saveSettings(); // Ses tercihini hemen kaydet
                // Test etmek için seçilen sesle bir deneme konuşması yapılabilir
                if (e.target.value !== "") { // Otomatik seçimi test etmeye çalışma
                    this.speak("Ses başarıyla değiştirildi.", { lang: 'tr-TR', rate: 1.0 });
                }
            });


            document.getElementById('modal-strategy-toggles').addEventListener('change', (e) => {
                if (e.target.classList.contains('strategy-toggle')) {
                    const key = e.target.dataset.strategyKey;
                    this.settings.activeStrategies[key] = e.target.checked;
                    this.updateActiveStrategies(); // Stratejilerin isLive bayrağını günceller
                    this.showNotification(`${this.strategies[key].displayName} ${e.target.checked ? 'aktif' : 'pasif'}.`, 'info');
                    this.saveSettings();
                }
            });

            document.getElementById('modal-clear-signals-btn').addEventListener('click', () => this.clearAllSignals());
            document.getElementById('reset-all-settings-btn').addEventListener('click', () => this.resetAllSettings());
            document.getElementById('save-settings-btn').addEventListener('click', () => { this.saveSettings(); this.showNotification('Ayarlar kaydedildi!', 'success'); this.closeSettingsModal(); });
       
            // NEW Resize Handle Logic
            const centerPanel = document.querySelector('.center-panel');
            const resizeHandle = centerPanel.querySelector('.resize-handle');
            let isResizing = false;
            let lastY = 0;
            let initialHeight = 0;
            const MIN_PANEL_HEIGHT = 200; // Minimum yükseklik sınırı
            const MAX_PANEL_HEIGHT = window.innerHeight * 0.9; // Maksimum yükseklik, ekran yüksekliğinin %90'ı

            if (resizeHandle) {
                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    lastY = e.clientY;
                    initialHeight = centerPanel.offsetHeight;
                    centerPanel.classList.add('resizing');
                    document.body.style.cursor = 'ns-resize';

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });

                const onMouseMove = (e) => {
                    if (!isResizing) return;
                    const dy = e.clientY - lastY;
                    let newHeight = initialHeight + dy;

                    // Apply min/max height constraints
                    newHeight = Math.max(MIN_PANEL_HEIGHT, Math.min(MAX_PANEL_HEIGHT, newHeight));
                    
                    centerPanel.style.height = `${newHeight}px`;
                    this.chartManager.chart.resize(centerPanel.clientWidth, centerPanel.clientHeight);
                    this.heatmapManager._resizeCanvas();
                };

                const onMouseUp = () => {
                    isResizing = false;
                    centerPanel.classList.remove('resizing');
                    document.body.style.cursor = '';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
            }
        }

        toggleControlsPanel() {
            document.body.classList.toggle('header-collapsed');
            this.headerCollapsed = document.body.classList.contains('header-collapsed'); 
            setTimeout(() => { window.dispatchEvent(new Event('resize')); }, 360);
        }
        switchMainView(viewName) {
            this.currentMainView = viewName;
            const chartView = document.getElementById('chart-container-view');
            const heatmapView = document.getElementById('heatmap-container-view');
            const chartCountdownOverlay = document.getElementById('chart-countdown-overlay');

            if (viewName === 'chart') {
                chartView.classList.remove('hidden-view');
                heatmapView.classList.add('hidden-view');
                chartCountdownOverlay.classList.remove('hidden-view'); // Show countdown for chart
                setTimeout(() => { this.chartManager.chart.resize(chartView.clientWidth, chartView.clientHeight); this.chartManager.chart.timeScale().fitContent(); }, 0); 
            } else {
                chartView.classList.add('hidden-view');
                heatmapView.classList.remove('hidden-view');
                chartCountdownOverlay.classList.add('hidden-view'); // Hide countdown for heatmap
                setTimeout(() => { this.heatmapManager._resizeCanvas(); }, 0); 
            }
        }
        
        // NEW Fullscreen Chart Functions
        enterFullscreenChart() {
            document.body.classList.add('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.remove('hidden-view');
            document.getElementById('chart-countdown-overlay').classList.remove('hidden-view'); // Ensure countdown visible
            // Resize chart to fill the window
            this.chartManager.chart.resize(window.innerWidth, window.innerHeight);
            this.chartManager.chart.timeScale().fitContent();
        }

        exitFullscreenChart() {
            document.body.classList.remove('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.add('hidden-view');
            // Re-hide countdown if not in chart view
            if (this.currentMainView !== 'chart') {
                document.getElementById('chart-countdown-overlay').classList.add('hidden-view');
            }
            // Trigger a window resize event to let layout recalculate
            window.dispatchEvent(new Event('resize'));
            // Explicitly resize chart based on its parent in normal layout
            const chartContainer = document.getElementById('chart-container-view');
            if (chartContainer && this.chartManager.chart) {
                setTimeout(() => {
                    this.chartManager.chart.resize(chartContainer.clientWidth, chartContainer.clientHeight);
                    this.chartManager.chart.timeScale().fitContent();
                }, 50); // Small delay to allow CSS transition to finish
            }
        }

        openSettingsModal() { this.updateSettingsModalUI(); document.getElementById('settings-modal-overlay').classList.add('visible'); }
        closeSettingsModal() { document.getElementById('settings-modal-overlay').classList.remove('visible'); this.updateActiveStrategies(); this.calculateAllIndicators(); window.dispatchEvent(new Event('resize')); }

        resetAllSettings() {
            if (confirm('Tüm ayarları ve sinyal geçmişini sıfırlamak istediğinizden emin misiniz? Bu işlem geri alınamaz.')) {
                localStorage.removeItem('utc_settings');
                localStorage.removeItem('utc_signals');
                localStorage.removeItem('utc_stats');
                localStorage.removeItem('utc_strategy_stats');
                localStorage.removeItem('utc_current_symbol'); 
                localStorage.removeItem('utc_current_timeframe'); 
                localStorage.removeItem('utc_header_collapsed'); 
                localStorage.removeItem('utc_current_view'); 
                
                this.settings = this.loadSettings(); 
                this.signals = []; 
                this.stats = { total: 0, tp: 0, sl: 0 }; 
                this.strategyStats = this.initDefaultStrategyStats();
                this.currentSymbol = 'BTCUSDT'; 
                this.currentTimeframe = '15m'; 
                this.headerCollapsed = true;
                this.currentMainView = 'chart'; 

                this.initStrategies(); 
                this.updateSettingsModalUI(); 
                this.renderSignals(true); 
                this.renderStats(true);   
                this.chartManager.clearMarkers(); 
                this.showNotification('Tüm ayarlar ve veriler sıfırlandı!', 'info');
                this.speak(this.getRandomMessage('resetAll'));
                this.stop(); 
                document.body.classList.add('header-collapsed'); 
                this.switchMainView('chart');
            }
        }

        async start() {
            if (this.isRunning) return;
            this.isRunning = true; 
            document.getElementById('start-btn').disabled = true; 
            document.getElementById('stop-btn').disabled = false;
            
            this.showNotification('Sistem Başlatıldı: Canlı veri akışı başlatılıyor...', 'success');
            this.speak(this.getRandomMessage('systemStart'));
            await this.fetchInitialData(); 
            this.connectWebSockets(); // We'll use the depth20 stream from here
            
            this.renderInterval = setInterval(() => this.render(), 250);
            this.analysisInterval = setInterval(() => this.runPeriodicAnalysis(), 5000);
            if (this.settings.optimization.enabled) {
                this.cooldownTuneInterval = setInterval(() => this.autoTuneCooldowns(), 30000); 
                this.thresholdTuneInterval = setInterval(() => this.autoTuneThresholds(), 30000); 
            }
        }

        stop() {
            if (!this.isRunning) return;
            this.isRunning = false; 
            document.getElementById('start-btn').disabled = true; 
            document.getElementById('stop-btn').disabled = true; 
            this.disconnectWebSockets();
            if (this.renderInterval) clearInterval(this.renderInterval); 
            if (this.analysisInterval) clearInterval(this.analysisInterval);
            if (this.cooldownTuneInterval) clearInterval(this.cooldownTuneInterval);
            if (this.thresholdTuneInterval) clearInterval(this.thresholdTuneInterval);
            if (this.countdownInterval) clearInterval(this.countdownInterval);
            
            this.multiTimeframeManager.cleanup();
            
            this.updateConnectionStatus(false, "BAĞLANTI KESİLDİ"); 
            if (this.combatModeActive) this.deactivateCombatMode();
            this.showNotification('Sistem Durduruldu.', 'danger');
            this.speak(this.getRandomMessage('systemStop'));
        }

        async changeSymbol(newSymbol) {
            if (this.currentSymbol === newSymbol) return;
            this.currentSymbol = newSymbol; 
            this.showNotification(`${this.currentSymbol.replace('USDT', '/USDT')} sembolüne geçildi.`, 'info');
            this.speak(this.getRandomMessage('symbolChange', { 'Sembol': this.currentSymbol.replace('USDT', '') }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); } // stop-start döngüsü yeni sembol için tüm bağlantıları yeniler
            this.updateSuperTopTicker(); 
        }
        async changeTimeframe(newTimeframe) {
            this.currentTimeframe = newTimeframe; 
            this.showNotification(`Zaman aralığı ${this.currentTimeframe} olarak değiştirildi.`, 'info');
            this.speak(this.getRandomMessage('timeframeChange', { 'Timeframe': this.currentTimeframe }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); } // stop-start döngüsü yeni zaman dilimi için tüm bağlantıları yeniler
        }
        resetDataForNewSymbol() {
            this.candles = []; this.aggTrades = []; this.marketData.price = 0; 
            // Revert orderBook initialization to simple arrays for snapshot stream
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null };
            this.chartManager.setData([]); this.chartManager.clearMarkers(); this.render();
            this.heatmapManager.draw({bids:[], asks:[]}, 0); // Clear heatmap
        }

        async fetchInitialData() {
            try {
                this.logToJournal(`${this.currentSymbol} için geçmiş mum verileri çekiliyor...`);
                // Binance Futures API adresi (fapi)
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${this.currentTimeframe}&limit=500`;
                const response = await fetch(url); if (!response.ok) throw new Error(`API Hatası: ${response.statusText}`);
                const data = await response.json();
                this.candles = data.map(d => ({ time: d[0], open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]), }));
                this.chartManager.setData(this.candles); this.logToJournal(`${this.candles.length} adet mum yüklendi.`);
                this.calculateAllIndicators();
            } catch (error) { this.showNotification(`Geçmiş veri alınamadı: ${error.message}`, 'danger'); console.error("Geçmiş veri hatası:", error); }
        }

        // Revert to using depth20 stream directly, no complex snapshot/diff handling
        connectWebSockets() {
            this.disconnectWebSockets(); 
            this.reconnectAttempts = 0;
            const symbolLower = this.currentSymbol.toLowerCase();
            // Use depth20 for order book (snapshot updates), which matches previous working code
            const streams = [`${symbolLower}@ticker`, `${symbolLower}@depth20@100ms`, `${symbolLower}@aggTrade`, `${symbolLower}@kline_${this.currentTimeframe}`];
            const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`); 
            this.sockets['main'] = ws;
            
            ws.onopen = () => { this.updateConnectionStatus(true); this.reconnectAttempts = 0; this.logToJournal("WebSocket bağlantısı başarıyla kuruldu."); };
            ws.onmessage = (event) => { const message = JSON.parse(event.data); this.handleMarketData(message.stream, message.data); };
            ws.onerror = (error) => console.error('WebSocket Hatası:', error);
            ws.onclose = () => { 
                if (this.isRunning) { 
                    this.reconnectAttempts++;
                    this.reconnectDelay = Math.min(30000, 3000 * Math.pow(2, this.reconnectAttempts - 1));
                    const message = `YENİDEN BAĞLANILIYOR... (${this.reconnectDelay / 1000}s)`;
                    this.updateConnectionStatus(false, message); 
                    this.logToJournal(`Bağlantı kapandı. ${this.reconnectDelay/1000} saniye sonra yeniden denenecek. (Deneme: ${this.reconnectAttempts})`);
                    setTimeout(() => this.connectWebSockets(), this.reconnectDelay); 
                } 
            };
        }
        disconnectWebSockets() { 
            if (this.sockets['main']) { 
                this.sockets['main'].onclose = null; // Prevent reconnect on explicit close
                this.sockets['main'].close(1000, "İstemci tarafından kapatıldı"); 
                delete this.sockets['main'];
            }
        }

        // Simpler handleMarketData for depth20 stream
        handleMarketData(stream, data) {
            const streamType = stream.split('@')[1];
            if (streamType === 'ticker') {
                this.marketData.price = parseFloat(data.c);
                this.marketData.change24h = parseFloat(data.P);
                this.marketData.volume24h = parseFloat(data.q);
                this.marketData.symbol = data.s;
                if (data.s === 'BTCUSDT') this.marketData.btcPrice = parseFloat(data.c);
                // Pozisyon yönetimi + TP/SL kontrol
                this.manageOpenPositions();
                this.checkAutoCloseSignals();
            } 
            else if (streamType.startsWith('depth')) {
                // For depth20 stream, data.b and data.a are directly the bids/asks arrays
                this.orderBook = { 
                    bids: data.b.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    asks: data.a.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    lastUpdateId: data.u 
                };
                this.heatmapManager.draw(this.orderBook, this.marketData.price);
                if(this.settings.features.enableSpoofDetection) this.spoofDetector.trackOrderBook(this.orderBook);
                for (const key in this.strategies) { // Changed to this.strategies to allow passive strategies to analyze
                    if (typeof this.strategies[key].analyzeOrderBook === 'function') {
                        this.strategies[key].analyzeOrderBook(this.orderBook);
                    }
                }
            } else if (streamType.startsWith('kline')) {
                if (this.candles.length > 0) {
                    const kline = data.k; this.chartManager.updateRealtime(kline);
                    if (kline.x) { 
                        const newCandle = { time: kline.t, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c), volume: parseFloat(kline.v) };
                        const lastCandle = this.candles[this.candles.length - 1];
                        if (lastCandle && lastCandle.time === kline.t) this.candles[this.candles.length - 1] = newCandle; else this.candles.push(newCandle);
                        if (this.candles.length > 500) this.candles.shift(); 
                        this.calculateAllIndicators(); 
                    }
                    this.manageOpenPositions();
                    this.checkAutoCloseSignals();
                }
            } else if (streamType === 'aggTrade') {
                const trade = { price: parseFloat(data.p), quantity: parseFloat(data.q), isBuyerMaker: data.m, timestamp: data.T };
                for (const key in this.strategies) { // Changed to this.strategies to allow passive strategies to analyze
                    if (typeof this.strategies[key].processTrade === 'function') {
                        this.strategies[key].processTrade(trade);
                    }
                }
            }
        }
        
        runPeriodicAnalysis() { 
            if (!this.isRunning) return; 
            for (const key in this.strategies) { // Changed to this.strategies to allow passive strategies to analyze
                if (typeof this.strategies[key].periodicAnalyze === 'function') {
                    this.strategies[key].periodicAnalyze(); 
                }
            }
            if (this.settings.features.enableRiskGuardian) this.riskGuardian.checkKillSwitch();
        }
        
        calculateAllIndicators() {
            if (this.candles.length === 0) return;
            const rsiPeriod = this.settings.params.rsiPeriod;
            const atrPeriod = this.settings.params.atrPeriod;

            const closes = this.candles.map(c => c.close);
            const highs = this.candles.map(c => c.high);
            const lows = this.candles.map(c => c.low);
            const volumes = this.candles.map(c => c.volume);

            // RSI
            if (closes.length >= rsiPeriod + 1) {
                let gains = 0; let losses = 0;
                for (let i = 1; i <= rsiPeriod; i++) { const diff = closes[i] - closes[i - 1]; if (diff > 0) gains += diff; else losses -= diff; }
                let avgGain = gains / rsiPeriod; let avgLoss = losses / rsiPeriod;
                const rsiValues = [];
                rsiValues.push(100 - (100 / (1 + (avgLoss === 0 ? 100 : avgGain / avgLoss)))); 
                for (let i = rsiPeriod + 1; i < closes.length; i++) {
                    const diff = closes[i] - closes[i - 1];
                    avgGain = (avgGain * (rsiPeriod - 1) + (diff > 0 ? diff : 0)) / rsiPeriod;
                    avgLoss = (avgLoss * (rsiPeriod - 1) + (diff < 0 ? -diff : 0)) / rsiPeriod;
                    rsiValues.push(100 - (100 / (1 + (avgLoss === 0 ? 100 : avgGain / avgLoss))));
                }
                this.indicators.rsi = rsiValues;
            } else { this.indicators.rsi = []; } 

            // ATR
            if (this.candles.length >= atrPeriod) {
                let trs = [];
                for (let i = 1; i < this.candles.length; i++) {
                    const c = this.candles[i], p = this.candles[i - 1];
                    trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
                }
                if (trs.length >= atrPeriod) {
                    let atrSum = trs.slice(-atrPeriod).reduce((a, b) => a + b, 0);
                    this.indicators.atr = atrSum / atrPeriod;
                } else { this.indicators.atr = null; }
            } else { this.indicators.atr = null; }

            // SMA (Simple Moving Average)
            const sma = (arr, n) => arr.slice(-n).reduce((a,b)=>a+b,0)/Math.max(1, Math.min(arr.length, n));
            this.indicators.sma20 = closes.length >= 20 ? sma(closes, 20) : null;
            this.indicators.sma50 = closes.length >= 50 ? sma(closes, 50) : null;
            this.indicators.volSma20 = volumes.length >= 20 ? sma(volumes, 20) : null;

            // VWAP
            let cumPV = 0, cumV = 0;
            for (const k of this.candles) { const tp = (k.high + k.low + k.close)/3; cumPV += tp * k.volume; cumV += k.volume; }
            this.indicators.vwap = cumV ? (cumPV / cumV) : null;

            // ADX (Average Directional Index) - Gelişmiş Hesaplama
            this.indicators.adx = this.calcADX(this.candles, atrPeriod);
            this.marketRegime = (this.indicators.adx && this.indicators.adx > 25) ? 'trend' : (this.indicators.adx && this.indicators.adx < 20 ? 'range' : 'transition');
        }

      calcADX(candles, period = 14) {
    if (!candles || candles.length < period * 2) return null; 
    const tr = [], plusDM = [], minusDM = [];
    for (let i = 1; i < candles.length; i++) {
        const c = candles[i], p = candles[i-1];
        const upMove = c.high - p.high;
        const downMove = p.low - c.low;
        const trueRange = Math.max(
            c.high - c.low,
            Math.abs(c.high - p.close),
            Math.abs(c.low - p.close)
        );
        tr.push(trueRange);
        plusDM.push((upMove > downMove && upMove > 0) ? upMove : 0);
        minusDM.push((downMove > upMove && downMove > 0) ? downMove : 0);
    }
    const wilderSmooth = (arr, n) => {
        let sum = arr.slice(0, n).reduce((a,b)=>a+b,0);
        const smoothed = [sum];
        for (let i = n; i < arr.length; i++) {
            sum = sum - (sum/n) + arr[i];
            smoothed.push(sum);
        }
        return smoothed;
    };


            const smoothedTR = wilderSmooth(tr, period);
            const smoothedPlusDM = wilderSmooth(plusDM, period);
            const smoothedMinusDM = wilderSmooth(minusDM, period);

            const plusDI = smoothedPlusDM.map((val, idx) => 100 * (val / Math.max(1e-8, smoothedTR[idx])));
            const minusDI = smoothedMinusDM.map((val, idx) => 100 * (val / Math.max(1e-8, smoothedTR[idx])));

            const dxValues = plusDI.map((pdi, idx) => {
                const mdi = minusDI[idx];
                return 100 * Math.abs(pdi - mdi) / Math.max(1e-8, (pdi + mdi));
            });
            
            if (dxValues.length >= period) {
                return wilderSmooth(dxValues, period).pop();
            }
            return null;
        }

        getOrderBookSnapshotInfo() {
            // For depth20 stream, this.orderBook already holds the array structure
            const ob = this.orderBook;
            if (!ob || !ob.bids || ob.bids.length === 0 || !ob.asks || ob.asks.length === 0) return null;
            const bestBid = ob.bids[0][0], bestAsk = ob.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            const topN = this.settings.optimization.gating.topN || 5;
            const price = this.marketData.price || mid || 1;
            const sumUsd = (levels) => levels.slice(0, topN).reduce((s,[p,q])=> s + (p*q), 0);
            const topBidUsd = sumUsd(ob.bids);
            const topAskUsd = sumUsd(ob.asks);
            const minTopUsd = Math.min(topBidUsd, topAskUsd);
            return { bestBid, bestAsk, spreadPct, topBidUsd, topAskUsd, minTopUsd, mid, price };
        }
        marketGatingPenalty(direction) {
            const info = this.getOrderBookSnapshotInfo();
            if (!info || !this.settings.optimization.gating.enabled) return 0;
            const g = this.settings.optimization.gating;
            let penalty = 0;
            if (info.spreadPct > g.spreadMaxPct) penalty += 1.5; 
            if (info.minTopUsd < g.minDepthUsd) penalty += 1.5; 
            return penalty;
        }

        getEffectiveThreshold() { return (this.settings.confluenceThreshold || 3) + (this.runtimeThresholdOffset || 0); }

        calculateDynamicTpSl(signal) {
            const atr = this.indicators.atr;
            let rrRatioBase = this.settings.params.rrRatio;
            if (this.riskState === 'conservative') rrRatioBase = Math.max(1.2, rrRatioBase * 0.9);
            if (this.riskState === 'aggressive') rrRatioBase = Math.min(2.5, rrRatioBase * 1.1);

            if (!atr || atr === 0) { 
                signal.tp = signal.direction === 'buy' ? signal.price * (1 + 0.01*rrRatioBase/1.5) : signal.price * (1 - 0.01*rrRatioBase/1.5);
                signal.sl = signal.direction === 'buy' ? signal.price * 0.995 : signal.price * 1.005;
            } else {
                const atrMultiplier = 1.5 - (Math.min(10, Math.max(0, signal.score)) / 10 * 0.5); 
                const slDistance = atr * atrMultiplier;
                const tpDistance = slDistance * rrRatioBase;
                if (signal.direction === 'buy') { signal.sl = signal.price - slDistance; signal.tp = signal.price + tpDistance; }
                else { signal.sl = signal.price + slDistance; signal.tp = signal.price - tpDistance; }
                signal.entrySlDistance = slDistance;
                signal.entryTpDistance = tpDistance;
            }
        }

        manageOpenPositions() {
            if (!this.isRunning || !this.marketData.price || !this.settings.optimization.breakeven.enabled) return;
            const price = this.marketData.price;
            const atr = this.indicators.atr;
            if (!atr) return; 

            let changed = false;

            const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
            for (const s of activeSignals) {
                if (!s.entrySlDistance || s.entrySlDistance <= 0) continue; 

                const rNow = s.direction === 'buy' ? (price - s.price) / s.entrySlDistance : (s.price - price) / s.entrySlDistance;
                s.mfeR = Math.max(s.mfeR || 0, rNow); 

                const settings = this.settings.optimization.breakeven;

                // Maliyete Çek (Breakeven)
                if (!s.beDone && s.mfeR >= (settings.beAtR || 0.8)) {
                    s.sl = s.price; 
                    s.beDone = true;
                    s.note = (s.note ? s.note + ' | ' : '') + 'SL->BE';
                    changed = true;
                    this.showNotification(`Sinyal ${s.id.substring(0,6)} için SL maliyete çekildi.`, 'info');
                }
                
                // Takip Eden Zarar Durdurma (Trailing Stop)
                if (s.mfeR >= (settings.trailAfterR || 1.5) && (s.trailingStage || 0) < 1) {
                    let newSl;
                    if (s.direction === 'buy') {
                        newSl = price - (atr * settings.trailToR); 
                        s.sl = Math.min(s.tp, Math.max(s.sl, newSl)); 
                    } else { 
                        newSl = price + (atr * settings.trailToR); 
                        s.sl = Math.max(s.tp, Math.min(s.sl, newSl)); 
                    }
                    s.trailingStage = 1;
                    s.note = (s.note ? s.note + ' | ' : '') + 'Trail1';
                    changed = true;
                    this.showNotification(`Sinyal ${s.id.substring(0,6)} için SL güncellendi (Trailing).`, 'info');
                }
            }
            if (changed) this.saveData('utc_signals', this.signals);
        }

        checkAutoCloseSignals() {
            if (!this.isRunning || !this.marketData.price) return;
            const price = this.marketData.price;
            const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
            for (const s of activeSignals) {
                if (s.direction === 'buy') {
                    if (price >= s.tp) { this.updateSignalResult(s.id, 'tp'); }
                    else if (price <= s.sl) { this.updateSignalResult(s.id, 'sl'); }
                } else if (s.direction === 'sell') {
                    if (price <= s.tp) { this.updateSignalResult(s.id, 'tp'); }
                    else if (price >= s.sl) { this.updateSignalResult(s.id, 'sl'); }
                }
            }
        }

        render() { 
            this.renderPriceDisplay(); 
            this.updateSignalProgressBar(); 
        }
        renderPriceDisplay() {
            const priceEl = document.getElementById('current-price');
            const tickerPriceEl = document.getElementById('ticker-bar-price');
            const oldPriceText = tickerPriceEl ? tickerPriceEl.textContent : '0';
            const oldPrice = this.marketData.price ? parseFloat(oldPriceText.replace(/,/g, '')) : 0;
            
            if (this.marketData.price) {
                const formattedPrice = this.formatPrice(this.marketData.price);
                if (priceEl) priceEl.textContent = formattedPrice;
                if(tickerPriceEl) tickerPriceEl.textContent = formattedPrice;

                if (!isNaN(oldPrice) && oldPrice !== 0) { 
                    const color = this.marketData.price > oldPrice ? 'var(--positive)' : (this.marketData.price < oldPrice ? 'var(--negative)' : '');
                    if(priceEl) { priceEl.style.color = color; priceEl.style.transition = 'none'; setTimeout(() => priceEl.style.color = '', 500); }
                    if(tickerPriceEl) { tickerPriceEl.style.color = color; tickerPriceEl.style.transition = 'none'; setTimeout(() => tickerPriceEl.style.color = '', 500); }
                }
            }
            const change = this.marketData.change24h || 0;
            const changeEl = document.getElementById('price-change-24h');
            if (changeEl) { changeEl.textContent = `${change.toFixed(2)}%`; changeEl.style.color = change >= 0 ? 'var(--positive)' : 'var(--negative)'; }
            const volumeEl = document.getElementById('volume-24h'); if(volumeEl) volumeEl.textContent = this.formatVolume(this.marketData.volume24h);
            const atrEl = document.getElementById('atr-value'); if(atrEl) atrEl.textContent = this.indicators.atr ? this.indicators.atr.toFixed(this.getDecimalPlaces(this.indicators.atr)) : '-';
        }

        updateCandleCountdown() {
            const headerCountdownEl = document.getElementById('candle-countdown');
            const chartCountdownEl = document.getElementById('chart-countdown-overlay');

            if (!this.isRunning || this.candles.length === 0) {
                headerCountdownEl.textContent = '--:--';
                chartCountdownEl.textContent = '--:--';
                return;
            }

            const now = Date.now();
            // Binance kline time, mumun açılış zamanıdır.
            const lastCandleOpenTime = this.candles[this.candles.length - 1].time; 

            let timeframeMs;
            switch (this.currentTimeframe) {
                case '1m': timeframeMs = 60 * 1000; break;
                case '5m': timeframeMs = 5 * 60 * 1000; break;
                case '15m': timeframeMs = 15 * 60 * 1000; break;
                case '1h': timeframeMs = 60 * 60 * 1000; break;
                case '4h': timeframeMs = 4 * 60 * 60 * 1000; break;
                default: headerCountdownEl.textContent = '--:--'; chartCountdownEl.textContent = '--:--'; return;
            }

            const nextCandleOpenTime = lastCandleOpenTime + timeframeMs;
            let remainingTime = nextCandleOpenTime - now;

            if (remainingTime < 0) {
                remainingTime = timeframeMs + (remainingTime % timeframeMs);
                if (remainingTime <= 0) remainingTime += timeframeMs; // Ensure positive if it became 0 or negative
            }
            
            remainingTime = Math.max(0, remainingTime); 

            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);

            const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            headerCountdownEl.textContent = formattedTime;
            
            // Show/hide chart countdown based on view
            if (this.currentMainView === 'chart' || document.body.classList.contains('fullscreen-chart')) {
                chartCountdownEl.textContent = formattedTime;
                chartCountdownEl.classList.remove('hidden-view');
            } else {
                chartCountdownEl.classList.add('hidden-view');
            }
        }

        updateSignalProgressBar() {
            const buyFill = document.getElementById('buy-signal-bar-fill');
            const sellFill = document.getElementById('sell-signal-bar-fill');
            const buyScoreText = document.getElementById('buy-signal-score-text');
            const sellScoreText = document.getElementById('sell-signal-score-text');

            if (!buyFill || !sellFill || !buyScoreText || !sellScoreText) return;

            const maxScoreForDisplay = 10; 

            const buyScore = this.confluenceEngine.buyScore || 0;
            const sellScore = this.confluenceEngine.sellScore || 0;

            const buyPercent = Math.min(100, Math.max(0, (buyScore / maxScoreForDisplay) * 100));
            const sellPercent = Math.min(100, Math.max(0, (sellScore / maxScoreForDisplay) * 100));

            buyFill.style.width = `${buyPercent}%`;
            sellFill.style.width = `${sellPercent}%`;

            buyScoreText.textContent = `${buyScore.toFixed(1)}`;
            sellScoreText.textContent = `${sellScore.toFixed(1)}`;
        }

        addFinalSignal(signal) {
            this.signals.unshift(signal); if (this.signals.length > 200) this.signals.pop();
            this.saveData('utc_signals', this.signals);
            this.renderSignals(true); 
            this.renderStats(true); 
            this.chartManager.addSignalMarker(signal);
            this.showNotification(`YENİ SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${typeof signal.score==='number'?signal.score.toFixed(1):signal.score}`, signal.direction === 'buy' ? 'success' : 'danger');
            playSignal(signal.direction); 
            
            if (this.settings.features.enableTTS) {
                const messageKey = signal.direction === 'buy' ? 'buy' : 'sell';
                const message = this.getRandomMessage(messageKey, { 
                    Sembol: signal.symbol.replace('USDT', ''), 
                    Skor: signal.score.toFixed(1) 
                });
                this.speak(message);
            }

            if (signal.score >= 8 && !this.combatModeActive) { this.activateCombatMode(); } 
        }

        updateSignalResult(signalId, result) {
            const signal = this.signals.find(s => s.id === signalId);
            if(signal && signal.status === 'active') {
                signal.status = result;
                this.stats.total++;
                this.stats[result]++;
                this.updateStrategyStats(signal);
                if (this.settings.features.enableCUSUMDrift) {
                    const driftDetected = this.cusumDetector.update(result === 'tp');
                    if (driftDetected) {
                        this.showNotification('PERFORMANS SAPMASI!', 'Sinyal kazanma oranında sapma tespit edildi. Ayarlar optimize ediliyor...', 'warning');
                        if (this.settings.features.enableTTS) {
                            this.speak(this.getRandomMessage('cusumDriftDetected'));
                        }
                    }
                }

                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.renderSignals(true); 
                this.renderStats(true);   
                this.showNotification(`Sinyal ${signal.id.substring(0,6)} - ${result.toUpperCase()} olarak sonuçlandı.`, 'info');
                if (this.settings.features.enableTTS) {
                    const messageKey = result === 'tp' ? 'signalTP' : 'signalSL';
                    this.speak(this.getRandomMessage(messageKey));
                }
            }
        }

        updateStrategyStats(signal) {
            const isWin = signal.status === 'tp';
            const contributors = signal.contributors || [];
            const totalEff = contributors.reduce((s, c) => s + (c.effScore || (c.baseScore * (c.weight||1))), 0) || 1;
            const decay = 0.995; 

            for (const c of contributors) {
                const stat = this.strategyStats[c.strategy] || { alpha:3, beta:2, proposals:0, contrib:0, wins:0, losses:0, lastUpdate: Date.now() };
                stat.alpha *= decay; stat.beta *= decay; 
                const credit = (c.effScore || (c.baseScore * (c.weight || 1))) / totalEff; 
                stat.contrib += 1;
                if (isWin) { stat.wins += credit; stat.alpha += credit; }
                else { stat.losses += credit; stat.beta += credit; }
                stat.lastUpdate = Date.now();
                this.strategyStats[c.strategy] = stat;
            }

            for (const key of Object.keys(this.strategies)) { 
                const w = this.getStrategyWeight(key);
                const base = this.settings.cooldowns.strategyProposalMs || 10000;
                const factor = Math.max(0.5, Math.min(2.0, 1.2 / Math.max(0.01,w))); 
                const newCd = Math.max(500, Math.round(base * factor));
                this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = newCd;
            }
            this.saveStrategyStats();
        }

        autoToggleStrategies() {
            if (!this.settings.optimization.enabled || !this.settings.optimization.autoToggle) return;
            const now = Date.now();
            if (now - this.lastAutoToggleTs < 5*60*1000) return; 
            this.lastAutoToggleTs = now;
            const minW = this.settings.optimization.minWeightToStay || 0.6;
            const minContrib = this.settings.optimization.minContribForToggle || 30;

            let changed = false;
            for (const key of this.allStrategyKeys) {
                const w = this.getStrategyWeight(key);
                const stat = this.strategyStats[key] || {};
                const active = !!this.settings.activeStrategies[key]; 

                // Deaktif etme koşulu: Aktifse, ağırlığı düşükse ve yeterince katkı sağladıysa
                if (active && w < minW && (stat.contrib || 0) >= minContrib) {
                    this.settings.activeStrategies[key] = false;
                    this.showNotification(`Oto-optimizasyon: ${this.strategies[key].displayName} pasif edildi (w=${w.toFixed(2)}).`, 'warning');
                    if (this.settings.features.enableTTS) {
                        this.speak(this.getRandomMessage('autoToggleDeactivate', { 'Strateji Adı': this.strategies[key].displayName }));
                    }
                    changed = true;
                // Aktif etme koşulu: Pasifse, ağırlığı yeterliyse ve yeterince öneri topladıysa (proposals)
                // proposals'ı kullanıyoruz çünkü pasifken sadece öneri sayar, win/loss değil.
                } else if (!active && w >= 1.0 && (stat.proposals || 0) >= minContrib/2) { 
                    this.settings.activeStrategies[key] = true;
                    this.showNotification(`Oto-optimizasyon: ${this.strategies[key].displayName} yeniden aktif (w=${w.toFixed(2)}).`, 'success');
                     if (this.settings.features.enableTTS) {
                        this.speak(this.getRandomMessage('autoToggleActivate', { 'Strateji Adı': this.strategies[key].displayName }));
                    }
                    changed = true;
                }
            }
            if(changed) {
                this.updateActiveStrategies(); // Strateji örneklerinin isLive bayrağını günceller
                this.saveSettings();
                this.updateSettingsModalUI(); 
            }
        }

        autoTuneCooldowns() {
            if (!this.isRunning || !this.settings.optimization.enabled) return;
            const now = Date.now();
            const WINDOW_MS = 5 * 60 * 1000; 
            // Sadece aktif stratejilerden gelen son sinyalleri dikkate al.
            const recentSignals = this.signals.filter(s => s.status !== 'active' && s.symbol === this.currentSymbol && now - s.timestamp <= WINDOW_MS).slice(0, 50).sort((a,b)=> a.timestamp - b.timestamp);

            let quickFlips = 0, totalPairs = 0;
            if (recentSignals.length >= 2) {
                for (let i = 1; i < recentSignals.length; i++) {
                    totalPairs++;
                    const dt = recentSignals[i].timestamp - recentSignals[i-1].timestamp;
                    if (recentSignals[i-1].direction !== recentSignals[i].direction && dt <= 15000) { 
                        quickFlips++;
                    }
                }
            }
            const flipRatio = totalPairs ? (quickFlips / totalPairs) : 0;
            const volPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0.001;

            const cd = this.settings.cooldowns;
            const baseSame = this.loadSettings().cooldowns.sameDirectionMs;
            const baseOpp = this.loadSettings().cooldowns.oppositeDirectionMs;
            const baseSignal = this.loadSettings().cooldowns.signalMs;
            const baseProposalTimeout = this.loadSettings().cooldowns.proposalTimeoutMs;

            const newSame = Math.max(10000, Math.min(120000, Math.round(baseSame * (1 + flipRatio * 0.8))));
            const newOpp  = Math.max(5000, Math.min(120000, Math.round(baseOpp  * (1 + flipRatio * 1.2))));
            
            const volFactor = volPct < 0.005 ? 1.2 : (volPct > 0.02 ? 0.8 : 1.0);
            const newSignal = Math.max(3000, Math.min(60000, Math.round(baseSignal * volFactor)));
            const newProposalTimeout = Math.max(1500, Math.min(8000, Math.round(baseProposalTimeout * volFactor)));

            let changed = false;
            if (Math.abs(newSame - cd.sameDirectionMs) / cd.sameDirectionMs > 0.05) { cd.sameDirectionMs = newSame; changed = true; }
            if (Math.abs(newOpp - cd.oppositeDirectionMs) / cd.oppositeDirectionMs > 0.05) { cd.oppositeDirectionMs = newOpp; changed = true; }
            if (Math.abs(newSignal - cd.signalMs) / cd.signalMs > 0.05) { cd.signalMs = newSignal; changed = true; }
            if (Math.abs(newProposalTimeout - cd.proposalTimeoutMs) / cd.proposalTimeoutMs > 0.05) { cd.proposalTimeoutMs = newProposalTimeout; changed = true; }

            if (changed) {
                this.saveSettings();
                this.updateSettingsModalUI(); 
                this.showNotification(`Cooldown optimize edildi (flip: ${(flipRatio*100).toFixed(0)}%, vol: ${(volPct*100).toFixed(2)}%).`, 'warning');
                if (this.settings.features.enableTTS) {
                    this.speak(this.getRandomMessage('cooldownOptimize'));
                }
            }

            this.autoToggleStrategies();
        }

        autoTuneThresholds() {
            if (!this.isRunning || !this.settings.optimization.enabled) return;
            const now = Date.now();
            const WINDOW_SIGNALS_COUNT = 40;
            const RECENT_SIGNALS_COUNT = 20;

            // Sadece kapanmış sinyalleri dikkate al
            const windowSignals = this.signals.filter(s => s.status !== 'active' && s.symbol === this.currentSymbol).slice(0, WINDOW_SIGNALS_COUNT);
            const recent = windowSignals.slice(0, RECENT_SIGNALS_COUNT);
            const tp = recent.filter(s => s.status === 'tp').length;
            const sl = recent.filter(s => s.status === 'sl').length;
            const totalRecent = tp + sl;
            const winRate = totalRecent > 0 ? tp / totalRecent : 0.5;

            let targetOffset = 0;
            if (winRate < 0.4) targetOffset = 1;
            if (winRate < 0.3) targetOffset = 2;
            if (winRate > 0.6) targetOffset = 0;

            if (this.marketRegime === 'trend' && winRate > 0.55) { 
                targetOffset = Math.max(0, targetOffset - 0.5);
            } else if (this.marketRegime === 'range' && winRate > 0.55) { 
                targetOffset = Math.max(0, targetOffset - 0.5);
            } else if (this.marketRegime === 'transition') { 
                targetOffset = Math.max(0.5, targetOffset + 0.5);
            }

            if (winRate <= 0.35) this.riskState = 'conservative';
            else if (winRate >= 0.65) this.riskState = 'aggressive';
            else this.riskState = 'neutral';

            this.runtimeThresholdOffset = (0.7 * (this.runtimeThresholdOffset || 0)) + (0.3 * targetOffset);
            this.runtimeThresholdOffset = parseFloat(this.runtimeThresholdOffset.toFixed(1)); 
        }

        updateSession() {
            if (!this.sessionProfiler) return;
            this.sessionState = this.sessionProfiler.getCurrentSession();
        }

        // Contributors formatlayıcı
        formatContributors(signal, detailed = false) {
            const cons = signal?.contributors || [];
            if (!cons.length) return '-';
            const parts = cons.map(c => {
                const name = this.strategies[c.strategy]?.displayName || c.strategy;
                const raw = c.effScore || ((c.baseScore || 0) * (c.weight || 1));
                return { name, raw, weight: c.weight || 1, baseScore: c.baseScore || 0 };
            });
            const total = parts.reduce((s, x) => s + x.raw, 0) || 1;
            parts.forEach(p => p.pct = Math.round((p.raw / total) * 100));
            parts.sort((a,b)=> b.pct - a.pct);

            if (!detailed) {
                const top = parts.slice(0, 3).map(p => `${p.name} ${p.pct}%`);
                const more = parts.length > 3 ? ` +${parts.length - 3}` : '';
                return top.join(' | ') + more;
            } else {
                return parts.map(p => `${p.name}: ${p.pct}% (w=${p.weight.toFixed(2)}, s=${p.baseScore})`).join(' | ');
            }
        }

        renderSignals(isModal = false) {
            const tbody = isModal ? document.getElementById('modal-signals-body') : document.getElementById('signals-body');
            if(!tbody) return; 
            tbody.innerHTML = this.signals.map(s => {
                // Güvenlik kontrolü: Kritik özelliklerin varlığını ve geçerliliğini kontrol et
                if (s.price === undefined || s.tp === undefined || s.sl === undefined || s.score === undefined || s.direction === undefined || s.timestamp === undefined || isNaN(s.price) || isNaN(s.tp) || isNaN(s.sl) || isNaN(s.score)) {
                    console.warn("Hatalı sinyal verisi tespit edildi, render atlanıyor:", s);
                    return ''; // Bu bozuk satırı render etme
                }

                const baseCols = `
                    <td>${new Date(s.timestamp).toLocaleTimeString()}</td>
                    <td>${s.direction.toUpperCase()}</td>
                    <td>${this.formatPrice(s.price)}</td>
                    <td>${this.formatPrice(s.tp)}</td>
                    <td>${this.formatPrice(s.sl)}</td>
                    <td>${typeof s.score==='number' ? s.score.toFixed(1) : s.score}</td>
                `;
                const contribCol = `<td title="${this.formatContributors(s, true)}">${this.formatContributors(s, false)}</td>`; 
                const statusCol = `<td>${(s.status || 'ACTIVE').toUpperCase()}</td>`;
                return `
                    <tr class="signal-${s.status === 'active' ? s.direction : s.status}">
                        ${baseCols}
                        ${contribCol}
                        ${statusCol}
                    </tr>
                `;
            }).join('');
        }
        renderStats(isModal = false) {
            const container = isModal ? document.getElementById('modal-stats-container') : document.getElementById('stats-container');
            if(!container) return; 
            const totalSignals = this.stats.total;
            const tpSignals = this.stats.tp;
            const slSignals = this.stats.sl; 
            const winRate = totalSignals > 0 ? (tpSignals / totalSignals * 100).toFixed(1) : "N/A";
            
            const totalScore = this.signals.reduce((sum, s) => sum + (s.score || 0), 0);
            const avgScore = totalSignals > 0 ? (totalScore / totalSignals).toFixed(1) : "N/A";

            container.innerHTML = `
                <div class="stat-item"><span class="stat-label">Toplam Sinyal:</span><span class="stat-value">${totalSignals}</span></div>
                <div class="stat-item"><span class="stat-label">Başarılı (TP):</span><span class="stat-value" style="color:var(--positive)">${tpSignals}</span></div>
                <div class="stat-item"><span class="stat-label">Başarısız (SL):</span><span class="stat-value" style="color:var(--negative)">${slSignals}</span></div>
                <div class="stat-item"><span class="stat-label">Başarı Oranı:</span><span class="stat-value" style="color:var(--primary)">${winRate}%</span></div>
                <div class="stat-item"><span class="stat-label">Ortalama Skor:</span><span class="stat-value">${avgScore}</span></div>
                <div class="stat-item"><span class="stat-label">Piyasa Rejimi:</span><span class="stat-value">${this.marketRegime.toUpperCase()}</span></div>
                <div class="stat-item"><span class="stat-label">Efektif Eşik:</span><span class="stat-value">${this.getEffectiveThreshold().toFixed(1)}</span></div>
                <div class="stat-item"><span class="stat-label">Risk Durumu:</span><span class="stat-value">${this.riskState.toUpperCase()}</span></div>
                <div class="stat-item"><span class="stat-label">Piyasa Seansı:</span><span class="stat-value">${this.sessionState.toUpperCase()}</span></div>
            `;
        }

        activateCombatMode() {
            if (this.combatModeActive) return; this.combatModeActive = true; document.documentElement.setAttribute('data-theme', 'war');
            this.chartManager.updateTheme(); this.heatmapManager.updateTheme(); 
            playSignal('combat'); 
            this.showNotification('!!! SAVAŞ MODU AKTİF !!!', 'warning');
            if (this.settings.features.enableTTS) {
                this.speak(this.getRandomMessage('combatModeActivate'));
            }
        }
        deactivateCombatMode() {
            this.combatModeActive = false; const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme(); this.heatmapManager.updateTheme();
            if (this.settings.features.enableTTS) {
                this.speak(this.getRandomMessage('combatModeDeactivate'));
            }
        }

        formatPrice(price) { if(!price && price !== 0) return '-'; return price.toLocaleString('en-US', { minimumFractionDigits: this.getDecimalPlaces(price), maximumFractionDigits: this.getDecimalPlaces(price) }); }
        getDecimalPlaces(price) { if(price === undefined || price === null || isNaN(price)) return 2; if (price >= 1000) return 2; if (price >= 1) return 3; if (price >= 0.01) return 4; return 6; }
        formatVolume(volume) { if (!volume) return '-'; if (volume >= 1e9) return `${(volume / 1e9).toFixed(2)}B`; if (volume >= 1e6) return `${(volume / 1e6).toFixed(2)}M`; return `${(volume / 1e3).toFixed(1)}K`; }
        toggleTheme() { if (this.combatModeActive) { this.deactivateCombatMode(); return; } const ct = document.documentElement.getAttribute('data-theme'); const nt = (ct === 'dark') ? 'light' : 'dark'; document.documentElement.setAttribute('data-theme', nt); localStorage.setItem('utc_theme', nt); this.chartManager.updateTheme(); this.heatmapManager.updateTheme(); }
        
        updateConnectionStatus(isConnected, message = 'BAĞLANTI YOK') { 
            const sd = document.getElementById('connection-status');
            const st = document.getElementById('connection-text');
            const tickerSymbolEl = document.getElementById('ticker-bar-symbol');
            if(isConnected) { sd.classList.add('online'); st.textContent = `BAĞLI (${this.currentSymbol.replace('USDT', '/USDT')})`; if(tickerSymbolEl) tickerSymbolEl.textContent = this.currentSymbol.replace('USDT', '/USDT'); }
            else { sd.classList.remove('online'); st.textContent = message; } 
        }
        clearChartMarkers() { this.chartManager.clearMarkers(); this.showNotification('Grafik sinyalleri temizlendi.', 'info'); }
        clearAllSignals() {
            if(confirm('Tüm sinyal geçmişini silmek istediğinizden emin misiniz?')) {
                this.signals = [];
                this.stats = { total: 0, tp: 0, sl: 0 };
                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.renderSignals(true);
                this.renderStats(true);
                this.chartManager.clearMarkers();
                this.showNotification('Tüm sinyal geçmişi silindi.', 'info');
                this.cusumDetector.reset(); 
                if (this.settings.features.enableTTS) {
                    this.speak('Tüm sinyal geçmişi silindi.');
                }
            }
        }

        showNotification(message, type = 'info') { const c=document.getElementById('notifications-container'); if(!c) return; const n = document.createElement('div'); n.className=`notification ${type}`; n.textContent=message; c.prepend(n); setTimeout(() => { n.style.transition='opacity 0.5s ease'; n.style.opacity=0; setTimeout(()=>n.remove(), 500); }, 5000); }
        logToJournal(message) { console.log(`[LOG] ${new Date().toLocaleTimeString()} - ${message}`); }
        
        // TTS Fonksiyonları
        loadVoices() {
            if (!this.synth) return; 

            const populateVoiceList = () => {
                this.voices = this.synth.getVoices();
                this.updateTTSVoiceSelectUI(); 
            };

            if (this.synth.getVoices().length > 0) {
                populateVoiceList();
            } else {
                this.synth.onvoiceschanged = populateVoiceList;
            }
        }

        updateTTSVoiceSelectUI() {
            const voiceSelect = document.getElementById('modal-tts-voice-select');
            if (!voiceSelect) return;

            voiceSelect.innerHTML = ''; 

            if (!this.synth || !this.settings.features.enableTTS || this.voices.length === 0) {
                const option = document.createElement('option');
                option.textContent = !this.synth ? "TTS Desteklenmiyor" : "Sesler Yüklenmedi / Yok";
                option.value = "";
                option.disabled = true;
                option.selected = true;
                voiceSelect.appendChild(option);
                voiceSelect.disabled = true;
                return;
            }

            const defaultOption = document.createElement('option');
            defaultOption.textContent = "Otomatik Seç (tr-TR)";
            defaultOption.value = ""; 
            voiceSelect.appendChild(defaultOption);

            let foundPreferred = false;

            this.voices.forEach(voice => {
                const option = document.createElement('option');
                option.textContent = `${voice.name} (${voice.lang})`;
                option.value = voice.name;
                if (this.settings.features.preferredVoiceName && voice.name === this.settings.features.preferredVoiceName) {
                    option.selected = true;
                    foundPreferred = true;
                }
                voiceSelect.appendChild(option);
            });

            if (this.settings.features.preferredVoiceName && !foundPreferred) {
                defaultOption.selected = true;
                this.settings.features.preferredVoiceName = null; 
                this.saveSettings(); 
            } else if (!this.settings.features.preferredVoiceName && !voiceSelect.querySelector('option[selected]')) {
                defaultOption.selected = true;
            }

            voiceSelect.disabled = false; 
        }

        speak(text, options = {}) {
            if (!this.settings.features.enableTTS) return; 
            if (!this.synth) { 
                console.warn('SpeechSynthesis API kullanılabilir değil, konuşma yapılamıyor:', text);
                return;
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = options.lang || 'tr-TR'; 
            utterance.rate = options.rate || 1.1; 
            utterance.pitch = options.pitch || 1.0; 

            let selectedVoice = null;
            if (this.voices.length > 0) {
                if (this.settings.features.preferredVoiceName) {
                    selectedVoice = this.voices.find(v => v.name === this.settings.features.preferredVoiceName);
                }
                if (!selectedVoice) {
                    selectedVoice = this.voices.find(v => v.lang === 'tr-TR');
                }
                if (!selectedVoice) {
                    selectedVoice = this.voices.find(v => v.default) || this.voices[0];
                }
            } 
            
            utterance.voice = selectedVoice;

            utterance.onend = () => {
                this.isSpeaking = false;
                this._processSpeechQueue();
            };
            utterance.onerror = (event) => {
                console.error('SpeechSynthesisError:', event.error, 'Konuşulan Metin:', text);
                this.isSpeaking = false;
                this._processSpeechQueue();
            };

            this.speechQueue.push(utterance);
            if (!this.isSpeaking) {
                this._processSpeechQueue();
            }
        }

        _processSpeechQueue() {
            if (this.speechQueue.length > 0 && !this.isSpeaking) {
                const utterance = this.speechQueue.shift();
                this.isSpeaking = true;
                this.synth.speak(utterance);
            }
        }

        getRandomMessage(key, placeholders = {}) {
            if (!this.speechTexts[key] || this.speechTexts[key].length === 0) {
                console.warn(`Konuşma metni anahtarı bulunamadı veya boş: ${key}`);
                return ""; 
            }
            const messages = this.speechTexts[key];
            const randomIndex = Math.floor(Math.random() * messages.length);
            let message = messages[randomIndex];

            for (const placeholderKey in placeholders) {
                const regex = new RegExp(`\\[${placeholderKey}\\]`, 'g');
                message = message.replace(regex, placeholders[placeholderKey]);
            }
            return message;
        }

        saveSettings() { localStorage.setItem('utc_settings', JSON.stringify(this.settings)); }
        loadSettings() {
            const defaultActive = {};
            this.allStrategyKeys.forEach((key) => defaultActive[key] = true); 
            const defaults = {
                confluenceThreshold: 3,
                params: { rsiPeriod: 14, atrPeriod: 14, wallBtc: 20, rrRatio: 1.5 },
                cooldowns: { 
                    signalMs: 15000, sameDirectionMs: 30000, proposalTimeoutMs: 3000, strategyProposalMs: 10000,
                    oppositeDirectionMs: 20000, reverseHysteresisPoints: 2
                },
                optimization: {
                    enabled: true, 
                    timeDecaySec: 3,
                    dirMargin: 0.5,
                    gating: { enabled: true, spreadMaxPct: 0.0015, minDepthUsd: 50000, topN: 5 },
                    breakeven: { enabled: true, beAtR: 0.8, trailAfterR: 1.5, trailToR: 0.5 },
                    autoToggle: true,
                    minWeightToStay: 0.6,
                    minContribForToggle: 30
                },
                features: { 
                    enableSpoofDetection: true,
                    enableCUSUMDrift: true,
                    enableRiskGuardian: true,
                    enableShadowABTesting: false, 
                    enableTTS: true,
                    preferredVoiceName: null 
                },
                riskGuardian: { 
                    killSwitchWinRate: 30 
                },
                activeStrategies: defaultActive
            };
            const saved = this.loadData('utc_settings');
            if(saved) {
                return {
                    ...defaults,
                    ...saved,
                    params: { ...defaults.params, ...(saved.params||{}) },
                    cooldowns: { ...defaults.cooldowns, ...(saved.cooldowns||{}) },
                    optimization: { 
                        ...defaults.optimization, 
                        ...(saved.optimization||{}),
                        gating: { ...defaults.optimization.gating, ...(saved.optimization?.gating||{}) },
                        breakeven: { ...defaults.optimization.breakeven, ...(saved.optimization?.breakeven||{}) }
                    },
                    features: { ...defaults.features, ...(saved.features||{}) },
                    riskGuardian: { ...defaults.riskGuardian, ...(saved.riskGuardian||{}) },
                    activeStrategies: { ...defaults.activeStrategies, ...(saved.activeStrategies||{}) }
                };
            }
            return defaults;
        }
        saveData(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); } catch(e) { console.error("Veri kaydedilemedi:", e); } }
        loadData(key) { try { const data = localStorage.getItem(key); return data ? JSON.parse(data) : null; } catch(e) { console.error("Veri okunamadı:", e); return null; } }
    }

    document.addEventListener('DOMContentLoaded', () => { 
        try { 
            window.app = new UltimateTradingCommandCenter(); 
            setTimeout(() => window.dispatchEvent(new Event('resize')), 100);
        } 
        catch(e) {
            console.error("Uygulama başlatılırken kritik bir hata oluştu:", e);
            document.body.innerHTML = `<div style="color: red; padding: 20px; font-family: monospace;">Uygulama başlatılamadı. Konsolu kontrol edin. Hata: ${e.message}</div>`;
        }
    });
</script>
</body>
</html>
