<!DOCTYPE html>
<html lang="tr" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTIMATE TRADING KOMUTA MERKEZİ v2.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <!-- TSParticles for visual effects -->
    <script src="https://cdn.jsdelivr.net/npm/tsparticles-slim@2.12.0/tsparticles.slim.min.js"></script>
    <script>
    // Sayfa yüklendiğinde çalışacak ana fonksiyon
    function initApp() {
        console.log('initApp başlatılıyor...');
        // Panteon UI için sürükleme özelliği
                        // --- YENİ PANTEON AÇ/KAPAT MANTIĞI ---
        const pantheonToggleButton = document.getElementById('pantheon-toggle-btn');
        const pantheonUIContainer = document.getElementById('pantheon-ui');
        if (pantheonToggleButton && pantheonUIContainer) {
            const isPantheonVisible = localStorage.getItem('isPantheonVisible') === 'true';
            if (isPantheonVisible) {
                pantheonUIContainer.classList.add('visible');
            }
            pantheonToggleButton.addEventListener('click', () => {
                const isVisible = pantheonUIContainer.classList.toggle('visible');
                localStorage.setItem('isPantheonVisible', isVisible);
            });
        }
        // --- PANTEON AÇ/KAPAT MANTIĞI SONU ---
        const pantheonUI = document.getElementById('pantheon-ui');
        if (pantheonUI) {
            let isDragging = false;
            let offsetX, offsetY;
            
            function startDrag(e) {
                isDragging = true;
                offsetX = e.clientX - pantheonUI.getBoundingClientRect().left;
                offsetY = e.clientY - pantheonUI.getBoundingClientRect().top;
                pantheonUI.style.cursor = 'grabbing';
                e.preventDefault();
            }
            
            function onDrag(e) {
                if (!isDragging) return;
                pantheonUI.style.left = (e.clientX - offsetX) + 'px';
                pantheonUI.style.top = (e.clientY - offsetY) + 'px';
            }
            
            function stopDrag() {
                isDragging = false;
                pantheonUI.style.cursor = 'grab';
                
                // Pozisyonu kaydet
                const rect = pantheonUI.getBoundingClientRect();
                localStorage.setItem('pantheonUIPosition', JSON.stringify({
                    left: rect.left,
                    top: rect.top
                }));
            }
            
            // Event listener'ları ekle
            pantheonUI.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('mouseleave', stopDrag);
            
            // Kayıtlı pozisyonu yükle
            const savedPosition = localStorage.getItem('pantheonUIPosition');
            if (savedPosition) {
                try {
                    const { left, top } = JSON.parse(savedPosition);
                    pantheonUI.style.left = `${left}px`;
                    pantheonUI.style.top = `${top}px`;
                } catch (e) {
                    console.error('Pozisyon yüklenirken hata:', e);
                }
            }
        }
        
        // Sistemleri güvenli bir şekilde başlatma
        try {
            // Panteon sistemi var mı kontrol et ve global değişkene ata
            if (typeof PantheonSystem === 'function' && window.panteon) {
                console.log('Panteon sistemi zaten başlatılmış, yeniden başlatılmayacak.');
            } else if (typeof PantheonSystem === 'function') {
                console.log('Panteon sistemi başlatılıyor...');
                window.panteon = new PantheonSystem();
            }
            
            // App nesnesi var mı kontrol et
            if (!window.app) {
                console.log('Trading Command Center başlatılıyor...');
                window.app = new UltimateTradingCommandCenter();
            }
        } catch (e) {
            console.error('Sistemleri başlatırken hata:', e);
        }
        
        // Panteon güç yönetimini başlat
        if (window.app && !window.app.pantheonPower) {
            window.app.pantheonPower = {
                buy: 0,
                sell: 0,
                lastUpdate: Date.now()
            };
        }
        
        // Panteon metodlarını app nesnesine güvenli bir şekilde bağla
        if (window.panteon && window.app) {
            if (window.panteon.increasePantheonPower) {
                window.app.increasePantheonPower = window.panteon.increasePantheonPower.bind(window.panteon);
            }
            if (window.panteon.updatePantheonUI) {
                window.app.updatePantheonUI = window.panteon.updatePantheonUI.bind(window.panteon);
            }
            if (window.panteon.triggerElciSpecialAbility) {
                window.app.triggerElciSpecialAbility = window.panteon.triggerElciSpecialAbility.bind(window.panteon);
            }
        } else {
            console.warn('Panteon veya App nesneleri henüz hazır değil.');
        }
        
        // Panteon arayüzünü güncelle
        if (window.app && window.app.updatePantheonUI) {
            window.app.updatePantheonUI();
        }
    }
    
    // Sayfa yüklendiğinde initApp'ı çalıştır
    document.addEventListener('DOMContentLoaded', initApp);
    </script>

    <style>
        :root {
            --background-dark: #0d1117; --panel-bg-dark: #161b22; --text-main-dark: #c9d1d9; --text-secondary-dark: #8b949e; --border-color-dark: #30363d; --input-bg-dark: #010409; --hover-bg-dark: #21262d; --primary-dark: #58a6ff;
            --background-light: #ffffff; --panel-bg-light: #f6f8fa; --text-main-light: #24292f; --text-secondary-light: #57606a; --border-color-light: #d0d7de; --input-bg-light: #f0f2f5; --hover-bg-light: #e8eaed; --primary-light: #0969da;
            --war-mode-bg: linear-gradient(145deg, #4d0000 0%, #000000 75%); --war-mode-panel-bg: rgba(255, 0, 0, 0.08); --war-mode-border: #8B0000; --war-mode-text: #ff5858; --war-mode-primary: #ffc107;
            --positive: #28a745; --negative: #dc3545; --neutral: #ffc107;
            
            /* YENİ: Panteon Renkleri */
            --metatron-color: #3b82f6; /* Mavi - Bilgelik */
            --uriel-color: #f59e0b;    /* Amber - Cesaret */
            --raphael-color: #10b981;  /* Zümrüt - Şifa */
            --gabriel-color: #8b5cf6;  /* Mor - İletişim */
            --michael-color: #ef4444;  /* Kırmızı - Savaş */
            --ticker-height: 30px; 
            --signal-bar-height: 40px;
            --header-min-height: 40px;
        }
        /* Fullscreen modda gizlenecek elemanlar */
        body.fullscreen-chart #super-top-ticker,
        body.fullscreen-chart #signal-progress-bar-container,
        body.fullscreen-chart .header,
        body.fullscreen-chart .panel-title {
            display: none !important;
        }

        /* Fullscreen modda chart'ı büyütme */
        body.fullscreen-chart .container { padding-top: 0 !important; height: 100vh !important; }
        body.fullscreen-chart .main-grid { height: 100vh !important; margin: 0 !important; }
        body.fullscreen-chart .center-panel { flex-grow: 1 !important; height: 100vh !important; border-radius: 0 !important; margin: 0 !important; }
        body.fullscreen-chart .data-container { height: 100% !important; }
        body.fullscreen-chart #chart-container-view,
        body.fullscreen-chart #live-chart { height: 100% !important; flex-grow: 1 !important; }
        body.fullscreen-chart .heatmap-container { display: none !important; }
        body.fullscreen-chart .chart-zoom-controls { background: rgba(0,0,0,0.7); }
        body.fullscreen-chart #exit-fullscreen-btn { display: block !important; }
        body.fullscreen-chart #chart-countdown-overlay { display: block !important; }

        [data-theme="light"] { --background: var(--background-light); --panel-bg: var(--panel-bg-light); --text-main: var(--text-main-light); --text-secondary: var(--text-secondary-light); --border-color: var(--border-color-light); --input-bg: var(--input-bg-light); --hover-bg: var(--hover-bg-light); --primary: var(--primary-light); }
        [data-theme="dark"] { --background: var(--background-dark); --panel-bg: var(--panel-bg-dark); --text-main: var(--text-main-dark); --text-secondary: var(--text-secondary-dark); --border-color: var(--border-color-dark); --input-bg: var(--input-bg-dark); --hover-bg: var(--hover-bg-dark); --primary: var(--primary-dark); }
        [data-theme="war"] { --background: var(--war-mode-bg); --panel-bg: var(--war-mode-panel-bg); --text-main: var(--war-mode-text); --text-secondary: #ffaaaa; --border-color: var(--war-mode-border); --input-bg: rgba(255, 255, 255, 0.05); --hover-bg: rgba(255, 255, 255, 0.1); --primary: var(--war-mode-primary); }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Roboto Mono', monospace; font-size: 12px; background: var(--background); color: var(--text-main); overflow: hidden; transition: background 0.5s, color 0.5s; }
        
        #super-top-ticker { display: flex; position: fixed; top: 0; left: 0; width: 100%; background: var(--panel-bg); border-bottom: 1px solid var(--border-color); padding: 2px 10px; z-index: 1100; align-items: center; justify-content: space-between; font-size: 11px; font-weight: 700; height: var(--ticker-height); }
        .super-top-left { display: flex; align-items: center; gap: 10px; flex-shrink: 0;}
        #ticker-bar-symbol { color: var(--primary); }
        #ticker-bar-price { color: var(--text-main); font-size: 12px; }
        .super-top-right-buttons { display: flex; gap: 5px; }

        .container { display: flex; flex-direction: column; height: 100vh; padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); }

        .header { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; flex-shrink: 0; box-shadow: 0 2px 10px rgba(0,0,0,0.2); margin: 5px; position: relative; }
        .header-top-bar { display: flex; align-items: center; width: 100%; padding: 5px 15px; min-height: var(--header-min-height); justify-content: space-between; cursor: pointer; font-weight: 700; font-size: 16px; color: var(--primary); }
        .header-collapsible-content { transition: max-height 0.35s ease-in-out, opacity 0.3s ease, padding 0.35s ease, visibility 0.35s; max-height: 300px; opacity: 1; overflow: hidden; visibility: visible; padding: 0 15px 8px 15px; }
        body.header-collapsed .header-collapsible-content { max-height: 0; opacity: 0; visibility: hidden; padding-top: 0; padding-bottom: 0; }

        .main-controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; padding-bottom: 8px; }
        .form-control { background: var(--input-bg); color: var(--text-main); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-family: 'Roboto Mono', monospace; }
        
        .status { display: flex; align-items: center; gap: 5px; font-size: 11px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--negative); transition: background-color 0.5s; }
        .status-dot.online { background: var(--positive); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 #28a745b3; } 70% { box-shadow: 0 0 0 6px #28a74500; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        [data-theme="war"] .status-dot.online { background: var(--war-mode-primary); animation: war-pulse 1s infinite; }
        @keyframes war-pulse { 0% { box-shadow: 0 0 0 0 #ffc107b3; } 70% { box-shadow: 0 0 0 6px #ffc10700; } 100% { box-shadow: 0 0 0 0 #28a74500; } }
        .btn { padding: 4px 12px; border: 1px solid var(--border-color); background: var(--panel-bg); color: var(--text-main); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .btn:hover { background: var(--hover-bg); border-color: var(--primary); }
        .btn-success { background: var(--positive); color: white; border-color: var(--positive); } .btn-danger { background: var(--negative); color: white; border-color: var(--negative); }
        .btn-tiny { padding: 2px 6px; font-size: 10px; line-height: 1; min-width: 0; white-space: nowrap; }
        
        .main-grid { display: grid; grid-template-columns: 1fr; gap: 5px; flex-grow: 1; margin: 5px; overflow: hidden; height: calc(100% - var(--header-min-height) - 10px - var(--ticker-height) - var(--signal-bar-height)); }
        body.header-collapsed .main-grid { height: calc(100vh - var(--ticker-height) - var(--signal-bar-height) - 10px); margin-top: 0; } 
        
        .panel { display: flex; flex-direction: column; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; overflow: hidden; position: relative;}
        .panel-title { font-weight: 700; font-size: 13px; color: var(--primary); padding: 8px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;}
        .panel-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
        .settings-group { margin-bottom: 15px; } .form-group { margin-bottom: 8px; } .form-label { display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 4px; }
        .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 12px; padding: 4px 0;}
        
        .price-display { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; width: 100%; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; font-size: 10px; margin-top: 8px; } 
        .price-item .price-label { color: var(--text-secondary); } 
        .price-item .price-value { font-size: 18px; font-weight: 700; }
        .price-item.countdown { grid-column: 1 / span 2; display: flex; justify-content: center; align-items: center; font-size: 14px; font-weight: 700; color: var(--primary); padding-top: 5px;}
        
        .center-panel { display: grid; grid-template-rows: 1fr; gap: 5px; padding: 0 !important; } 
        .data-container { display: grid; grid-template-rows: 1fr auto; overflow: hidden; height: 100%; } 
        .data-grid { position: relative; overflow: hidden; min-height: 0; } 

        #live-chart { width: 100%; height: 100%; } 
        .heatmap-container { display: grid; grid-template-rows: auto 1fr; border-top: 1px solid var(--border-color); }
        #orderbook-heatmap { width: 100%; height: 100%; display: block; }

        .chart-zoom-controls { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 100; }
        .chart-zoom-controls .btn-tiny { background: rgba(1, 4, 9, 0.7); backdrop-filter: blur(2px); }

        #exit-fullscreen-btn {
            position: absolute; top: 10px; right: 10px; z-index: 101; 
            background: rgba(1, 4, 9, 0.7); color: white; border-radius: 4px; 
            padding: 2px 6px; font-size: 16px; cursor: pointer; border: 1px solid var(--border-color);
            line-height: 1;
        }
        #chart-countdown-overlay {
            position: absolute; top: 10px; left: 10px; z-index: 100; 
            background: rgba(1, 4, 9, 0.7); padding: 4px 8px; border-radius: 4px; 
            color: var(--primary); font-size: 14px; font-weight: bold;
        }

        .data-table-container { width: 100%; height: 100%; overflow: auto; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .data-table th, .data-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid var(--border-color); white-space: nowrap;}
        .data-table th { font-weight: 700; position: sticky; top: 0; background: var(--panel-bg); z-index: 10;}
        .data-table tr:hover { background: var(--hover-bg); }
        .signal-buy { background-color: #28a74514; } .signal-sell { background-color: #dc354514; }
        .signal-tp { background-color: #28a74533; } .signal-sl { background-color: #dc354533; }
        .signal-pending { background-color: #ffc1071a; } /* Neutral/warning color with transparency */

        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border-color); font-size: 12px; }
        .stat-item:last-child { border-bottom: none; } .stat-label { color: var(--text-secondary); } .stat-value { font-weight: 700; }
        .btn-sm { padding: 1px 4px; font-size: 9px; margin-left: 4px; border-radius: 3px; cursor: pointer;}
        ::-webkit-scrollbar { width: 6px; height: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--text-secondary); border-radius: 3px; }
        .n        /* DÜZELTME: Bildirimlerin yeni stili ve konumu */
        .notifications { 
            position: fixed; 
            bottom: 15px; 
            left: 15px; /* Sağdan sola alındı */
            z-index: 2000; 
            width: 280px; /* Daha dar */
        }
        .notification { 
            background: rgba(22, 27, 34, 0.9); /* Hafif transparan */
            backdrop-filter: blur(4px);
            border: 1px solid var(--border-color); 
            border-left-width: 4px; 
            border-radius: 4px; 
            padding: 8px 12px; /* Daha küçük padding */
            font-size: 12px; /* Daha küçük font */
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); 
            margin-top: 8px; 
            animation: slide-in 0.3s ease-out;
        }
        @keyframes slide-in {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .notification.success { border-left-color: var(--positive); } 
        .notification.danger { border-left-color: var(--negative); } 
        .notification.warning { border-left-color: var(--neutral); }
        
        aside#settings-panel, aside#analytics-panel { display: none !important; }
        .hidden-view { display: none !important; } 

        /* YENİ LOG PANELİ STİLLERİ */
        #log-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 2550; }
        #log-modal-overlay.visible { display: flex; }
        .log-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 95%; max-width: 1000px; height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); }
        .log-modal-header { padding: 10px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 14px; color: var(--primary); }
        .log-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
        .log-modal-body { padding: 0; overflow-y: auto; flex-grow: 1; }
        #log-output { font-family: 'Roboto Mono', monospace; font-size: 11px; color: var(--text-secondary); padding: 10px; margin: 0; white-space: pre-wrap; word-break: break-all; }
        #log-output .log-error { color: var(--negative); }
        #log-output .log-warn { color: var(--neutral); }
        #log-output .log-info { color: var(--positive); }

        
        aside#settings-panel, aside#analytics-panel { display: none !important; }
        .hidden-view { display: none !important; } 

        #settings-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 2500; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        #settings-modal-overlay.visible { opacity: 1; visibility: visible; }
        .settings-modal-content { background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; width: 90%; max-width: 900px; max-height: 90%; display: flex; flex-direction: column; box-shadow: 0 8px 30px rgba(0,0,0,0.4); transform: translateY(20px); transition: transform 0.3s ease; }
        #settings-modal-overlay.visible .settings-modal-content { transform: translateY(0); }
        .settings-modal-header { padding: 12px 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: 700; font-size: 15px; color: var(--primary); }
        .settings-modal-header .close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary); cursor: pointer; padding: 0 5px; line-height: 1; }
        .settings-modal-header .close-btn:hover { color: var(--negative); }
        .settings-modal-body { padding: 15px; overflow-y: auto; flex-grow: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .settings-modal-footer { padding: 12px 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; }

        /* Yeni Sinyal Barı */
        #signal-progress-bar-container {
            display: flex; gap: 5px; width: 100%; padding: 5px 10px; background: var(--panel-bg); 
            border-bottom: 1px solid var(--border-color); justify-content: space-around; align-items: center;
            position: fixed; top: var(--ticker-height); left: 0; z-index: 1099;
            height: var(--signal-bar-height);
        }
        .signal-bar-wrapper { flex: 1; text-align: center; }
        .signal-bar-label { font-size: 10px; color: var(--text-secondary); margin-bottom: 3px; }
        .signal-bar { width: 100%; height: 10px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 5px; overflow: hidden; position: relative; }
        .signal-bar-fill { height: 100%; width: 0%; transition: width 0.2s ease-out; position: absolute; left: 0; top: 0; background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.buy { background: linear-gradient(90deg, transparent, var(--positive)); }
        .signal-bar-fill.sell { background: linear-gradient(90deg, transparent, var(--negative)); }
        .signal-score-text { font-size: 9px; margin-top: 2px; color: var(--primary); }

        /* Resizable Handle */
        .resize-handle { position: absolute; bottom: 0; left: 0; width: 100%; height: 8px; cursor: ns-resize; background: var(--border-color); z-index: 10; border-top: 1px solid var(--border-color); }
        .center-panel.resizing { user-select: none; }

        /* Panteon UI Stilleri */
                        /* --- YENİ PANTEON AÇ/KAPAT BUTONU STİLLERİ --- */
        #pantheon-toggle-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            color: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        #pantheon-toggle-btn:hover {
            transform: scale(1.1);
            border-color: var(--primary);
        }
        
        /* --- GÜNCELLENMİŞ VE KÜÇÜLTÜLMÜŞ PANTEON UI STİLLERİ --- */
        .pantheon-ui {
            position: fixed;
            bottom: 80px; /* Butonun üstünde yer alacak */
            right: 20px;
            background: rgba(22, 27, 34, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            width: 180px; /* Yarı yarıya küçültüldü */
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s ease;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95) translateY(10px);
        }
        .pantheon-ui.visible {
            opacity: 1;
            visibility: visible;
            transform: scale(1) translateY(0);
        }
        .pantheon-header {
            margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid var(--border-color);
            display: flex; justify-content: space-between; align-items: center;
        }
        .pantheon-header span {
            font-weight: 700; color: var(--primary); font-size: 11px;
        }
        .pantheon-close {
            background: none; border: none; color: var(--text-secondary);
            font-size: 18px; cursor: pointer; line-height: 1; padding: 0 4px;
        }
        .pantheon-close:hover { color: var(--negative); }
        .pantheon-gods {
            display: flex; flex-direction: column; gap: 4px; margin-bottom: 8px;
        }
        .god {
            display: flex; align-items: center; padding: 4px;
            border-radius: 4px; background: var(--input-bg); transition: all 0.2s ease;
        }
        .god:hover { background: var(--hover-bg); transform: translateX(2px); }
        .god-icon { font-size: 12px; margin-right: 6px; width: 18px; text-align: center; }
        .god-name { font-weight: 600; font-size: 10px; width: 55px; }
        .god-power { font-size: 9px; width: 28px; text-align: right; margin-right: 5px; font-family: 'Roboto Mono', monospace;}
        .god-progress { flex-grow: 1; height: 6px; background: var(--border-color); border-radius: 3px; overflow: hidden; }
        .god-progress-fill { height: 100%; width: 0%; transition: width 0.3s ease, background-color 0.3s ease; }
        
        .metatron .god-progress-fill { background: var(--metatron-color); }
        .uriel .god-progress-fill { background: var(--uriel-color); }
        .raphael .god-progress-fill { background: var(--raphael-color); }
        .gabriel .god-progress-fill { background: var(--gabriel-color); }
        .michael .god-progress-fill { background: var(--michael-color); }
        
        .pantheon-abilities {
            display: flex; gap: 5px; margin-top: 8px; padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }
        .ability {
            flex: 1; background: var(--input-bg); border-radius: 4px; padding: 5px;
            text-align: center; cursor: pointer; transition: all 0.2s ease; position: relative; overflow: hidden;
        }
        .ability:hover { transform: translateY(-2px); box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); }
        .ability-icon { font-size: 12px; margin-bottom: 2px; }
        .ability-name { font-size: 9px; font-weight: 600; }
        .ability-cooldown {
            position: absolute; bottom: 0; left: 0;
            height: 2px; background: var(--primary); width: 100%;
            transform-origin: left; transform: scaleX(0); transition: transform 0.1s linear;
        }
        
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
        .ability.active { animation: pulse 1.5s infinite; }

                        /* DÜZELTME: Metinlerin yanlışlıkla seçilmesini engelle */
        .btn, .panel-title, .header-top-bar, .signal-bar-label, .form-label {
            user-select: none; /* Standart */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
        }

                                @media screen and (max-width: 768px) {
            .desktop-only { display: none !important; }
            .mobile-only { display: flex !important; align-items: center; }

            .container { 
                padding-top: calc(var(--ticker-height) + var(--signal-bar-height)); 
                padding-bottom: var(--header-min-height); 
            }
            #signal-progress-bar-container { top: var(--ticker-height); }
            
            .header { 
                order: 2; 
                position: fixed;
                bottom: 0; 
                left: 0;
                right: 0;
                width: 100%; 
                z-index: 1000; 
                margin: 0; 
                border-radius: 0; 
                border: none; 
                border-top: 1px solid var(--border-color); 
            }
            /* DÜZELTME: Butonlar ve başlık için yeni ve daha basit düzen */
            .header-top-bar { 
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 10px; 
                min-height: var(--header-min-height);
            }
            .header-center-title {
                cursor: pointer;
                flex-grow: 1;
                text-align: center;
            }
            .header-left-controls, .header-right-controls {
                display: flex;
                gap: 8px;
            }
            #mobile-toggle-controls-btn, .header-right-controls .btn {
                font-size: 16px;
                padding: 5px 10px;
            }
            /* Mobilde masaüstü başlığını gizle */
            .header-center-title .header-title-text {
                display: none;
            }

            .header-collapsible-content { padding: 0; }
            .header-collapsible-content .main-controls { flex-direction: column; align-items: center; padding: 0; width: 100%; }
            .form-control, .btn, .status { width: 100%; text-align: center; padding: 8px 10px; font-size: 11px; }
            .status { justify-content: center; }
            .price-display { grid-template-columns: repeat(2, 1fr); margin-top: 10px; }
            .price-item .price-value { font-size: 14px; } 
            
            .main-grid { 
                order: 1; 
                margin: 0;
                height: 100%;
                display: flex;
                flex-direction: column;
            }
            .center-panel { 
                order: 1; 
                flex-grow: 1;
                height: 100%;
                border: none;
                border-radius: 0; 
                background: transparent;
                box-shadow: none; 
                margin: 0; 
            }
            .center-panel > .panel-title { display: none; }
            .data-container { 
                flex-direction: column; 
                height: 100%; 
                padding: 5px;
            }
            .data-grid { 
                height: 100%;
                flex-grow: 1;
            }
            #live-chart { height: 100%; width: 100%; } 
            .heatmap-container { height: 150px; flex-shrink: 0; margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 10px; }
            .heatmap-container .panel-title { border-bottom: none; margin-bottom: 5px; }
            .settings-modal-content { width: 95%; margin: 10px; }
            .settings-modal-body { grid-template-columns: 1fr; gap: 15px; }
            .super-top-right-buttons { display: none; }
            .resize-handle { display: none; }
            #chart-countdown-overlay { font-size: 12px; padding: 3px 6px; }

            body.fullscreen-chart .main-grid { height: 100vh; }
            body.fullscreen-chart .center-panel { height: 100vh; }
        }




    </style>
</head>
<body class="header-collapsed"> 
    <!-- Canvas for visual effects -->
    <canvas id="effects-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;"></canvas> 
    
        <!-- YENİ PANTEON AÇ/KAPAT BUTONU -->
    <button id="pantheon-toggle-btn" title="Panteon Sistemini Aç/Kapat">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path d="M12 1.25a3.5 3.5 0 1 0 0 7 3.5 3.5 0 1 0 0-7zM3.5 9.25a3.5 3.5 0 1 0 0 7 3.5 3.5 0 1 0 0-7zm17 0a3.5 3.5 0 1 0 0 7 3.5 3.5 0 1 0 0-7zM12 15.75a3.5 3.5 0 1 0 0 7 3.5 3.5 0 1 0 0-7z"></path></svg>
    </button>
    <!-- Panteon Sistemi UI -->
    <div id="pantheon-ui" class="pantheon-ui">
        <div class="pantheon-header">
            <span>PANTEON SİSTEMİ</span>
            <button class="pantheon-close">×</button>
        </div>
        
        <div class="pantheon-gods">
            <div class="god metatron" data-god="metatron">
                <div class="god-icon">👁️</div>
                <div class="god-name">Metatron</div>
                <div class="god-power">0%</div>
                <div class="god-progress">
                    <div class="god-progress-fill"></div>
                </div>
            </div>
            
            <div class="god uriel" data-god="uriel">
                <div class="god-icon">⚔️</div>
                <div class="god-name">Uriel</div>
                <div class="god-power">0%</div>
                <div class="god-progress">
                    <div class="god-progress-fill"></div>
                </div>
            </div>
            
            <div class="god raphael" data-god="raphael">
                <div class="god-icon">💊</div>
                <div class="god-name">Raphael</div>
                <div class="god-power">0%</div>
                <div class="god-progress">
                    <div class="god-progress-fill"></div>
                </div>
            </div>
            
            <div class="god gabriel" data-god="gabriel">
                <div class="god-icon">📢</div>
                <div class="god-name">Gabriel</div>
                <div class="god-power">0%</div>
                <div class="god-progress">
                    <div class="god-progress-fill"></div>
                </div>
            </div>
            
            <div class="god michael" data-god="michael">
                <div class="god-icon">⚖️</div>
                <div class="god-name">Michael</div>
                <div class="god-power">0%</div>
                <div class="god-progress">
                    <div class="god-progress-fill"></div>
                </div>
            </div>
        </div>
        
        <div class="pantheon-abilities">
            <div class="ability" id="ability-revelation" data-ability="revelation">
                <div class="ability-icon">🔍</div>
                <div class="ability-name">Vahiy</div>
                <div class="ability-cooldown"></div>
            </div>
            <div class="ability" id="ability-valor" data-ability="valor">
                <div class="ability-icon">🛡️</div>
                <div class="ability-name">Cesaret</div>
                <div class="ability-cooldown"></div>
            </div>
            <div class="ability" id="ability-restoration" data-ability="restoration">
                <div class="ability-icon">💫</div>
                <div class="ability-name">Şifa</div>
                <div class="ability-cooldown"></div>
            </div>
        </div>
    </div>
    
        <div id="super-top-ticker">
        <div class="super-top-left">
            <span id="ticker-bar-symbol"></span>
            <span id="ticker-bar-price"></span>
        </div>
        <!-- MASAÜSTÜ BUTONLARI -->
        <div class="super-top-right-buttons desktop-only">
            <button id="main-controls-btn" class="btn btn-tiny">Komuta Merkezi</button>
            <button id="chart-view-btn" class="btn btn-tiny">Grafik</button>
            <button id="heatmap-view-btn" class="btn btn-tiny">Isı Haritası</button>
            <button id="fullscreen-chart-btn" class="btn btn-tiny">Tam Ekran Grafik</button>
            <button id="honor-board-btn" class="btn btn-tiny">Şeref Tablosu</button>
            <button id="banned-board-btn" class="btn btn-tiny">Banlılar</button>
            <button id="open-settings-modal-btn" class="btn btn-tiny">Ayarlar</button>
        </div>
                <!-- YENİ MOBİL BUTONLARI -->
        <div class="super-top-right-buttons mobile-only">
            <button id="mobile-fullscreen-chart-btn" class="btn btn-tiny">Tam Ekran</button>
            <!-- DÜZELTME: Yeni Log butonu eklendi -->
            <button id="mobile-open-log-modal-btn" class="btn btn-tiny">📜 Log</button>
            <button id="mobile-open-settings-modal-btn" class="btn btn-tiny btn-success">Ayarlar</button>
        </div>

    </div>


    <!-- Yeni Sinyal Barı -->
    <div id="signal-progress-bar-container">
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">BUY SINYAL GÜCÜ</div>
            <div class="signal-bar">
                <div id="buy-signal-bar-fill" class="signal-bar-fill buy"></div>
            </div>
            <div id="buy-signal-score-text" class="signal-score-text">0.0</div>
        </div>
        <div class="signal-bar-wrapper">
            <div class="signal-bar-label">SELL SINYAL GÜCÜ</div>
            <div class="signal-bar">
                <div id="sell-signal-bar-fill" class="signal-bar-fill sell"></div>
            </div>
            <div id="sell-signal-score-text" class="signal-score-text">0.0</div>
        </div>
    </div>

    <div class="container">
                                <header class="header">
            <div id="header-main-bar" class="header-top-bar">
                <div class="header-left-controls">
                    <button id="mobile-toggle-controls-btn" class="btn btn-tiny mobile-only" title="Kontrolleri Aç/Kapat">☰</button>
                </div>
                <div class="header-center-title" title="Paneli aç/kapatmak için çift tıkla">
                    <span class="header-title-text">KOMUTA MERKEZİ KONTROLLERİ</span>
                </div>
                <div class="header-right-controls">
                    <!-- DÜZELTME: Eksik olan Grafik butonu eklendi -->
                    <button id="mobile-chart-view-btn" class="btn btn-tiny mobile-only" title="Grafik">📈</button>
                    <button id="mobile-heatmap-view-btn" class="btn btn-tiny mobile-only" title="Isı Haritası">🔥</button>
                    <button id="mobile-honor-board-btn" class="btn btn-tiny mobile-only" title="Şeref Tablosu">🏆</button>
                    <button id="mobile-banned-board-btn" class="btn btn-tiny mobile-only" title="Banlılar">BAN</button>
                </div>
            </div>
            <div class="header-collapsible-content">
                <div class="main-controls">
                    <input type="text" id="symbol-input" class="form-control" placeholder="Örn: BTC, ETH, SOL">
                    <select id="timeframe-select" class="form-control">
                        <option value="1m">1m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option>
                    </select>
                    <div class="status">
                        <div id="connection-status" class="status-dot"></div>
                        <span id="connection-text">BAĞLANTI YOK</span>
                    </div>
                    <button id="theme-toggle-btn" class="btn">Tema</button>
                    <button id="start-btn" class="btn btn-success">SİSTEMİ BAŞLAT</button>
                    <button id="stop-btn" class="btn btn-danger" disabled>DURDUR</button>
                    <button id="clear-markers-btn" class="btn">Grafik Sinyallerini Sil</button> 
                </div>
                <div class="price-display">
                    <div class="price-item"><div class="price-label">FİYAT</div><div class="price-value" id="current-price">-</div></div>
                    <div class="price-item"><div class="price-label">24s DEĞİŞİM</div><div class="price-value" id="price-change-24h">-</div></div>
                    <div class="price-item"><div class="price-label">24s HACİM</div><div class="price-value" id="volume-24h">-</div></div>
                    <div class="price-item"><div class="price-label">VOLATİLİTE (ATR)</div><div class="price-value" id="atr-value">-</div></div>
                    <div class="price-item countdown"><span id="candle-countdown">--:--</span></div>
                </div>
            </div>
        </header>




        <main class="main-grid">
            <section class="center-panel panel">
                <div class="data-container">
                    <div class="data-grid" id="chart-container-view">
                        <div id="live-chart"></div>
                        <div class="chart-zoom-controls"> 
                            <button id="chart-zoom-in" class="btn btn-tiny">+</button>
                            <button id="chart-zoom-out" class="btn btn-tiny">-</button>
                            <button id="chart-zoom-reset" class="btn btn-tiny">Sıfırla</button>
                        </div>
                        <button id="exit-fullscreen-btn" class="btn btn-tiny hidden-view" title="Tam Ekrandan Çık">&times;</button>
                        <div id="chart-countdown-overlay" class="hidden-view">--:--</div>
                    </div>
                    <div class="heatmap-container" id="heatmap-container-view">
                        <div class="panel-title" style="border-top: 1px solid var(--border-color); border-bottom: none;">EMİR DEFTERİ ISI HARİTASI</div>
                        <canvas id="orderbook-heatmap"></canvas>
                    </div>
                </div>
                <div class="resize-handle"></div>
            </section>
        </main>
    </div>
    
    <div id="notifications-container" class="notifications"></div>

    <!-- AYARLAR MODAL -->
    <div id="settings-modal-overlay">
        <div class="settings-modal-content">
            <div class="settings-modal-header">
                <span>AYARLAR & OPTİMİZASYON</span>
                <button class="close-btn" id="close-settings-modal-btn">&times;</button>
            </div>
            <div class="settings-modal-body">
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Temel Parametreler</div>
                    <div class="form-group"><label class="form-label">Min. Uyum Skoru (1-10)</label><input type="range" id="modal-confluence-threshold" class="form-control" min="1" max="10" value="3" step="1"></div>
                    <div class="form-group"><label class="form-label">RSI Periyodu</label><input type="number" id="modal-param-rsi-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">ATR Periyodu</label><input type="number" id="modal-param-atr-period" class="form-control" value="14"></div>
                    <div class="form-group"><label class="form-label">Duvar Tespiti (BTC Miktarı)</label><input type="number" id="modal-param-wall-btc" class="form-control" value="20"></div>
                    <div class="form-group"><label class="form-label">Risk/Ödül Oranı (R/R)</label><input type="number" id="modal-param-rr-ratio" class="form-control" value="1.5" step="0.1"></div>
                </div>
                <div
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Cooldown Ayarları</div>
                    <div class="form-group"><label class="form-label">Genel Sinyal Cooldown (ms)</label><input type="number" id="modal-signal-cooldown-ms" class="form-control" value="15000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Aynı Yön Sinyal Cooldown (ms)</label><input type="number" id="modal-same-direction-cooldown-ms" class="form-control" value="30000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Yön Cooldown (ms)</label><input type="number" id="modal-opposite-direction-cooldown-ms" class="form-control" value="20000" min="0" step="100"></div>
                    <div class="form-group"><label class="form-label">Ters Yön Histerezis (+Puan)</label><input type="number" id="modal-reverse-hysteresis-points" class="form-control" value="2" min="0" step="1"></div>
                    <div class="form-group"><label class="form-label">Proposal Timeout (ms)</label><input type="number" id="modal-proposal-timeout-ms" class="form-control" value="3000" min="500" step="100"></div>
                    <div class="form-group"><label class="form-label">Strateji Teklifi Cooldown (ms)</label><input type="number" id="modal-strategy-proposal-cooldown-ms" class="form-control" value="10000" min="0" step="100"></div>
                </div>
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Gelişmiş Özellikler</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-spoof-detection" class="feature-toggle" checked> Spoof Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-cusum-drift" class="feature-toggle" checked> CUSUM Sapma Tespiti</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-risk-guardian" class="feature-toggle" checked> Risk Koruyucu (Kill Switch)</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-optimize" class="feature-toggle" checked> Oto-Optimizasyon</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-auto-toggle-strat" class="feature-toggle" checked> Stratejileri Oto-Ayarla</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-breakeven-trail" class="feature-toggle" checked> Maliyete Çek/Takip Eden SL</label></div>
                    <div class="form-group"><label class="form-label">BE R Oranı</label><input type="number" id="modal-be-at-r" class="form-control" value="0.8" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Başlangıç R Oranı</label><input type="number" id="modal-trail-after-r" class="form-control" value="1.5" step="0.1"></div>
                    <div class="form-group"><label class="form-label">Trailing Kârı R Oranı</label><input type="number" id="modal-trail-to-r" class="form-control" value="0.5" step="0.1"></div>
                </div>

                <!-- YENİ EKLENEN BÖLÜM BAŞLANGICI -->
                <div class="settings-group">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Teyit & Gelişmiş Filtreleme</div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-candle-confirm" class="feature-toggle" checked> Sinyal için Mum Kapanışını Bekle</label></div>
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-mtf-confirm" class="feature-toggle" checked> Üst Zaman Dilimi Trend Teyidi</label></div>
                    <div class="form-group">
                        <label class="form-label">MTF Zaman Dilimi</label>
                        <select id="modal-mtf-timeframe" class="form-control">
                            <option value="5m">5m</option>
                            <option value="15m" selected>15m</option>
                            <option value="1h">1h</option>
                            <option value="4h">4h</option>
                        </select>
                    </div>
                     <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-dynamic-sizing" class="feature-toggle" checked> Sinyal Gücüne Göre Dinamik Boyutlandırma</label></div>
                    <hr style="border-color: var(--border-color); margin: 10px 0;">
                    <div class="form-group"><label class="checkbox-label"><input type="checkbox" id="modal-enable-tts" class="feature-toggle" checked> Sesli Bildirimler</label></div>
                    <div class="form-group">
                        <label class="form-label">Ses Seçimi</label>
                        <select id="modal-tts-voice-select" class="form-control"></select>
                    </div>
                </div>
                <!-- YENİ EKLENEN BÖLÜM SONU -->

                <div class="settings-group" style="grid-column: 1 / -1;">
                     <div class="panel-title" style="margin-bottom: 10px;">Aktif Stratejiler</div>
                    <div id="modal-strategy-toggles" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 5px;"></div>
                </div>
                <div class="settings-group" style="grid-column: 1 / -1;">
                    <div class="panel-title" style="margin-bottom: 10px;">Sinyal Geçmişi ve Analiz</div>
                    <div class="data-table-container" style="max-height: 300px;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Zaman</th>
                                    <th>Sembol</th>
                                    <th>Tip</th>
                                    <th>Fiyat</th>
                                    <th>TP</th>
                                    <th>SL</th>
                                    <th>Skor</th>
                                    <th>Katkı</th>
                                    <th>Boyut</th>
                                    <th>Durum</th>
                                    <th>Not</th>
                                </tr>
                            </thead>
                            <tbody id="modal-signals-body"></tbody>
                        </table>
                    </div>
                    <button id="modal-clear-signals-btn" class="btn btn-danger btn-sm" style="margin-top: 10px;">Tüm Sinyalleri Sil</button>
                    <div id="modal-stats-container" style="margin-top: 15px;"></div>
                </div>
            </div>
            <div class="settings-modal-footer">
                <button id="reset-all-settings-btn" class="btn btn-danger">AYARLARI SIFIRLA</button>
                <button id="save-settings-btn" class="btn btn-success">AYARLARI KAYDET</button>
            </div>
        </div>
    </div>
    <!-- YENİ LOG PANELİ (MODAL) -->
    <div id="log-modal-overlay">
        <div class="log-modal-content">
            <div class="log-modal-header">
                <span>SİSTEM LOGLARI & GÜNLÜK</span>
                <div>
                    <button id="export-logs-btn" class="btn btn-sm btn-success">Logları Dışa Aktar</button>
                    <button class="close-btn" id="close-log-modal-btn">&times;</button>
                </div>
            </div>
            <div class="log-modal-body">
                <pre id="log-output"></pre>
            </div>
        </div>
    </div>

   

    <!-- ŞEREF TABLOSU MODAL -->
    <div id="honor-modal-overlay" style="position:fixed; inset:0; background:rgba(0,0,0,0.7); display:none; z-index:2600; align-items:center; justify-content:center;">
      <div style="background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; width:90%; max-width:900px; max-height:90%; overflow:auto;">
        <div style="padding:10px; border-bottom:1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700; color:var(--primary)">Şeref Tablosu</div>
          <button id="close-honor-modal" class="btn btn-tiny">Kapat</button>
        </div>
        <div id="honor-modal-body" style="padding:12px;"></div>
      </div>
    </div>

<script>
    // Sinyal sesleri
    function playSignal(type) {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            if (type === 'buy') {
                oscillator.type = 'triangle'; oscillator.frequency.value = 1000;
            } else if (type === 'sell') {
                oscillator.type = 'square'; oscillator.frequency.value = 400;
            } else if (type === 'combat') {
                oscillator.type = 'sawtooth'; oscillator.frequency.value = 800; 
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);
                oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 1);
                return;
            }
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5);
        } catch (error) { console.log('Ses çalınamadı:', error); }
    }
    
    // Ses sentez motoruyla gelişmiş sesli bildirim fonksiyonu
    function playSoundAlert(type, priority = 1) {
        try {
            if (!window.audioContext) {
                window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const audioContext = window.audioContext;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();
            
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Bildirim türüne göre ses ayarları
            switch (type) {
                case 'success':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(880, audioContext.currentTime + 0.1);
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 1500;
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
                    
                case 'warning':
                case 'alert':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.15);
                    filterNode.type = 'bandpass';
                    filterNode.frequency.value = 500;
                    filterNode.Q.value = 3;
                    gainNode.gain.setValueAtTime(0.25 * Math.min(priority/2, 1), audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                    
                case 'error':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(196, audioContext.currentTime + 0.2);
                    filterNode.type = 'highpass';
                    filterNode.frequency.value = 150;
                    gainNode.gain.setValueAtTime(0.3 * Math.min(priority/2, 1), audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.6);
                    break;
                    
                case 'notification':
                default:
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 523.25; // C5
                    filterNode.type = 'lowpass';
                    filterNode.frequency.value = 800;
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
            }
            
            // Yüksek öncelikli bildirimlerde ikincil ses
            if (priority >= 4) {
                setTimeout(() => {
                    const osc2 = audioContext.createOscillator();
                    const gain2 = audioContext.createGain();
                    osc2.connect(gain2);
                    gain2.connect(audioContext.destination);
                    
                    osc2.type = 'sine';
                    osc2.frequency.value = 880;
                    gain2.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    
                    osc2.start(audioContext.currentTime);
                    osc2.stop(audioContext.currentTime + 0.15);
                }, 300);
            }
            
        } catch (error) {
            console.error('Ses sentezleme hatası:', error);
        }
    }

    /* =========================
       GÖRSELLEŞTİRME YÖNETİCİLERİ
       ========================= */
        class AdvancedNotificationCenter {
        constructor(app) {
            this.app = app;
            this.container = document.getElementById('notifications-container');
            this.notifications = [];
            this.maxHistory = 50; // Maximum number of notifications to keep in history
            this.maxVisibleNotifications = 10; // How many notifications to show at once
            this.groupSimilarTimeWindow = 5000; // Group similar notifications within 5 seconds
            
            // Load history from localStorage if available
            this.loadHistory();
            
            // Create notification categories
            this.categories = {
                system: { icon: '🔧', sound: false, color: 'var(--text-secondary)' },
                trade: { icon: '📊', sound: true, color: 'var(--primary)' },
                alert: { icon: '⚠️', sound: true, color: 'var(--neutral)' },
                success: { icon: '✅', sound: true, color: 'var(--positive)' },
                error: { icon: '❌', sound: true, color: 'var(--negative)' }
            };
            
            this.soundEnabled = true;
            this.priorityThreshold = 2; // Priority level for playing sounds (1-5)
            
            // Initialize UI
            this.initStyles();
            this.initNotificationPanel();
        }
        
        initStyles() {
            // Add custom styles for notifications if not already added
            if (!document.getElementById('notification-center-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-center-styles';
                style.textContent = `
                    /* Advanced Notification Center Styles */
                    .notifications { 
                        position: fixed; 
                        bottom: 15px; 
                        left: 15px;
                        z-index: 2000; 
                        width: 320px;
                        max-height: 80vh;
                        overflow-y: auto;
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                        padding-right: 8px;
                    }

                    .notification { 
                        background: rgba(22, 27, 34, 0.95);
                        backdrop-filter: blur(5px);
                        border: 1px solid var(--border-color); 
                        border-left-width: 4px; 
                        border-radius: 6px; 
                        padding: 10px 12px;
                        font-size: 12px;
                        box-shadow: 0 3px 10px rgba(0,0,0,0.3); 
                        animation: slide-in 0.3s ease-out;
                        transition: opacity 0.3s ease, transform 0.3s ease;
                        overflow: hidden;
                    }

                    .notification-control-panel {
                        background: var(--panel-bg);
                        border: 1px solid var(--border-color);
                        border-radius: 4px;
                        padding: 5px 8px;
                        margin-bottom: 8px;
                    }

                    .notification-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 5px;
                        font-size: 11px;
                        font-weight: bold;
                        color: var(--text-secondary);
                    }

                    .notification-header div {
                        display: flex;
                        gap: 5px;
                    }

                    .notification-icon {
                        font-size: 14px;
                        margin-right: 8px;
                        flex-shrink: 0;
                    }

                    .notification-priority {
                        font-size: 9px;
                        color: var(--primary);
                        letter-spacing: 1px;
                    }

                    .notification-close {
                        cursor: pointer;
                        font-size: 16px;
                        line-height: 1;
                        opacity: 0.7;
                        transition: opacity 0.2s;
                    }

                    .notification-close:hover {
                        opacity: 1;
                    }

                    .notification-content {
                        flex-grow: 1;
                        line-height: 1.4;
                        word-break: break-word;
                        position: relative;
                    }

                    .notification-time {
                        font-size: 9px;
                        color: var(--text-secondary);
                        margin-top: 2px;
                    }

                    .notification-count {
                        position: absolute;
                        top: -8px;
                        right: -5px;
                        background: var(--primary);
                        color: #000;
                        border-radius: 10px;
                        padding: 1px 6px;
                        font-size: 10px;
                        font-weight: bold;
                    }

                    /* Category-specific styles */
                    .notification.system { border-left-color: var(--text-secondary); }
                    .notification.trade { border-left-color: var(--primary); }
                    .notification.alert { border-left-color: var(--neutral); }
                    .notification.success { border-left-color: var(--positive); }
                    .notification.error { border-left-color: var(--negative); }
                    
                    .high-priority {
                        border-left-width: 6px !important;
                        animation: pulse-highlight 2s infinite;
                    }

                    /* Animation keyframes */
                    @keyframes slide-in {
                        from { transform: translateX(-100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    
                    @keyframes pulse-highlight {
                        0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
                        70% { box-shadow: 0 0 0 8px rgba(255, 255, 255, 0); }
                        100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
                    }
                    
                    /* Notification history modal */
                    #notification-history-modal .modal-body {
                        max-height: 400px;
                        overflow-y: auto;
                    }
                    
                    .notification-filters {
                        display: flex;
                        gap: 5px;
                        margin-bottom: 10px;
                        flex-wrap: wrap;
                    }
                    
                    .notification-filters .filter {
                        padding: 3px 8px;
                        border-radius: 12px;
                        background: var(--panel-bg);
                        border: 1px solid var(--border-color);
                        font-size: 11px;
                        cursor: pointer;
                    }
                    
                    .notification-filters .filter.active {
                        background: var(--primary);
                        color: #000;
                    }
                    
                    #notification-history-list {
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                    }
                    
                    /* Responsive adjustments */
                    @media screen and (max-width: 768px) {
                        .notifications {
                            width: 85%;
                            max-width: 320px;
                        }
                        
                        .notification {
                            padding: 8px 10px;
                            font-size: 11px;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
                initNotificationPanel() {
            // 1. Ana bildirim konteynerini oluştur
            if (!this.container) {
                this.container = document.createElement('div');
                this.container.id = 'notifications-container';
                this.container.className = 'notifications';
                document.body.appendChild(this.container);
            }
            
            // 2. Masaüstü için kontrol panelini oluştur
            const panel = document.createElement('div');
            panel.className = 'notification-control-panel';
            panel.innerHTML = `
                <div class="notification-header">
                    <span>BİLDİRİMLER</span>
                    <div>
                        <button id="notification-history-btn" class="btn btn-tiny" title="Bildirim Geçmişi">📋</button>
                        <button id="clear-notifications" class="btn btn-tiny" title="Bildirimleri Temizle">🗑️</button>
                        <button id="toggle-notification-sound" class="btn btn-tiny" title="Sesi Aç/Kapat">🔊</button>
                    </div>
                </div>
            `;
            this.container.appendChild(panel);

            // 3. Modal'ı oluştur
            this.createHistoryModal();
            
            // 4. Tüm butonlar için olay dinleyicilerini bağla (Hem masaüstü hem mobil)
            const showHistoryAction = () => this.showHistory();
            const clearAllAction = () => this.clearAll();
            const toggleSoundAction = () => {
                this.soundEnabled = !this.soundEnabled;
                const newIcon = this.soundEnabled ? '🔊' : '🔇';
                
                const soundBtnDesktop = document.getElementById('toggle-notification-sound');
                if (soundBtnDesktop) soundBtnDesktop.innerHTML = newIcon;

                const soundBtnMobile = document.getElementById('mobile-toggle-notification-sound');
                if (soundBtnMobile) soundBtnMobile.innerHTML = newIcon;

                this.notify('Bildirim sesleri ' + (this.soundEnabled ? 'açıldı' : 'kapatıldı'), 'system', 1);
            };

            // Masaüstü butonları
            document.getElementById('notification-history-btn').addEventListener('click', showHistoryAction);
            document.getElementById('clear-notifications').addEventListener('click', clearAllAction);
            document.getElementById('toggle-notification-sound').addEventListener('click', toggleSoundAction);
            
            // Mobil (dikey panel) butonları
            document.getElementById('mobile-notification-history-btn')?.addEventListener('click', showHistoryAction);
            document.getElementById('mobile-clear-notifications')?.addEventListener('click', clearAllAction);
            document.getElementById('mobile-toggle-notification-sound')?.addEventListener('click', toggleSoundAction);
        }
        
        /**
         * Create the notification history modal
         */
        createHistoryModal() {
            // Remove existing modal if any
            const existingModal = document.getElementById('notification-history-modal');
            if (existingModal) existingModal.remove();
            
            const modal = document.createElement('div');
            modal.id = 'notification-history-modal';
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Bildirim Geçmişi</h3>
                        <span class="close-modal">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="notification-filters">
                            <button class="filter active" data-filter="all">Tümü</button>
                            <button class="filter" data-filter="trade">İşlem</button>
                            <button class="filter" data-filter="alert">Uyarı</button>
                            <button class="filter" data-filter="success">Başarılı</button>
                            <button class="filter" data-filter="error">Hata</button>
                            <button class="filter" data-filter="system">Sistem</button>
                        </div>
                        <div id="notification-history-list"></div>
                    </div>
                    <div class="modal-footer">
                        <button id="clear-notifications-history" class="btn btn-danger">Geçmişi Temizle</button>
                    </div>
                </div>
            `;
            
            // Append to body but keep it hidden
            document.body.appendChild(modal);
            
            // Add event listeners
            const closeBtn = modal.querySelector('.close-modal');
            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });
            
            const filters = modal.querySelectorAll('.filter');
            filters.forEach(filter => {
                filter.addEventListener('click', (e) => {
                    filters.forEach(f => f.classList.remove('active'));
                    e.target.classList.add('active');
                    this.filterHistory(e.target.getAttribute('data-filter'));
                });
            });
            
            document.getElementById('clear-notifications-history').addEventListener('click', () => {
                this.clearHistory();
                this.notify('Bildirim geçmişi temizlendi', 'system', 1);
                modal.style.display = 'none';
            });
        }
        
        /**
         * Display a new notification
         * @param {string} message - The notification message
         * @param {string} category - Notification category (system, trade, alert, success, error)
         * @param {number} priority - Priority level (1-5)
         * @param {number} timeout - How long to display (ms)
         */
        notify(message, category = 'system', priority = 2, timeout = 5000) {
            if (!this.container) return;
            
            // Default category if invalid
            if (!this.categories[category]) category = 'system';
            
            // Check for similar recent notifications to avoid spam
            if (this.shouldGroupWithSimilar(message, category)) {
                return;
            }
            
            // Generate unique ID
            const notificationId = 'notify-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
            const timestamp = new Date();
            
            // Create notification element
            const notification = document.createElement('div');
            notification.id = notificationId;
            notification.className = `notification ${category}`;
            notification.setAttribute('data-id', notificationId);
            if (priority >= 4) notification.classList.add('high-priority');
            
            // Build notification content
            const catInfo = this.categories[category];
            notification.innerHTML = `
                <div class="notification-header">
                    <span class="notification-icon">${catInfo.icon}</span>
                    <span class="notification-priority">${'•'.repeat(priority)}</span>
                    <span class="notification-close">&times;</span>
                </div>
                <div class="notification-content">
                    ${message}
                    <div class="notification-time">${timestamp.toLocaleTimeString()}</div>
                </div>
            `;
            
            // Add to DOM
            const controlPanel = this.container.querySelector('.notification-control-panel');
            if (controlPanel && controlPanel.nextSibling) {
                this.container.insertBefore(notification, controlPanel.nextSibling);
            } else {
                this.container.appendChild(notification);
            }
            
            // Add to history
            this.addToHistory({
                id: notificationId,
                message,
                category,
                priority,
                timestamp
            });
            
            // Play sound for high priority notifications
            if (this.soundEnabled && priority >= this.priorityThreshold) {
                this.playNotificationSound(category, priority);
            }
            
            // Add close event
            const closeBtn = notification.querySelector('.notification-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    notification.remove();
                });
            }
            
            // Clean up old notifications
            this.cleanupOldNotifications();
            
            // Auto-remove after timeout
            setTimeout(() => {
                if (notification.parentNode) {
                    // Add fade-out animation
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(-100%)';
                    setTimeout(() => notification.remove(), 300);
                }
            }, timeout);
            
            return notification;
        }
        
        /**
         * Determine if a similar notification was recently shown
         */
        shouldGroupWithSimilar(message, category) {
            const now = Date.now();
            const similar = this.notifications.find(n => 
                n.category === category && 
                this.isSimilarMessage(n.message, message) && 
                (now - n.timestamp < this.groupSimilarTimeWindow)
            );
            
            if (similar) {
                // Update the existing notification instead of creating a new one
                const existingNotification = document.querySelector(`.notification.${category}[data-id="${similar.id}"]`);
                if (existingNotification) {
                    const countBadge = existingNotification.querySelector('.notification-count');
                    if (countBadge) {
                        countBadge.textContent = (parseInt(countBadge.textContent) || 1) + 1;
                    } else {
                        const contentDiv = existingNotification.querySelector('.notification-content');
                        if (contentDiv) {
                            contentDiv.innerHTML += `<span class="notification-count">2</span>`;
                        }
                    }
                    // Reset the timestamp for this notification
                    similar.timestamp = now;
                    return true;
                }
            }
            
            return false;
        }
        
        /**
         * Compare messages for similarity
         */
        isSimilarMessage(msg1, msg2) {
            // Basic similarity check - can be enhanced with more sophisticated comparison
            if (msg1 === msg2) return true;
            
            // Check for pattern-based similarities (e.g., only numbers differ)
            const normalized1 = msg1.replace(/\d+(\.\d+)?%?/g, 'X');
            const normalized2 = msg2.replace(/\d+(\.\d+)?%?/g, 'X');
            
            return normalized1 === normalized2;
        }
        
        /**
         * Add notification to history and save
         */
        addToHistory(notification) {
            // Add to history array
            this.notifications.unshift(notification);
            
            // Trim history if needed
            if (this.notifications.length > this.maxHistory) {
                this.notifications = this.notifications.slice(0, this.maxHistory);
            }
            
            // Save to localStorage
            this.saveHistory();
        }
        
        /**
         * Play sound notification
         */
        playNotificationSound(category, priority) {
            try {
                // Try to use app's built-in sound if available
                if (this.app.settings?.features?.enableTts && priority >= 3 && this.categories[category].sound) {
                    if (typeof this.app.playSignal === 'function') {
                        // Use existing signal player if available
                        if (category === 'error' || category === 'alert') {
                            this.app.playSignal('alert');
                        } else if (category === 'success' || category === 'trade') {
                            this.app.playSignal('combat');
                        }
                        return;
                    }
                }
                
                // Fallback to Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Different sounds for different categories
                switch(category) {
                    case 'success':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(1320, audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'alert':
                    case 'error':
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
                        oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.15);
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                    case 'trade':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(priority >= 4 ? 880 : 440, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    default:
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 440;
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                }
            } catch (error) {
                console.error('Bildirim sesi çalınamadı:', error);
            }
        }
        
        /**
         * Remove old notifications to maintain visibility limit
         */
        cleanupOldNotifications() {
            // Get all current notification elements (excluding control panel)
            const notifElements = Array.from(this.container.querySelectorAll('.notification')).filter(
                el => !el.classList.contains('notification-control-panel')
            );
            
            // If we're over the limit, remove oldest ones
            if (notifElements.length > this.maxVisibleNotifications) {
                const toRemove = notifElements.slice(this.maxVisibleNotifications);
                toRemove.forEach(el => el.remove());
            }
        }
        
        /**
         * Clear all visible notifications
         */
        clearAll() {
            const notifications = this.container.querySelectorAll('.notification');
            notifications.forEach(notification => {
                // Don't remove the control panel
                if (!notification.classList.contains('notification-control-panel')) {
                    notification.remove();
                }
            });
        }
        
        /**
         * Clear notification history and save
         */
        clearHistory() {
            this.notifications = [];
            this.saveHistory();
        }
        
        /**
         * Save notification history to localStorage
         */
        saveHistory() {
            try {
                localStorage.setItem('utc_notifications', JSON.stringify(this.notifications));
            } catch (e) {
                console.error('Failed to save notification history', e);
            }
        }
        
        /**
         * Load notification history from localStorage
         */
        loadHistory() {
            try {
                const saved = localStorage.getItem('utc_notifications');
                if (saved) {
                    this.notifications = JSON.parse(saved);
                    
                    // Convert date strings back to Date objects
                    this.notifications.forEach(n => {
                        if (typeof n.timestamp === 'string') {
                            n.timestamp = new Date(n.timestamp).getTime();
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to load notification history', e);
                this.notifications = [];
            }
        }
        
        /**
         * Show notification history in a modal
         */
        showHistory() {
            const modal = document.getElementById('notification-history-modal');
            if (!modal) return;
            
            // Update the history list
            this.filterHistory('all');
            
            // Show the modal
            modal.style.display = 'block';
        }
        
        /**
         * Filter history by category
         */
        filterHistory(filter = 'all') {
            const historyList = document.getElementById('notification-history-list');
            if (!historyList) return;
            
            // Clear current list
            historyList.innerHTML = '';
            
            // Filter notifications
            const filtered = filter === 'all' 
                ? [...this.notifications]
                : this.notifications.filter(n => n.category === filter);
            
            if (filtered.length === 0) {
                historyList.innerHTML = '<div class="empty-state">Bu kategoride bildirim bulunmuyor.</div>';
                return;
            }
            
            // Add notifications to history list
            filtered.forEach(n => {
                const item = document.createElement('div');
                item.className = `notification ${n.category}`;
                
                const catInfo = this.categories[n.category] || this.categories.system;
                const date = new Date(n.timestamp);
                const dateStr = date.toLocaleString();
                
                item.innerHTML = `
                    <div class="notification-header">
                        <span class="notification-icon">${catInfo.icon}</span>
                        <span class="notification-priority">${'•'.repeat(n.priority || 1)}</span>
                    </div>
                    <div class="notification-content">
                        ${n.message}
                        <div class="notification-time">${dateStr}</div>
                    </div>
                `;
                
                historyList.appendChild(item);
            });
        }
    }

    class ChartManager {
        constructor(chartContainerId) {
            this.chartContainer = document.getElementById(chartContainerId);
            if (!this.chartContainer) throw new Error("Chart container bulunamadı!");
            this.chart = null; this.series = {}; this.signalMarkers = [];
            this.bbandsSeries = null;
            this._initChart();
        }
        _initChart() {
            this.chart = LightweightCharts.createChart(this.chartContainer, this._getChartOptions());
            this.series.candles = this.chart.addCandlestickSeries(this._getCandlestickOptions());
            this.series.volume = this.chart.addHistogramSeries(this._getVolumeOptions());
            
            const lineStyle = { color: 'rgba(255, 255, 0, 0.6)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted };
            this.series.bbUpper = this.chart.addLineSeries(lineStyle);
            this.series.bbMiddle = this.chart.addLineSeries(lineStyle);
            this.series.bbLower = this.chart.addLineSeries(lineStyle);

            window.addEventListener('resize', () => { 
                if (this.chart && this.chartContainer.clientWidth > 0 && this.chartContainer.clientHeight > 0) {
                    this.chart.resize(this.chartContainer.clientWidth, this.chartContainer.clientHeight);
                }
            });

            // --- YENİ: Grafik görünümünü kaydetmek için olay dinleyici ---
            this.chart.timeScale().subscribeVisibleLogicalRangeChange(logicalRange => {
                if (logicalRange) {
                    localStorage.setItem('utc_chart_view', JSON.stringify(logicalRange));
                }
            });
        }

        // --- YENİ: Kaydedilmiş görünümü geri yükleme fonksiyonu ---
        restoreView() {
            const savedView = localStorage.getItem('utc_chart_view');
            if (savedView) {
                try {
                    const logicalRange = JSON.parse(savedView);
                    this.chart.timeScale().setVisibleLogicalRange(logicalRange);
                } catch (e) {
                    console.error("Kaydedilmiş grafik görünümü yüklenemedi:", e);
                    this.chart.timeScale().fitContent();
                }
            } else {
                this.chart.timeScale().fitContent();
            }
        }

        updateTheme() {
            if(!this.chart) return;
            this.chart.applyOptions(this._getChartOptions());
            this.series.candles.applyOptions(this._getCandlestickOptions());
            this.series.volume.applyOptions(this._getVolumeOptions());
            const lineStyle = { color: 'rgba(255, 255, 0, 0.6)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted };
            this.series.bbUpper.applyOptions(lineStyle);
            this.series.bbMiddle.applyOptions(lineStyle);
            this.series.bbLower.applyOptions(lineStyle);
        }
        setData(candles) {
            if (!this.series.candles) return;
            const candleData = candles.map(c => ({ time: c.time / 1000, open: c.open, high: c.high, low: c.low, close: c.close }));
            const volumeData = candles.map(c => ({ time: c.time / 1000, value: c.volume, color: c.close >= c.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' }));
            this.series.candles.setData(candleData);
            this.series.volume.setData(volumeData);
            
            // --- DÜZELTME: Veri yüklendikten sonra kaydedilmiş görünümü uygula ---
            this.restoreView();
        }

        drawBollingerBands(bbandsData) {
            if (!this.series.bbUpper || !bbandsData) return;
            const mapToChartTime = (d) => ({ time: d.time / 1000, value: d.value });
            this.series.bbUpper.setData(bbandsData.upper.map(mapToChartTime));
            this.series.bbMiddle.setData(bbandsData.middle.map(mapToChartTime));
            this.series.bbLower.setData(bbandsData.lower.map(mapToChartTime));
        }

        updateRealtime(kline) {
             if (!this.series.candles) return;
             const candle = { time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c) };
             const volume = { time: kline.t / 1000, value: parseFloat(kline.v), color: candle.close >= candle.open ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)' };
             this.series.candles.update(candle);
             this.series.volume.update(volume);
        }
                addSignalMarker(signal) {
            if (!this.series.candles) return;
            const styles = getComputedStyle(document.body);
            const isMobile = window.innerWidth <= 768;
            let text = '';

            if (isMobile) {
                text = `S:${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score}`;
            } else {
                text = `Skor: ${typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score} @ ${this._formatMarkerPrice(signal.price)}`;
                if (signal.recommendedSize) {
                    text += ` | ${signal.recommendedSize}`;
                }
            }

            const marker = {
                id: signal.id,
                time: signal.timestamp / 1000,
                position: signal.direction === 'buy' ? 'belowBar' : 'aboveBar',
                color: signal.direction === 'buy' ? styles.getPropertyValue('--positive').trim() : styles.getPropertyValue('--negative').trim(),
                shape: signal.direction === 'buy' ? 'arrowUp' : 'arrowDown',
                text: text
            };
            if (signal.status === 'pending') {
                marker.color = styles.getPropertyValue('--neutral').trim();
                marker.shape = 'circle';
            }
            
            // Mevcut sinyaller arasından aynı ID'ye sahip olanı kaldır (güncelleme için)
            this.signalMarkers = this.signalMarkers.filter(m => m.id !== signal.id);
            // Yeni sinyali listenin sonuna ekle
            this.signalMarkers.push(marker);

            // --- YENİ EKLENEN KISIM BAŞLANGICI ---
            // Sinyal işaretleyici listesinde 3'ten fazla sinyal varsa, en eskisini (listedeki ilk sinyali) sil.
            // Bu döngü, liste boyutu 3 olana kadar çalışır.
            while (this.signalMarkers.length > 3) {
                this.signalMarkers.shift(); // Dizinin başındaki (en eski) elemanı kaldırır.
            }
            // --- YENİ EKLENEN KISIM SONU ---

            // Grafiği, sadece son 3 sinyali içeren güncel liste ile güncelle.
            this.series.candles.setMarkers(this.signalMarkers);
        }
        clearMarkers() { if (!this.series.candles) return; this.signalMarkers = []; this.series.candles.setMarkers([]); }
        zoom(factor) {
            if (!this.chart) return;
            const timeScale = this.chart.timeScale();
            const currentLogicalRange = timeScale.getVisibleLogicalRange();
            if (!currentLogicalRange) return;
            const newLogicalRange = { from: currentLogicalRange.from * factor, to: currentLogicalRange.to * factor };
            timeScale.setVisibleLogicalRange(newLogicalRange);
        }
        zoomIn() { this.zoom(0.9); }
        zoomOut() { this.zoom(1.1); }
        resetZoom() { 
            if (this.chart) {
                this.chart.timeScale().fitContent(); 
                // --- YENİ: Sıfırlama sonrası hafızayı da temizle ---
                localStorage.removeItem('utc_chart_view');
            }
        }

        _getDecimalPlacesBasedOnPrice(price) { if(!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _formatMarkerPrice(price) { const d = this._getDecimalPlacesBasedOnPrice(price); return price.toFixed(d); }
        _getChartOptions() {
            const styles = getComputedStyle(document.body);
            return {
                width: this.chartContainer.clientWidth, height: this.chartContainer.clientHeight,
                layout: { backgroundColor: 'transparent', textColor: styles.getPropertyValue('--text-main').trim(), fontFamily: "'Roboto Mono', monospace" },
                grid: { vertLines: { color: styles.getPropertyValue('--border-color').trim() }, horzLines: { color: styles.getPropertyValue('--border-color').trim() } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: styles.getPropertyValue('--border-color').trim(), timeVisible: true, secondsVisible: false, rightOffset: 10 }
            };
        }
        _getCandlestickOptions() {
             const styles = getComputedStyle(document.body);
             return { 
                upColor: styles.getPropertyValue('--positive').trim(), downColor: styles.getPropertyValue('--negative').trim(),
                borderVisible: false, wickUpColor: styles.getPropertyValue('--positive').trim(), wickDownColor: styles.getPropertyValue('--negative').trim(),
                priceFormat: { type: 'price', precision: 6, minMove: 0.000001 }
             };
        }
        _getVolumeOptions() { return { priceFormat: { type: 'volume' }, priceScaleId: '', scaleMargins: { top: 0.8, bottom: 0 } }; }
    }


    class HeatmapManager {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            if (!this.canvas) throw new Error("Heatmap canvas bulunamadı!");
            this.ctx = this.canvas.getContext('2d');
            this._resizeCanvas();
            window.addEventListener('resize', () => this._resizeCanvas());
        }
        draw(orderBook, symbolPrice) {
            if (!orderBook.bids || !Array.isArray(orderBook.bids) || orderBook.bids.length === 0 || !orderBook.asks || !Array.isArray(orderBook.asks) || orderBook.asks.length === 0) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                return;
            }
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            const asks = orderBook.asks.slice().reverse(); const bids = orderBook.bids;
            const allLevels = [...bids, ...asks]; const maxQty = Math.max(...allLevels.map(l => l[1]));
            this._drawSection(asks, 'asks', maxQty, symbolPrice); this._drawSection(bids, 'bids', maxQty, symbolPrice);
        }
        updateTheme() { this._resizeCanvas(); }
        _drawSection(levels, type, maxQty, symbolPrice) {
            const styles = getComputedStyle(document.body);
            const baseColor = type === 'asks' ? styles.getPropertyValue('--negative').trim() : styles.getPropertyValue('--positive').trim();
            if (levels.length === 0) return;
            const heightPerLevel = (this.canvas.height / 2) / levels.length;
            const priceDecimals = this._getDecimalPlaces(symbolPrice);
            const labelSkipInterval = heightPerLevel < 12 ? Math.ceil(12 / heightPerLevel) : 1;
            levels.forEach((level, index) => {
                const [price, qty] = level;
                const intensity = Math.min(Math.sqrt(qty / maxQty), 1.0);
                this.ctx.fillStyle = this._hexToRgba(baseColor, intensity * 0.6 + 0.1);
                const y = type === 'asks' ? index * heightPerLevel : (this.canvas.height / 2) + (index * heightPerLevel);
                const barWidth = this.canvas.width * intensity;
                this.ctx.fillRect(0, y, barWidth, heightPerLevel);
                if (index % labelSkipInterval === 0) {
                    this.ctx.fillStyle = intensity > 0.5 ? '#FFFFFF' : styles.getPropertyValue('--text-secondary').trim();
                    this.ctx.font = '10px "Roboto Mono"'; this.ctx.textAlign = 'left';
                    this.ctx.fillText(`${(qty).toFixed(2)} @ ${price.toFixed(priceDecimals)}`, 10, y + heightPerLevel - 3);
                }
            });
        }
        _getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        _hexToRgba(hex, alpha) {
            if(!hex.startsWith('#')) return `rgba(120,120,120,${alpha})`;
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        _resizeCanvas() { 
            if(this.canvas.parentElement) {
                this.canvas.width = this.canvas.parentElement.clientWidth; 
                this.canvas.height = this.canvas.parentElement.clientHeight; 
            }
        }
    }

    /* =========================
       GELİŞMİŞ ÖZELLİK YÖNETİCİLERİ
       ========================= */

    // Çoklu Zaman Dilimi Yöneticisi (Multi-Timeframe Manager) - Gelişmiş
    class MultiTimeframeManager {
        constructor(bot) {
            this.bot = bot;
            this.data = {}; // { '1h': { candles: [], ema20: null }, '15m': { ... } }
            this.intervals = {};
            this.isInitialized = false;
        }

        async initialize(symbol, timeframes = []) {
            if (this.isInitialized) this.cleanup();
            this.isInitialized = true;
            this.bot.logToJournal(`MTF Manager başlatılıyor: ${timeframes.join(', ')}`);
            for (const tf of timeframes) {
                this.data[tf] = { candles: [], ema20: null };
                await this.fetchHistoricalData(symbol, tf);
                this.intervals[tf] = setInterval(() => this.fetchRealtimeData(symbol, tf), this._timeframeToMs(tf));
            }
        }

        async fetchHistoricalData(symbol, timeframe) {
            try {
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${timeframe}&limit=100`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API Hatası: ${response.statusText}`);
                const data = await response.json();
                this.data[timeframe].candles = data.map(d => ({ time: d[0], close: parseFloat(d[4]) }));
                this.calculateIndicators(timeframe);
                this.bot.logToJournal(`${timeframe} için ${this.data[timeframe].candles.length} mum yüklendi.`);
            } catch (error) {
                console.error(`MTF geçmiş veri hatası (${timeframe}):`, error);
            }
        }

        async fetchRealtimeData(symbol, timeframe) {
            try {
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${timeframe}&limit=2`;
                const response = await fetch(url);
                if (!response.ok) return;
                const data = await response.json();
                const newCandle = { time: data[0][0], close: parseFloat(data[0][4]) };
                const lastCandle = this.data[timeframe].candles[this.data[timeframe].candles.length - 1];
                if (lastCandle && lastCandle.time === newCandle.time) {
                    this.data[timeframe].candles[this.data[timeframe].candles.length - 1] = newCandle;
                } else {
                    this.data[timeframe].candles.push(newCandle);
                    if(this.data[timeframe].candles.length > 101) this.data[timeframe].candles.shift();
                }
                this.calculateIndicators(timeframe);
            } catch (error) {
                 console.error(`MTF anlık veri hatası (${timeframe}):`, error);
            }
        }
        
        calculateIndicators(timeframe) {
            const candles = this.data[timeframe]?.candles;
            if (!candles || candles.length < 20) return;
            const closes = candles.map(c => c.close);
            this.data[timeframe].ema20 = this._calculateEMA(closes, 20);
        }

        _calculateEMA(prices, period) {
            const k = 2 / (period + 1);
            let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < prices.length; i++) {
                ema = (prices[i] * k) + (ema * (1 - k));
            }
            return ema;
        }

        getTrend(timeframe) {
            const tfData = this.data[timeframe];
            if (!tfData || !tfData.ema20) return 'neutral';
            
            const price = this.bot.marketData.price;
            const ema = tfData.ema20;
            if (!price || !ema) return 'neutral';

            const diff = Math.abs(price - ema) / ema;
            
            // Belirsizlik durumu için eşik değer (%0.1)
            if (diff < 0.001) return 'neutral';
            
            return price > ema ? 'up' : 'down';
        }
        
        _timeframeToMs(tf) {
            const unit = tf.slice(-1);
            const val = parseInt(tf.slice(0, -1));
            if (unit === 'm') return val * 60 * 1000;
            if (unit === 'h') return val * 60 * 60 * 1000;
            return 60000;
        }

        cleanup() {
            this.isInitialized = false;
            Object.values(this.intervals).forEach(clearInterval);
            this.data = {};
            this.intervals = {};
            this.bot.logToJournal("MTF Manager durduruldu ve temizlendi.");
        }
    }

    // Sahte Emir Tespiti (Spoof Detector)
        class SpoofDetector {
        constructor(bot) {
            this.bot = bot;
            // --- YENİ OPTİMİZASYON DEĞİŞKENLERİ ---
            this.largeOrderThreshold = 10; // BTC cinsinden BAŞLANGIÇ eşiği
            this.pendingChecks = []; // Onay bekleyen tespitler
            this.confirmationStats = { confirmed: 0, rejected: 0 }; // İstatistikler
            // --- BİTTİ ---
            this.trackedOrders = new Map();
            this.NOTIFICATION_COOLDOWN_MS = 30000;
            this.lastNotificationTime = 0;
            this.PRICE_PROXIMITY_PERCENT = 0.0005;
        }

        trackOrderBook(orderBook) {
            const now = Date.now();
            const currentBids = new Map(orderBook.bids.map(([p, q]) => [p, q]));
            const currentAsks = new Map(orderBook.asks.map(([p, q]) => [p, q]));
            this._detectSpoofing(now, currentBids, currentAsks);
            this._trackNewLargeOrders(now, orderBook);
        }

        _detectSpoofing(now, currentBids, currentAsks) {
            const ordersToDelete = [];
            for (const [price, order] of this.trackedOrders.entries()) {
                if (now - order.timestamp > 15000) {
                    ordersToDelete.push(price);
                    continue;
                }
                const book = order.type === 'bid' ? currentBids : currentAsks;
                const priceTolerance = price * this.PRICE_PROXIMITY_PERCENT;
                let stillExists = false;
                for (const [currentPrice, currentQty] of book.entries()) {
                    if (Math.abs(currentPrice - price) <= priceTolerance) {
                        if (currentQty >= order.qty * 0.8) {
                            stillExists = true;
                            break;
                        }
                    }
                }
                if (!stillExists) {
                    if (now - this.lastNotificationTime > this.NOTIFICATION_COOLDOWN_MS) {
                        let notificationText = '';
                        let ttsKey = '';
                        let expectedDirection = '';

                        if (order.type === 'bid') {
                            notificationText = `Sahte Alış Emri Çekildi! Düşüş gelebilir. Dikkat et hacı abi.`;
                            ttsKey = 'spoofBidRemoved';
                            expectedDirection = 'down';
                        } else {
                            notificationText = `Sahte Satış Emri Çekildi! Alım gelebilir. Dikkat et komutanım.`;
                            ttsKey = 'spoofAskRemoved';
                            expectedDirection = 'up';
                        }

                        this.bot.showNotification(notificationText, 'warning');
                        this.bot.speak(this.bot.getRandomMessage(ttsKey));
                        
                        // --- YENİ: TESPİTİ ONAY İÇİN KAYDET ---
                        this.pendingChecks.push({
                            timestamp: now,
                            priceAtDetection: this.bot.marketData.price,
                            expectedDirection: expectedDirection,
                            checkAfterCandles: 5 // 5 mum sonra kontrol et
                        });
                        // --- BİTTİ ---

                        this.lastNotificationTime = now;
                    }
                    ordersToDelete.push(price);
                }
            }
            ordersToDelete.forEach(price => this.trackedOrders.delete(price));
        }

        _trackNewLargeOrders(now, orderBook) {
            const processBook = (book, type) => {
                for (const [price, qty] of book) {
                    const btcValue = (this.bot.currentSymbol === 'BTCUSDT') ?
                        qty :
                        (qty * price) / (this.bot.marketData.btcPrice || 70000);
                    if (btcValue > this.largeOrderThreshold) { // Değişken eşiği kullan
                        if (!this.trackedOrders.has(price)) {
                            this.trackedOrders.set(price, { qty, timestamp: now, type });
                        }
                    }
                }
            };
            processBook(orderBook.bids, 'bid');
            processBook(orderBook.asks, 'ask');
        }

        // --- YENİ OPTİMİZASYON FONKSİYONLARI ---
        checkConfirmations() {
            const candleCount = this.bot.candles.length;
            if (candleCount < 10) return;

            this.pendingChecks = this.pendingChecks.filter(check => {
                const candlesSince = candleCount - this.bot.candles.findIndex(c => c.time >= check.timestamp);
                if (candlesSince < check.checkAfterCandles) {
                    return true; // Henüz kontrol zamanı gelmedi, listede kalsın
                }

                const priceNow = this.bot.candles[candleCount - 1].close;
                const priceChange = (priceNow - check.priceAtDetection) / check.priceAtDetection;
                
                let confirmed = false;
                if (check.expectedDirection === 'up' && priceChange > 0.001) { // %0.1'den fazla yükseldiyse
                    confirmed = true;
                } else if (check.expectedDirection === 'down' && priceChange < -0.001) { // %0.1'den fazla düştüyse
                    confirmed = true;
                }

                if (confirmed) {
                    this.confirmationStats.confirmed++;
                } else {
                    this.confirmationStats.rejected++;
                }
                return false; // Kontrol edildi, listeden kaldır
            });
        }

        autoOptimizeThreshold() {
            const totalChecks = this.confirmationStats.confirmed + this.confirmationStats.rejected;
            if (totalChecks < 10) return; // Yeterli veri birikene kadar bekle

            const rejectionRate = this.confirmationStats.rejected / totalChecks;

            if (rejectionRate > 0.6) { // Reddedilme oranı %60'tan fazlaysa (çok hassas)
                this.largeOrderThreshold *= 1.10; // Eşiği %10 artır (daha az hassas yap)
                this.bot.logToJournal(`Spoof Detector optimizasyonu: Eşik ${this.largeOrderThreshold.toFixed(2)} BTC'ye yükseltildi.`);
            } else if (rejectionRate < 0.3) { // Reddedilme oranı %30'dan azsa (çok kaba olabilir)
                this.largeOrderThreshold *= 0.95; // Eşiği %5 düşür (daha hassas yap)
                this.bot.logToJournal(`Spoof Detector optimizasyonu: Eşik ${this.largeOrderThreshold.toFixed(2)} BTC'ye düşürüldü.`);
            }

            // Eşiğin mantıklı sınırlar içinde kalmasını sağla
            this.largeOrderThreshold = Math.max(5, Math.min(50, this.largeOrderThreshold));

            // İstatistikleri sıfırla ki yeni eşikle tekrar ölçüm yapılsın
            this.confirmationStats = { confirmed: 0, rejected: 0 };
        }
        // --- BİTTİ ---
    }



    // CUSUM Sapma Tespiti (CUSUM Drift Detector)
    class CUSUMDriftDetector {
        constructor() {
            this.K = 0.5;
            this.H = 3;
            this.Cp = 0;
            this.Cn = 0;
            this.dataPoints = 0; 
        }
        update(isWin) {
            this.dataPoints++;
            const Xn = isWin ? 1 : 0;
            this.Cp = Math.max(0, this.Cp + (Xn - this.K));
            this.Cn = Math.max(0, this.Cn + ((1 - Xn) - this.K));
            let driftDetected = false;
            if (this.Cp > this.H) { driftDetected = false; this.reset(); }
            if (this.Cn > this.H) { driftDetected = true; this.reset(); }
            return driftDetected;
        }
        reset() { this.Cp = 0; this.Cn = 0; this.dataPoints = 0; }
    }

    // Piyasa Seans Profilleri (Session Profiler)
    class SessionProfiler {
        constructor(bot) { // bot instance'ını alması için constructor'a eklendi
            this.bot = bot;
            this.sessions = {
                'asia': { start: 0, end: 8, name: 'Asya' },
                'europe': { start: 8, end: 13, name: 'Avrupa' },
                'america': { start: 13, end: 22, name: 'Amerika' },
                'overlap': { start: 13, end: 16, name: 'Avr-Ame Çakışması' },
                'transition': { start: 22, end: 24, name: 'Geçiş' }
            };
        }
        getCurrentSession() {
            const now = new Date();
            const utcHour = now.getUTCHours();
            if (utcHour >= this.sessions.overlap.start && utcHour < this.sessions.overlap.end) return this.sessions.overlap.name;
            else if (utcHour >= this.sessions.america.start && utcHour < this.sessions.america.end) return this.sessions.america.name;
            else if (utcHour >= this.sessions.europe.start && utcHour < this.sessions.europe.end) return this.sessions.europe.name;
            else if (utcHour >= this.sessions.asia.start && utcHour < this.sessions.asia.end) return this.sessions.asia.name;
            else return this.sessions.transition.name;
        }
    }

    // Risk Koruyucu (Risk Guardian - Kill Switch)
    class RiskGuardian {
        constructor(bot) {
            this.bot = bot;
            this.killSwitchActivated = false;
        }
        checkKillSwitch() {
            // DÜZELTME: Kill switch aktifse, yeni teklifleri anında temizle
            if (this.killSwitchActivated) {
                if (this.bot.confluenceEngine.proposals.length > 0) {
                    this.bot.confluenceEngine.proposals = [];
                }
                return true; // Aktifse başka kontrol yapma
            }

            if (!this.bot.settings.features.enableRiskGuardian) {
                this.killSwitchActivated = false; return false;
            }
            const totalSignals = this.bot.stats.total;
            const tpSignals = this.bot.stats.tp;
            const winRate = totalSignals > 0 ? (tpSignals / totalSignals) * 100 : 100; // Başlangıçta 100 kabul et
            
            // Güvenlik kontrolü - riskGuardian ayarları yoksa veya killSwitchWinRate tanımlı değilse varsayılan değeri kullan
            const riskSettings = this.bot.settings.riskGuardian || {};
            const drawdownWinRateThreshold = riskSettings.killSwitchWinRate || 35.0; // Default threshold
            
            if (totalSignals >= 10 && winRate < drawdownWinRateThreshold && !this.killSwitchActivated) {
                this.killSwitchActivated = true;
                this.bot.showNotification(`!!! ACİL DURDURMA !!! Kazanma oranı ${winRate.toFixed(1)}% (${drawdownWinRateThreshold}% altı). Sistem durduruldu.`, 'danger');
                this.bot.speak(`Uyarı! Acil durdurma Protokolü aktif edildi. Kazanma oranı eşiğin altında. Sistemi acilen kontrol edin.`);
                this.bot.stop();
                return true;
            }
            return false;
        }
    }

    /* =========================
       STRATEJİLER (YENİ VE MEVCUT)
       ========================= */
    class Strategy {
        constructor(bot, name) { 
            this.bot = bot; this.name = name; this.displayName = this._getDisplayName(name); 
            this.lastProposalTime = {};
            this.DEFAULT_PROPOSAL_COOLDOWN_MS = 10000;
            this._isLive = false;
        }
        setIsLive(status) { this._isLive = status; }
        propose(symbol, direction, reason, score) {
            try {
                if (!this.bot.strategyStats[this.name] || !this.bot.strategyStats[this.name].overall) {
                    const baseStat = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, shadowWins: 0, shadowLosses: 0, shadowProposals: 0, lastUpdate: Date.now() };
                    this.bot.strategyStats[this.name] = {
                        overall: { ...baseStat },
                        trend: { ...baseStat },
                        range: { ...baseStat },
                        transition: { ...baseStat }
                    };
                }
                const stratStats = this.bot.strategyStats[this.name];

                stratStats.overall.proposals = (stratStats.overall.proposals || 0) + 1;
                stratStats.overall.lastUpdate = Date.now();
                this.bot.saveStrategyStats();

                if (!this._isLive) {
                    this.bot.recordShadowProposal(this.name, direction, reason, score);
                    return;
                }
                if (this.bot.settings.features.enableRiskGuardian && this.bot.riskGuardian.killSwitchActivated) return;

                const now = Date.now();
                const key = `${symbol}-${direction}`;
                const cooldown = (this.DEFAULT_PROPOSAL_COOLDOWN_MS ?? 10000);
                if (now - (this.lastProposalTime[key] || 0) < cooldown) return;
                this.bot.confluenceEngine.propose(this.name, direction, reason, score);
                this.lastProposalTime[key] = now;
            } catch (error) {
                console.error(`[${this.name}] Propose Error:`, error);
            }
        }

        _getDisplayName(name) { return name.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); }
        analyzeOrderBook(orderBook) {}
        processTrade(trade) {}
        periodicAnalyze() {}
    }

    class WallBounceStrategy extends Strategy {
        constructor(bot) { super(bot, 'wallBounce'); this.DISTANCE_THRESHOLD_PERCENT = 0.05 / 100; }
        analyzeOrderBook(orderBook) {
            const currentPrice = this.bot.marketData.price; if (!currentPrice) return;
            const btcPrice = this.bot.marketData.btcPrice || 70000;
            const wallQuantityThreshold = (this.bot.settings.params.wallBtc * btcPrice) / currentPrice;
            for (const [price, qty] of orderBook.asks) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (price - currentPrice) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'sell', `Satış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
            for (const [price, qty] of orderBook.bids) { 
                if (qty > wallQuantityThreshold) { 
                    const distance = (currentPrice - price) / currentPrice; 
                    if (distance > 0 && distance < this.DISTANCE_THRESHOLD_PERCENT) { 
                        this.propose(this.bot.currentSymbol, 'buy', `Alış Duvarı ${price.toFixed(this.bot.getDecimalPlaces(price))}`, 3); return; 
                    } 
                } 
            }
        }
    }
    class VelocityScalpingStrategy extends Strategy {
        constructor(bot) { super(bot, 'velocityScalping'); this.pricePoints = []; this.VELOCITY_WINDOW_MS = 2000; this.MIN_POINTS = 20; this.VELOCITY_THRESHOLD_PERCENT = 0.10 / 100; }
        processTrade(trade) {
            const now = Date.now(); 
            this.pricePoints.push({ time: now, price: trade.price }); 
            this.pricePoints = this.pricePoints.filter(p => now - p.time < this.VELOCITY_WINDOW_MS); 
            if (this.pricePoints.length < this.MIN_POINTS) return;
            const firstPoint = this.pricePoints[0]; const lastPoint = this.pricePoints[this.pricePoints.length - 1]; 
            const priceChange = (lastPoint.price - firstPoint.price) / firstPoint.price;
            if (priceChange > this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'buy', `Fiyat Hızı: +${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            } else if (priceChange < -this.VELOCITY_THRESHOLD_PERCENT) { 
                this.propose(this.bot.currentSymbol, 'sell', `Fiyat Hızı: ${(priceChange * 100).toFixed(2)}%`, 4); this.pricePoints = []; 
            }
        }
    }
    class RsiDivergenceStrategy extends Strategy {
        constructor(bot) { super(bot, 'rsiDivergence'); }
        periodicAnalyze() {
            const candles = this.bot.candles; const rsiValues = this.bot.indicators.rsi; const lookback = this.bot.settings.params.rsiPeriod;
            if (!rsiValues || rsiValues.length < lookback || !candles || candles.length < lookback) return;
            const recentRsi = rsiValues.slice(-lookback);
            const lastCandle = candles[candles.length - 1]; 
            const prevCandle = candles[candles.length - lookback]; 
            const lastRsi = recentRsi[recentRsi.length - 1]; 
            const prevRsi = recentRsi[0];
            if (!lastCandle || !prevCandle || !isFinite(lastRsi) || !isFinite(prevRsi)) return;
            if (lastCandle.high > prevCandle.high && lastRsi < prevRsi) { 
                this.propose(this.bot.currentSymbol, 'sell', 'RSI Ayı Uyuşmazlığı', 5); 
            }
            if (lastCandle.low < prevCandle.low && lastRsi > prevRsi) { 
                this.propose(this.bot.currentSymbol, 'buy', 'RSI Boğa Uyuşmazlığı', 5); 
            }
        }
    }
    class OrderFlowMomentumStrategy extends Strategy {
        constructor(bot) { super(bot, 'orderFlowMomentum'); this.trades = []; this.WINDOW_MS = 5000; }
        processTrade(trade) {
            const now = Date.now(); 
            this.trades.push(trade); 
            this.trades = this.trades.filter(t => now - t.timestamp < this.WINDOW_MS); 
            if (this.trades.length < 50) return;
            const buys = this.trades.filter(t => !t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0); 
            const sells = this.trades.filter(t => t.isBuyerMaker).reduce((sum, t) => sum + t.quantity, 0);
            const total = buys + sells; if (total === 0) return; 
            if (buys / total > 0.7) { this.propose(this.bot.currentSymbol, 'buy', `Alıcı Akışı: %${(buys / total * 100).toFixed(0)}`, 4); this.trades = []; }
            else if (sells / total > 0.7) { this.propose(this.bot.currentSymbol, 'sell', `Satıcı Akışı: %${(sells / total * 100).toFixed(0)}`, 4); this.trades = []; }
        }
    }
    class LiquidityGapsStrategy extends Strategy {
        constructor(bot) { super(bot, 'liquidityGaps'); this.GAP_THRESHOLD_PERCENT = 0.1 / 100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.asks || orderBook.asks.length === 0 || !orderBook.bids || orderBook.bids.length === 0) return;
            for (let i = 0; i < orderBook.asks.length - 1; i++) { 
                const gap = orderBook.asks[i + 1][0] - orderBook.asks[i][0]; 
                if ((gap / orderBook.asks[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'buy', `Likidite Boşluğu ${orderBook.asks[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.asks[i][0]))}`, 3); return; 
                } 
            }
            for (let i = 0; i < orderBook.bids.length - 1; i++) { 
                const gap = orderBook.bids[i][0] - orderBook.bids[i + 1][0]; 
                if ((gap / orderBook.bids[i][0]) > this.GAP_THRESHOLD_PERCENT) { 
                    this.propose(this.bot.currentSymbol, 'sell', `Likidite Boşluğu ${orderBook.bids[i][0].toFixed(this.bot.getDecimalPlaces(orderBook.bids[i][0]))}`, 3); return; 
                } 
            }
        }
    }
    class BreakoutPatternStrategy extends Strategy {
        constructor(bot) { super(bot, 'breakoutPattern'); this.LOOKBACK = 30; this.VOL_SPIKE = 1.4; this.BREAK_PCT = 0.03/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK + 1) return;
            const recent = c.slice(-this.LOOKBACK-1);
            const highs = recent.map(x=>x.high), lows = recent.map(x=>x.low), vols = recent.map(x=>x.volume);
            const last = recent[recent.length-1]; 
            const maxH = Math.max(...highs.slice(0, -1)); const minL = Math.min(...lows.slice(0, -1));
            const volSma = vols.reduce((a,b)=>a+b,0) / (vols.length-1);
            if (last.close > maxH * (1 + this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'buy', 'Aralık Üstü Hacimli Kırılım', 4);
            } else if (last.close < minL * (1 - this.BREAK_PCT) && last.volume > volSma * this.VOL_SPIKE) {
                this.propose(this.bot.currentSymbol, 'sell', 'Aralık Altı Hacimli Kırılım', 4);
            }
        }
    }
    class SupportResistanceStrategy extends Strategy {
        constructor(bot) { super(bot, 'supportResistance'); this.LOOKBACK = 60; this.THRESH = 0.15/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            const last = slice[slice.length-1];
            const maxH = Math.max(...slice.map(x=>x.high)); const minL = Math.min(...slice.map(x=>x.low));
            const distTop = (maxH - last.close)/last.close; const distBot = (last.close - minL)/last.close;
            if (distTop >= 0 && distTop < this.THRESH && last.close < last.open) {
                this.propose(this.bot.currentSymbol, 'sell', 'Direnç Bölgesi Reddi', 3);
            }
            if (distBot >= 0 && distBot < this.THRESH && last.close > last.open) {
                this.propose(this.bot.currentSymbol, 'buy', 'Destek Bölgesi Tepkisi', 3);
            }
        }
    }
    class FibonacciRetracementStrategy extends Strategy {
        constructor(bot) { super(bot, 'fibonacciRetracement'); this.LOOKBACK = 120; this.TOL = 0.2/100; this.levels = [0.382, 0.5, 0.618]; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK);
            let high = -Infinity, low = Infinity, hT=0, lT=0;
            slice.forEach(k => { if(k.high > high){high=k.high; hT=k.time;} if(k.low < low){low=k.low; lT=k.time;} });
            if (!isFinite(high) || !isFinite(low) || high===low) return;
            const last = slice[slice.length-1];
            if (hT > lT) {
                const retr = (high - last.close) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'buy', `Fibo ${Math.round(L*100)}% Bölgesi`, 3); break; }
                }
            } else {
                const retr = (last.close - low) / (high - low);
                for (const L of this.levels) {
                    if (Math.abs(retr - L) < this.TOL) { this.propose(this.bot.currentSymbol, 'sell', `Fibo ${Math.round(L*100)}% Bölgesi`, 3); break; }
                }
            }
        }
    }
    class VolumeProfileStrategy extends Strategy {
        constructor(bot) { super(bot, 'volumeProfile'); this.PERIOD = 20; this.SPIKE = 2.0; this.CLOSE_POS = 0.7; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < this.PERIOD + 1) return;
            const last = c[c.length-1];
            const vols = c.slice(-this.PERIOD-1, -1).map(x=>x.volume);
            const volSma = vols.reduce((a,b)=>a+b,0)/vols.length;
            if (last.volume > volSma * this.SPIKE && (last.close - last.low) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'buy', 'Hacim Spike - Üst Kapanış', 3);
            } else if (last.volume > volSma * this.SPIKE && (last.high - last.close) / Math.max(1e-8,(last.high - last.low)) > this.CLOSE_POS) {
                this.propose(this.bot.currentSymbol, 'sell', 'Hacim Spike - Alt Kapanış', 3);
            }
        }
    }
    class SmartMoneyConceptsStrategy extends Strategy {
        constructor(bot) { super(bot, 'smartMoneyConcepts'); this.GAP_MIN_PCT = 0.05/100; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 3) return;
            const a = c[c.length-3], b = c[c.length-2], d = c[c.length-1];
            if ((d.low - b.high > 0) && (b.low - a.high > 0) && ((d.low - a.high)/Math.max(1e-8, d.low) > this.GAP_MIN_PCT)) {
                 this.propose(this.bot.currentSymbol, 'buy', 'Bullish FVG (IMB)', 4);
            }
            if ((a.low - b.high > 0) && (b.low - d.high > 0) && ((a.low - d.high)/Math.max(1e-8, d.high) > this.GAP_MIN_PCT)) {
                this.propose(this.bot.currentSymbol, 'sell', 'Bearish FVG (IMB)', 4);
            }
        }
    }
    class DivergenceDetectionStrategy extends Strategy {
        constructor(bot) { super(bot, 'divergenceDetection'); this.LOOKBACK = 40; this.SWING_PERIOD = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; const rsi = this.bot.indicators.rsi; 
            if (!rsi || c.length < this.LOOKBACK || rsi.length < this.LOOKBACK) return;
            const slice = c.slice(-this.LOOKBACK), r = rsi.slice(-this.LOOKBACK);
            const pivLows = []; const pivHighs = [];
            for (let i = this.SWING_PERIOD; i < slice.length - this.SWING_PERIOD; i++) {
                const isPivotLow = slice[i].low < Math.min(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.low)) && 
                                   slice[i].low < Math.min(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.low));
                const isPivotHigh = slice[i].high > Math.max(...slice.slice(i-this.SWING_PERIOD, i).map(x=>x.high)) && 
                                    slice[i].high > Math.max(...slice.slice(i+1, i+1+this.SWING_PERIOD).map(x=>x.high));
                if (isPivotLow) pivLows.push(i);
                if (isPivotHigh) pivHighs.push(i);
            }
            if (pivLows.length >= 2) {
                const i1 = pivLows[pivLows.length-2], i2 = pivLows[pivLows.length-1];
                if (slice[i2].low < slice[i1].low && r[i2] > r[i1]) {
                    this.propose(this.bot.currentSymbol, 'buy', 'Boğa Sapması (RSI)', 5);
                }
            }
            if (pivHighs.length >= 2) {
                const i1 = pivHighs[pivHighs.length-2], i2 = pivHighs[pivHighs.length-1];
                if (slice[i2].high > slice[i1].high && r[i2] < r[i1]) {
                    this.propose(this.bot.currentSymbol, 'sell', 'Ayı Sapması (RSI)', 5);
                }
            }
        }
    }
    class MarketStructureStrategy extends Strategy {
        constructor(bot) { super(bot, 'marketStructure'); this.SWING = 3; }
        periodicAnalyze() {
            const c = this.bot.candles; if (c.length < 2*this.SWING+5) return;
            const pivotHighs = [], pivotLows = [];
            for (let i = this.SWING; i < c.length - this.SWING; i++) {
                if (c[i].high > Math.max(...c.slice(i-this.SWING, i).map(x=>x.high)) && c[i].high > Math.max(...c.slice(i+1, i+1+this.SWING).map(x=>x.high))) pivotHighs.push(i);
                if (c[i].low < Math.min(...c.slice(i-this.SWING, i).map(x=>x.low)) && c[i].low < Math.min(...c.slice(i+1, i+1+this.SWING).map(x=>x.low))) pivotLows.push(i);
            }
            const last = c[c.length-1];
            if (pivotHighs.length) {
                const ph = c[pivotHighs[pivotHighs.length-1]].high;
                if (last.close > ph) this.propose(this.bot.currentSymbol, 'buy', 'Yapı Kırılımı (BOS Up)', 4);
            }
            if (pivotLows.length) {
                const pl = c[pivotLows[pivotLows.length-1]].low;
                if (last.close < pl) this.propose(this.bot.currentSymbol, 'sell', 'Yapı Kırılımı (BOS Down)', 4);
            }
        }
    }
    class InstitutionalOrderFlowStrategy extends Strategy {
        constructor(bot) { super(bot, 'institutionalOrderFlow'); this.TOP_N = 5; this.IMB_THRESHOLD = 2.0; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const topB = orderBook.bids.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            const topA = orderBook.asks.slice(0, this.TOP_N).reduce((s,[,q])=>s+q,0);
            if (topB / Math.max(1e-8, topA) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'buy', 'Orderbook İmbalansı (Bid Ağırlık)', 3);
            } else if (topA / Math.max(1e-8, topB) > this.IMB_THRESHOLD) {
                this.propose(this.bot.currentSymbol, 'sell', 'Orderbook İmbalansı (Ask Ağırlık)', 3);
            }
        }
    }
    class MicroSpreadArbitrageStrategy extends Strategy {
        constructor(bot) { super(bot, 'microSpreadArbitrage'); this.SPREAD_PCT = 0.08/100; }
        analyzeOrderBook(orderBook) {
            if (!orderBook.bids || orderBook.bids.length === 0 || !orderBook.asks || orderBook.asks.length === 0) return;
            const bestBid = orderBook.bids[0][0], bestAsk = orderBook.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            if (spreadPct > this.SPREAD_PCT) {
                const current = this.bot.marketData.price || mid;
                if (current < mid) this.propose(this.bot.currentSymbol, 'buy', 'Geniş Spread - Mean Reversion', 2);
                else this.propose(this.bot.currentSymbol, 'sell', 'Geniş Spread - Mean Reversion', 2);
            }
        }
    }
    class VWAPReversionStrategy extends Strategy {
        constructor(bot) { super(bot, 'vwapReversion'); this.MULT = 1.0; }
        periodicAnalyze() {
            const price = this.bot.marketData.price, vwap = this.bot.indicators.vwap, atr = this.bot.indicators.atr;
            if (!price || !vwap || !atr) return;
            const dev = atr / price; 
            const diffPct = (price - vwap) / vwap;
            if (diffPct > this.MULT * dev) this.propose(this.bot.currentSymbol, 'sell', 'VWAP Üstü Aşırı Sapma', 3);
            if (diffPct < -this.MULT * dev) { this.propose(this.bot.currentSymbol, 'buy', 'VWAP Altı Aşırı Sapma', 3); }
        }
    }
    class SuperTrendStrategy extends Strategy {
        constructor(bot) { super(bot, 'superTrend'); this.MULT = 3.0; this.PERIOD = 14; }
        periodicAnalyze() {
            const c = this.bot.candles; const atr = this.bot.indicators.atr;
            if (!atr || c.length < 2) return;
            const last = c[c.length-1];
            const m = (last.high + last.low) / 2;
            const upper = m + this.MULT * atr, lower = m - this.MULT * atr;
            if (last.close > upper) this.propose(this.bot.currentSymbol, 'buy', 'ATR Kanal Üstü Kırılım (SuperTrend)', 4);
            else if (last.close < lower) { this.propose(this.bot.currentSymbol, 'sell', 'ATR Kanal Altı Kırılım (SuperTrend)', 4); }
        }
    }

    // YENİ STRATEJİLER
    class VolatilityBreakoutStrategy extends Strategy {
        constructor(bot) { 
            super(bot, 'volatilityBreakout'); 
            this.SQUEEZE_LOOKBACK = 20;
            this.SQUEEZE_MULT = 1.0; // ATR'ye göre sıkışma tespiti için çarpan
            this.BREAKOUT_VOL_MULT = 1.5; // Kırılım anındaki hacim artışı
        }
        periodicAnalyze() {
            const { bbands, atr, volSma20 } = this.bot.indicators;
            const c = this.bot.candles;
            if (!bbands || !atr || !volSma20 || c.length < this.SQUEEZE_LOOKBACK || !bbands.upper || bbands.upper.length === 0) return;

            const lastBandUpper = bbands.upper[bbands.upper.length-1];
            const lastBandMiddle = bbands.middle[bbands.middle.length-1];
            const lastBandLower = bbands.lower[bbands.lower.length-1];

            if (!lastBandUpper || !lastBandMiddle || !lastBandLower || lastBandMiddle.value === 0) return;

            const bandwidth = (lastBandUpper.value - lastBandLower.value) / lastBandMiddle.value;
            
            const isSqueeze = bandwidth < (atr * this.SQUEEZE_MULT / (c[c.length-1]?.close || 1));
            if(!isSqueeze) return;

            const lastCandle = c[c.length-1];
            if (!lastCandle) return;

            if (lastCandle.close > lastBandUpper.value && lastCandle.volume > volSma20 * this.BREAKOUT_VOL_MULT) {
                this.propose(this.bot.currentSymbol, 'buy', 'Volatilite Sıkışma Kırılımı (Yukarı)', 5);
            } else if (lastCandle.close < lastBandLower.value && lastCandle.volume > volSma20 * this.BREAKOUT_VOL_MULT) {
                this.propose(this.bot.currentSymbol, 'sell', 'Volatilite Sıkışma Kırılımı (Aşağı)', 5);
            }
        }
    }

    class CandleCharacterStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'candleCharacter');
            this.MIN_BODY_TO_WICK_RATIO = 0.6; // Gövde / Toplam Mum Boyu oranı
            this.ANALYSIS_WINDOW_PERCENT = 0.2; // Mumun son %20'sinde çalışır
        }
        periodicAnalyze() {
            if (this.bot.candles.length < 1) return;
            const candle = this.bot.candles[this.bot.candles.length-1];
            const timeframeMs = this.bot._timeframeToMs(this.bot.currentTimeframe);
            const candleAge = Date.now() - candle.time;
            
            // Sadece mumun sonlarına doğru çalış
            if (candleAge < timeframeMs * (1 - this.ANALYSIS_WINDOW_PERCENT)) return;

            const { open, high, low, close } = candle;
            const bodySize = Math.abs(close - open);
            const totalSize = high - low;
            if (totalSize === 0) return; // Doji veya veri hatası

            const bodyRatio = bodySize / totalSize;
            if(bodyRatio < this.MIN_BODY_TO_WICK_RATIO) return; // Güçsüz gövde, kararsızlık

            if (close > open) { // Yeşil mum
                const upperWick = high - close;
                // Eğer üst fitil toplam mum boyutunun %20'sinden azsa, gövde güçlüdür
                if (upperWick / totalSize < 0.2) { 
                    this.propose(this.bot.currentSymbol, 'buy', 'Güçlü Alıcı Mumu', 4);
                }
            } else { // Kırmızı mum
                const lowerWick = close - low;
                // Eğer alt fitil toplam mum boyutunu %20'sinden azsa, gövde güçlüdür
                if(lowerWick / totalSize < 0.2) { 
                    this.propose(this.bot.currentSymbol, 'sell', 'Güçlü Satıcı Mumu', 4);
                }
            }
        }
    }

     class FundingRateReversalStrategy extends Strategy {
        constructor(bot) {
            super(bot, 'fundingRateReversal');
            this.fundingRate = 0;
            this.openInterest = 0;
            this.lastFetchTime = 0;
            this.FETCH_INTERVAL_MS = 60 * 1000; // 1 dakikada bir veri çek
            this.EXTREME_FUNDING_THRESHOLD = 0.001; // %0.1 fonlama oranı eşiği
        }

        async periodicAnalyze() {
            const now = Date.now();
            if (now - this.lastFetchTime > this.FETCH_INTERVAL_MS) {
                this.lastFetchTime = now;
                try {
                    const response = await fetch(`https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${this.bot.currentSymbol}`);
                    if (!response.ok) {
                        console.error(`Funding Rate/Open Interest API Hatası: ${response.statusText}`);
                        return;
                    }
                    const data = await response.json();
                    this.fundingRate = parseFloat(data.lastFundingRate);
                    this.openInterest = parseFloat(data.openInterest) || 0; 

                } catch (e) { 
                    console.error("Fonlama Oranı/Açık Faiz verisi çekilemedi:", e); 
                    return;
                }
            }

            const currentPrice = this.bot.marketData.price;
            if (!currentPrice || !isFinite(this.fundingRate) || this.fundingRate === 0 || this.bot.candles.length < 2) return;

            if (this.fundingRate > this.EXTREME_FUNDING_THRESHOLD) {
                if (currentPrice < this.bot.candles[this.bot.candles.length - 2]?.close) { 
                     this.propose(this.bot.currentSymbol, 'sell', `Aşırı Pozitif Fonlama & Fiyat Düşüşü (${(this.fundingRate*100).toFixed(3)}%)`, 4);
                }
            } else if (this.fundingRate < -this.EXTREME_FUNDING_THRESHOLD) {
                 if (currentPrice > this.bot.candles[this.bot.candles.length - 2]?.close) { 
                    this.propose(this.bot.currentSymbol, 'buy', `Aşırı Negatif Fonlama & Fiyat Yükselişi (${(this.fundingRate*100).toFixed(3)}%)`, 4);
                }
            }
        }
    }


    /* =========================
       UYUM MOTORU (CONFLUENCE)
       ========================= */
    class ConfluenceEngine {
        constructor(bot) { 
            this.bot = bot; 
            this.proposals = []; 
            this.lastSignalTime = 0; 
            this.lastSignalTimeByDirection = { buy: 0, sell: 0 };
            this.lastDirection = null;
            this.buyScore = 0;
            this.sellScore = 0;
        }
        propose(strategy, direction, reason, score) {
            const now = Date.now();
            this.proposals = this.proposals.filter(p => !(p.strategy === strategy && p.direction === direction));
            this.proposals.push({ strategy, direction, reason, score, timestamp: now });
            this.checkConfluence();
        }
        _computeDirectional(direction) {
            const now = Date.now();
            const decaySec = this.bot.settings.optimization.timeDecaySec || 3;
            const groupSums = { trending: 0, meanReversion: 0, neutral: 0 };
            const used = [];
            const groupsUsed = new Set();
            const activeProposals = this.proposals.filter(p => {
                const strategyInstance = this.bot.strategies[p.strategy];
                return strategyInstance && strategyInstance._isLive && p.direction === direction;
            });

            for (const p of activeProposals) {
                const w = this.bot.getStrategyWeight(p.strategy);
                const ageSec = (now - p.timestamp)/1000;
                const decay = Math.exp(-ageSec / decaySec);
                // DÜZELTME: NaN kontrolü eklendi
                const eff = isNaN(p.score * w * decay) ? 0 : p.score * w * decay;
                const grp = this.bot.getStrategyGroup(p.strategy);
                groupsUsed.add(grp);
                groupSums[grp] = (groupSums[grp] || 0) + eff;
                used.push({ strategy: p.strategy, baseScore: p.score, weight: w, decay, effScore: eff });
            }
            const score = Object.values(groupSums).reduce((sum, val) => sum + val, 0); 
            return { score, contributors: used, groupSums, groupsCount: groupsUsed.size, contributorsCount: used.length };
        }
       
        checkConfluence() {
            const now = Date.now();
            const settings = this.bot.settings;
            const cd = settings.cooldowns || {};
            const proposalTimeout = cd.proposalTimeoutMs ?? 3000;
            const signalCooldown = cd.signalMs ?? 15000;
            const sameDirCooldown = cd.sameDirectionMs ?? 30000;
            const oppCooldown = cd.oppositeDirectionMs ?? 20000;
            const reverseHys = cd.reverseHysteresisPoints ?? 2;
            const dirMargin = settings.optimization.dirMargin ?? 0.5;
            const minThreshold = this.bot.getEffectiveThreshold();

            if (now - this.lastSignalTime < signalCooldown) return;
            this.proposals = this.proposals.filter(p => now - p.timestamp < proposalTimeout);

            const buy = this._computeDirectional('buy');
            const sell = this._computeDirectional('sell');

            let buyScoreAdj = buy.score;
            let sellScoreAdj = sell.score;

            if (settings.features.enableMtfConfirm) {
                const mtfTrend = this.bot.multiTimeframeManager.getTrend(settings.features.mtfTimeframe);
                if (mtfTrend === 'down') buyScoreAdj *= 0.6;
                if (mtfTrend === 'up') sellScoreAdj *= 0.6;
            }

            const buyPenalty = settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('buy') : 0;
            const sellPenalty = settings.optimization.gating.enabled ? this.bot.marketGatingPenalty('sell') : 0;
            buyScoreAdj -= buyPenalty;
            sellScoreAdj -= sellPenalty;

            const q = settings.optimization.signalQuality || { minContributors: 1, minGroups: 1 };
            const buyOk = (buy.contributorsCount >= q.minContributors) && (buy.groupsCount >= q.minGroups);
            const sellOk = (sell.contributorsCount >= q.minContributors) && (sell.groupsCount >= q.minGroups);

            buyScoreAdj = buyOk ? buyScoreAdj : -Infinity;
            sellScoreAdj = sellOk ? sellScoreAdj : -Infinity;

            this.buyScore = buyScoreAdj;
            this.sellScore = sellScoreAdj;

            if (buyScoreAdj >= minThreshold && (buyScoreAdj > sellScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.buy < sameDirCooldown) return;
                if (this.lastDirection === 'sell' && (now - this.lastSignalTime) < oppCooldown) {
                    if (buyScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('buy', buy.contributors, buyScoreAdj);
            } else if (sellScoreAdj >= minThreshold && (sellScoreAdj > buyScoreAdj + dirMargin)) {
                if (now - this.lastSignalTimeByDirection.sell < sameDirCooldown) return;
                if (this.lastDirection === 'buy' && (now - this.lastSignalTime) < oppCooldown) {
                    if (sellScoreAdj < (minThreshold + reverseHys)) return;
                }
                this.generateFinalSignal('sell', sell.contributors, sellScoreAdj);
            }
        }

        generateFinalSignal(direction, contributors, finalScore) {
            const contributingStrats = contributors.map(c => this.bot.strategies[c.strategy]?.displayName || c.strategy).join(', ');
            const status = this.bot.settings.features.enableCandleConfirm ? 'pending' : 'active';
            
            const signal = { 
                id: `sig_${Date.now()}`, timestamp: Date.now(), symbol: this.bot.currentSymbol, 
                direction, price: this.bot.marketData.price, score: finalScore, 
                reason: contributingStrats, contributors, status: status, note: '',
                mfeR: 0, beDone: false, trailingStage: 0, entrySlDistance: 0, entryTpDistance: 0,
                recommendedSize: this.bot.getRecommendedPositionSize(finalScore)
            };

            this.bot.calculateDynamicTpSl(signal);

            if (status === 'pending') {
                this.bot.addPendingSignal(signal);
            } else {
                this.bot.activateSignal(signal);
            }
            
            this.proposals = [];
            const now = Date.now();
            this.lastSignalTime = now;
            this.lastSignalTimeByDirection[direction] = now;
            this.lastDirection = direction;
        }
    }

    /* =========================
       ANA UYGULAMA
       ========================= */
    class UltimateTradingCommandCenter {
        constructor() {
            this.allStrategiesMap = {
                'wallBounce': WallBounceStrategy, 'velocityScalping': VelocityScalpingStrategy, 'rsiDivergence': RsiDivergenceStrategy, 
                'orderFlowMomentum': OrderFlowMomentumStrategy, 'liquidityGaps': LiquidityGapsStrategy, 'fibonacciRetracement': FibonacciRetracementStrategy, 
                'volumeProfile': VolumeProfileStrategy, 'smartMoneyConcepts': SmartMoneyConceptsStrategy, 'divergenceDetection': DivergenceDetectionStrategy, 
                'breakoutPattern': BreakoutPatternStrategy, 'supportResistance': SupportResistanceStrategy, 'marketStructure': MarketStructureStrategy, 
                'institutionalOrderFlow': InstitutionalOrderFlowStrategy, 'microSpreadArbitrage': MicroSpreadArbitrageStrategy,
                'vwapReversion': VWAPReversionStrategy, 'superTrend': SuperTrendStrategy,
                'volatilityBreakout': VolatilityBreakoutStrategy,
                'candleCharacter': CandleCharacterStrategy,
                'fundingRateReversal': FundingRateReversalStrategy
            };
            this.allStrategyKeys = Object.keys(this.allStrategiesMap); 

            this.isRunning = false; 
            this.sockets = {}; 
            
            this.currentSymbol = this.loadData('utc_current_symbol') || 'BTCUSDT'; 
            this.currentTimeframe = this.loadData('utc_current_timeframe') || '15m';
            this.headerCollapsed = this.loadData('utc_header_collapsed') !== null ? (this.loadData('utc_header_collapsed') === 'true') : true; 
            this.currentMainView = this.loadData('utc_current_view') || 'chart';

            this.marketData = { price: 0, change24h: 0, volume24h: 0, symbol: this.currentSymbol, btcPrice: 70000 }; 
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 

            this.aggTrades = []; 
            this.candles = [];
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null, bbands: null }; 
            this.signals = this.loadData('utc_signals') || [];
            this.pendingSignals = [];
            this.stats = this.loadData('utc_stats') || { total: 0, tp: 0, sl: 0 };

            this.strategyStats = this.loadData('utc_strategy_stats') || this.initDefaultStrategyStats();
            this.marketRegime = 'unknown';
            this.riskState = 'neutral'; 
            this.sessionState = 'unknown';

            this.strategyGroups = {
                trending: ['breakoutPattern','orderFlowMomentum','marketStructure','volumeProfile','smartMoneyConcepts','superTrend', 'volatilityBreakout'],
                meanReversion: ['vwapReversion','wallBounce','liquidityGaps','fibonacciRetracement','supportResistance','microSpreadArbitrage','divergenceDetection','rsiDivergence','institutionalOrderFlow', 'fundingRateReversal'],
                neutral: ['candleCharacter']
            };
            
            this.settings = this.loadSettings();
            this.strategies = {}; 
            
            this.combatModeActive = false;
            this.reconnectAttempts = 0;
            this.reconnectDelay = 3000;

            this.shadowProposals = [];

            this.chartManager = new ChartManager('live-chart');
            this.heatmapManager = new HeatmapManager('orderbook-heatmap');
            this.confluenceEngine = new ConfluenceEngine(this);
            this.multiTimeframeManager = new MultiTimeframeManager(this); 
            this.spoofDetector = new SpoofDetector(this);               
            this.cusumDetector = new CUSUMDriftDetector();               
            this.sessionProfiler = new SessionProfiler(this);
            this.riskGuardian = new RiskGuardian(this);                   
            this.notificationCenter = new AdvancedNotificationCenter(this);
            
            this.renderInterval = null; 
            this.analysisInterval = null;
            this.cooldownTuneInterval = null;
            this.thresholdTuneInterval = null;
            this.paramTuneInterval = null;
            this.sessionUpdateInterval = null;
            this.countdownInterval = null; 
            this.performanceMonitorInterval = null; // DÜZELTME: Performans izleyici için

            this.lastAutoToggleTs = 0;
            this.runtimeThresholdOffset = 0; 
            this.lastCalculatedCandle = null; // DÜZELTME: İndikatör optimizasyonu için
            this.renderTimeout = null; // DÜZELTME: Render debounce için

            this.synth = window.speechSynthesis || null;
            this.speechQueue = []; // DÜZELTME: Konuşma kuyruğu
            this.isSpeaking = false; // DÜZELTME: Konuşma durumu
            this.voices = [];
            
            // DÜZELTME: Eksik TTS metinleri eklendi
                        this.speechTexts = {
                buy: [
                    "Harika bir fırsat! [Sembol] için alım sinyali geldi. Yeşil ışık yanıyor! Skor [Skor].",
                    "Piyasa nefes aldı, [Sembol] yükselişe geçiyor. Bu trene binmek ister misin? Skor [Skor].",
                    "Komutanım, hesaplamalar net: [Sembol] için güçlü bir alım. Devler uyanıyor! Skor [Skor].",
                    "Cüzdanlarınıza dikkat, [Sembol] için bir yükseliş trendi başlangıcı. Fırsat kapınızı çaldı! Skor [Skor].",
                    "Gözünü dört aç! [Sembol] için büyük bir potansiyel görüyorum. Roket kalkışa hazır! Skor [Skor].",
                    "Bugün şanslı günün olabilir! [Sembol] alım için çağırıyor. İç sesine kulak ver! Skor [Skor].",
                    "Duy sesimi Komutanım! [Sembol] için alım sinyali. Hadi, pazarın nabzını tutalım! Skor [Skor].",
                    "Piyasa dans etmeye başladı, [Sembol] yükselişle eşlik ediyor. Katılmak ister misin? Skor [Skor].",
                    "Bana güven, [Sembol] için enerji pozitif. Bu işlemi kaçırmak istemezsin. Skor [Skor].",
                    "Ulan [Sembol] için alım sinyali patladı, hala ne bekliyorsun lanet olası! Kalk ve parayı kap, yoksa pişmanlık seni yer bitirir! Skor [Skor]."
                ],
                sell: [
                    "Piyasa biraz yorulmuş gibi, [Sembol] için satış sinyali geldi. Karları garantiye alalım! Skor [Skor].",
                    "Komutanım, [Sembol] için aşağı yönlü bir hareketlilik bekliyorum. Tetikte ol! Skor [Skor].",
                    "Bazen geri çekilmek de kazanmaktır. [Sembol] için satış vakti. Parçaları topluyoruz! Skor [Skor].",
                    "Bir fırtına yaklaşıyor olabilir, [Sembol] için satış sinyali. Kendini güvende tut! Skor [Skor].",
                    "Akıllıca bir adım! [Sembol] için kazançları koruma zamanı. Hızlı ve isabetli olalım. Skor [Skor].",
                    "Piyasa nazikçe fısıldıyor: [Sembol] için biraz ara ver. Karını koru! Skor [Skor].",
                    "Riskleri minimize etmenin zamanı geldi. [Sembol] için satış önerisi. Gerekirse tekrar gireriz. Skor [Skor].",
                    "Satış sinyali geldi. Umarım boğalar çimlere basmamıştır! [Sembol] için. Skor [Skor].",
                    "Ulan [Sembol] düşüyor, hala mı tutuyorsun lanet olası aptal! Sat da kurtul, yoksa cebin boşalır sinirlenme bana! Skor [Skor].",
                    "Siktir et o umudunu, [Sembol] satış sinyali verdi! Sert ol, çık ve karı kap, motive ol lan yoksa kaybedersin! Skor [Skor]."
                ],
                combatModeActivate: [
                    "Kumandanım, Kırmızı Alarm! Savaş Modu aktive edildi! Piyasanın kalbi şimdi elimizde!",
                    "Sistem uyarısı: Ultra savaş modu devrede! Piyasa savaşı başlıyor! Her bir strateji tam kapasite!",
                    "Savaş Modu Başladı! İleri Komutanım! Tüm güçler hazır, her anı avantaja çevireceğiz!",
                    "Hazırlanın! Savaş Modu aktive edildi. Bu bir zihin oyunu ve biz kazanacağız! Odaklanma ve hız, anahtarımız!",
                    "Ulan savaş modu aktive! Piyasa seni ezmeye çalışıyor ama biz daha sertiz lan, kalk ayağa ve piyasayı sikert! Zafer bizim olacak!"
                ],
                combatModeDeactivate: [
                    "Savaş modu başarıyla sonlandırıldı. Piyasa koşulları normale dönüyor, normal operasyonlara geri dönüyoruz. İyi iş çıkardınız.",
                    "Operasyon sonu. Savaş modu kapatıldı. Şimdi piyasanın sakin sularında yüzme zamanı.",
                    "Savaş modu devre dışı. Riskler azaldı, piyasa sakinleşiyor. Sakin sularda bile fırsatlar vardır, unutmayın.",
                    "Kumandanım, savaş bitti. Kazanılmış bir zaferin ardından dinlenme vakti. Bir sonraki mücadeleye kadar hazırız.",
                    "Ulan savaş modu kapandı, hala mı sinirli duruyorsun lan? Rahatla Komutanım, zaferi kutla yoksa ben sinirlenirim sana da!"
                ],
                signalTP: [
                    "Hedef vuruldu! TP geldi, Komutanım! Bu başarı sizin stratejik dehanızın kanıtı!",
                    "Tebrikler! Kar realizasyonu gerçekleşti. Şimdi kahve içme zamanı, zafer sizin!",
                    "TP alarmı! Kazanç cebinizde, piyasa artık bizim kontrolümüzde. Harika iş!",
                    "Boom! TP hedefi tutturuldu. Strateji kusursuz, Komutanım lider!",
                    "Kar alındı! Zekânız ve disiplininizle piyasanın kalbini fethettiniz!",
                    "Ulan TP vuruldu, para cebinde lan! Sinirliydim piyasaya ama sen ezerdin, motive ol da kutla zaferi Komutanım!"
                ],
                signalSL: [
                    "SL tetiklendi! Savaş kaybedilmiş değil, ders alınmış! Komutanım, hazırlanın ve tekrar saldırın!",
                    "Stop Loss aktif. Kaybedilen bir savaş değil, bir sonraki zaferin başlangıcı!",
                    "SL geldi, ama moral bozulmasın. Bu sadece piyasanın egonuzu test etmesi!",
                    "Kaybı kabul et, ama pes etme. SL tetiklendi, stratejiyi yeniden şekillendiriyoruz!",
                    "SL alarmı! Hedefi kaybettik ama deneyim kazandık, Komutanım!",
                    "Ulan SL tetiklendi, para gitti lan! Sinirlim piyasaya ama sen pes etme, motive ol da tekrar saldır Komutanım!"
                ],
                cusumDriftDetected: [
                    "CUSUM drift tespit edildi! Komutanım, piyasa dalgalanıyor ama biz her zaman hazırız!",
                    "Sinyal değişimi geldi, dikkat! Bu bir fırsat ya da ders, sizin kararınız!",
                    "CUSUM alarmı! Strateji tetikte, piyasa bizi test ediyor ama biz kazanmaya odaklıyız!",
                    "Drift detected! Piyasa kıvılcımları uçuşuyor, Komutanım, kontrol sizde!",
                    "Ulan CUSUM drift patladı, piyasa dalgalanıyor lan! Sinirlim ulan, ama motive ol da hazır ol, fırsat mı ders mi sen karar ver!"
                ],
                autoToggleDeactivate: [
                    "Optimizasyon uyarısı: [Strateji Adı] stratejisi beklenen performansı göstermedi. Geçici olarak pasif edildi.",
                    "[Strateji Adı] stratejisi, performans testinden geçemedi. Geçici olarak emekli edildi. Dikkatli olalım.",
                    "Bir strateji daha devredışı. [Strateji Adı] şu an için dinlenmeye alındı. Daha iyi günler için bekliyoruz.",
                    "Ulan [Strateji Adı] performansı sıçtı, pasif edildi lan! Sinirlim ulan, ama motive ol da bekle, en iyisi bu!"
                ],
                autoToggleActivate: [
                    "Optimizasyon başarıyla tamamlandı: [Strateji Adı] stratejisi tekrar aktif edildi. Yeni veriler çok umut verici!",
                    "Müjde! [Strateji Adı] stratejisi tekrar göreve hazır! Performansı yükselişte. Hadi bakalım, piyasayı sallayalım!",
                    "Hoş geldin geri [Strateji Adı]! Kendini toparlamışsın. Tekrar aktif edildi. Şimdi bize neler göstereceksin merak ediyorum.",
                    "Ulan [Strateji Adı] geri döndü, aktif edildi lan! Sinirlim yokluğunda ama motive ol da sallayalım piyasayı, zafer yakın ulan!"
                ],
                cooldownOptimize: [
                    "Sistem, soğuma sürelerini başarıyla yeniden ayarladı. Piyasanın nabzına göre şimdiden optimize edildik Komutanım.",
                    "Cooldown ayarları güncellendi. Artık sinyaller arasında daha zeki bir denge kuruyoruz. Ben bu işi biliyorum!",
                    "Piyasa ritmini değiştirdi, biz de cooldown sürelerimizi. Tam senkronizasyon için her şey ayarlandı Komutanım.",
                    "Ulan cooldown süreleri ayarlandı lan! Sinirlim piyasanın ritmine ama optimize ettik, motive ol da dans pistinde ezeriz hepsini Komutanım!"
                ],
                systemStart: [
                    "Sistem başlatıldı. Canlı veri akışı başlıyor. Gözlerim ve kulaklarım piyasada Komutanım.",
                    "Başlatma tamamlandı. Piyasa analizine başlıyorum. Bana güvenebilirsin.",
                    "Uyanıyorum... Tüm sensörler aktif. Piyasa maceramız şimdi başlıyor!",
                    "Ulan sistem başladı lan! Sinirlim uykuda ama şimdi canlı veri akıyor, motive ol da piyasayı ezeriz Komutanım!"
                ],
                systemStop: [
                    "Sistem durduruldu. Operasyonlar askıya alındı. Bir mola verelim Komutanım.",
                    "Kapanış prosedürü aktif. Veri akışı durduruldu. Daha sonra görüşmek üzere!",
                    "Enerji tasarrufu modu. Sistem kapanıyor. İhtiyaç duyduğunuzda beni tekrar başlatabilirsiniz.",
                    "Ulan sistem durduruldu lan! Sinirlim piyasaya ama şimdi mola ver, motive ol da dinlen Komutanım yoksa ezerim seni yorgunlukla!"
                ],
                symbolChange: [
                    "Sembol [Sembol] olarak değiştirildi. Yeni bir maceraya hazırız.",
                    "Hedef [Sembol] olarak güncellendi. Adaptasyon tamamlandı. Şimdi bu sembole odaklanıyoruz.",
                    "Sembol değişimi: [Sembol]. Her zaman yeni bir meydan okumaya açığım.",
                    "Ulan sembol [Sembol] oldu lan! Sinirlim eskisine ama şimdi motive ol da yeni maceraya atıl, ezeriz piyasayı Komutanım!"
                ],
                timeframeChange: [
                    "Zaman aralığı [Timeframe] olarak değiştirildi. Daha büyük veya küçük resme odaklanıyoruz.",
                    "Mum çubuğu zaman dilimi [Timeframe] olarak ayarlandı. Bakış açımızı güncelledik.",
                    "[Timeframe] zaman dilimindeyiz. Piyasanın farklı bir yüzünü keşfediyoruz.",
                    "Ulan zaman aralığı [Timeframe] oldu lan! Sinirlim eskisine ama şimdi motive ol da büyük resme odaklan, ezeriz piyasayı Komutanım!"
                ],
                resetAll: [
                    "Tüm ayarlar sıfırlandı. Sistem yeniden başlatılmaya hazır. Temiz bir sayfa açtık Komutanım.",
                    "Ulan tüm ayarlar sıfırlandı lan! Sinirlim karmaşaya ama şimdi motive ol da temiz sayfaya atıl, ezeriz piyasayı Komutanım!"
                ],
                shadowBan: [
                    "[Strateji] gölgeye alındı. Uslan da gel!",
                    "Şşşt [Strateji], gölge moduna geç. Önce pistte kendini ispat et."
                ],
                shadowRehab: [
                    "Bravo! [Strateji] gölgede form tuttu, tekrar sahnede.",
                    "[Strateji] rehabilite edildi. Hadi bakalım, yüzümüzü kara çıkarma!"
                ],
                rogueOfDay: [
                    "Bugünün şerefsizi: [Strateji]! Kendine gel de adam gibi sinyal ver.",
                    "[Strateji], bugün gözüm üzerinde. Şerefsizlikte ısrar etme!"
                ],
                spoofBidRemoved: [
                    "Sahte emir tespit edildi, düşüş gelebilir. Dikkat et hacı abi.",
                    "Uyarı! Büyük bir alış desteği kayboldu. Piyasa aşağı sarkabilir, tetikte ol.",
                    "Balina desteğini çekti! Fiyat düşebilir, dikkatli ol komutanım."
                ],
                spoofAskRemoved: [
                    "Sahte emir tespit edildi, alım gelebilir. Dikkat et komutanım.",
                    "Uyarı! Büyük bir satış duvarı kayboldu. Fiyat yukarı hareketlenebilir, hazır ol.",
                    "Balina direnci kaldırdı! Fiyat yukarı doğru gidebilir , gözünü dört aç hacı abi."
                ]
            };


            this.init();
        }

        initDefaultStrategyStats() {
            const stats = {};
            (this.allStrategyKeys || []).forEach(k => {
                const baseStat = { alpha: 3, beta: 2, proposals: 0, contrib: 0, wins: 0, losses: 0, shadowWins: 0, shadowLosses: 0, shadowProposals: 0, lastUpdate: Date.now() };
                stats[k] = {
                    overall: { ...baseStat },
                    trend: { ...baseStat },
                    range: { ...baseStat },
                    transition: { ...baseStat }
                };
            });
            return stats;
        }
        saveStrategyStats() { this.saveData('utc_strategy_stats', this.strategyStats); }

        loadSettings() {
            const savedSettings = JSON.parse(localStorage.getItem('utc_settings') || '{}');
            const defaults = {
                confluenceThreshold: 3,
                params: { rsiPeriod: 14, atrPeriod: 14, wallBtc: 20, rrRatio: 1.5 },
                cooldowns: { signalMs: 15000, sameDirectionMs: 30000, oppositeDirectionMs: 20000, reverseHysteresisPoints: 2, proposalTimeoutMs: 3000, strategyProposalMs: 10000 },
                features: { 
                    enableSpoofDetection: true, enableCUSUMDrift: true, enableRiskGuardian: true, enableTTS: true, preferredVoiceName: null,
                    enableCandleConfirm: true,
                    enableMtfConfirm: true,
                    mtfTimeframe: '15m',
                    enableDynamicSizing: true
                },
                riskGuardian: {
                    killSwitchWinRate: 35.0,
                    autoRecover: false,
                    maxDrawdown: 5.0
                },
                optimization: {
                    enabled: true,
                    autoToggle: true,
                    timeDecaySec: 3,
                    dirMargin: 0.5,
                    minWeightToStay: 0.60,
                    minContribForToggle: 30,
                    gating: { enabled: true, spreadMaxPct: 0.001, minDepthUsd: 50000 },
                    signalQuality: { minContributors: 2, minGroups: 1 },
                    breakeven: { enabled: true, beAtR: 0.8, trailAfterR: 1.5, trailToR: 0.5 }
                },
                penalties: {
                    shadowEnabled: true,
                    minWeightToShadow: 0.60,
                    minContribForShadow: 30,
                    rehabWinRate: 0.58,
                    minShadowProposals: 20,
                    coolOffMs: 30 * 60 * 1000
                },
                statusMaps: {
                    shadowBanned: {},
                    hardBanned: {}
                },
                strategyParams: {
                    wallBounce: { DISTANCE_THRESHOLD_PERCENT: 0.0005 },
                    velocityScalping: { VELOCITY_WINDOW_MS: 2000, MIN_POINTS: 20, VELOCITY_THRESHOLD_PERCENT: 0.001 },
                    liquidityGaps: { GAP_THRESHOLD_PERCENT: 0.001 },
                    breakoutPattern: { LOOKBACK: 30, VOL_SPIKE: 1.4, BREAK_PCT: 0.0003 },
                    supportResistance: { LOOKBACK: 60, THRESH: 0.0015 },
                    fibonacciRetracement: { LOOKBACK: 120, TOL: 0.002 },
                    vwapReversion: { MULT: 1.0 },
                    superTrend: { MULT: 3.0, PERIOD: 14 },
                    marketStructure: { SWING: 3 },
                    institutionalOrderFlow: { TOP_N: 5, IMB_THRESHOLD: 2.0 },
                    microSpreadArbitrage: { SPREAD_PCT: 0.0008 },
                    volumeProfile: { PERIOD: 20, SPIKE: 2.0, CLOSE_POS: 0.7 },
                    divergenceDetection: { LOOKBACK: 40, SWING_PERIOD: 3 },
                    volatilityBreakout: { SQUEEZE_LOOKBACK: 20, SQUEEZE_MULT: 1.0, BREAKOUT_VOL_MULT: 1.5 },
                    candleCharacter: { MIN_BODY_TO_WICK_RATIO: 0.6, ANALYSIS_WINDOW_PERCENT: 0.2 },
                    fundingRateReversal: { FETCH_INTERVAL_MS: 60 * 1000, EXTREME_FUNDING_THRESHOLD: 0.001 }
                },
                activeStrategies: {} 
            };
            
            const mergeDeep = (target, source) => {
                for (const key in source) {
                    if (source[key] instanceof Object && key in target && !(source[key] instanceof Array)) {
                        Object.assign(target[key], mergeDeep(target[key], source[key]));
                    } else {
                        target[key] = source[key];
                    }
                }
                return target;
            };

            const currentSettings = mergeDeep(defaults, savedSettings);
            
            this.allStrategyKeys.forEach(key => {
                if (typeof currentSettings.activeStrategies[key] === 'undefined') {
                    currentSettings.activeStrategies[key] = true; 
                }
                if (currentSettings.statusMaps.hardBanned[key] || currentSettings.statusMaps.shadowBanned[key]) {
                    currentSettings.activeStrategies[key] = false;
                }
            });
            return currentSettings;
        }

        saveSettings() {
            localStorage.setItem('utc_settings', JSON.stringify(this.settings));
            this.applyStrategyParamOverrides();
            if (this.isRunning) {
                this.multiTimeframeManager.initialize(this.currentSymbol, [this.settings.features.mtfTimeframe]);
            }
        }
        loadData(key) { try { return JSON.parse(localStorage.getItem(key)); } catch { return null; } }
        saveData(key, data) { localStorage.setItem(key, JSON.stringify(data)); }
        
        getStrategyGroup(key) {
            if (this.strategyGroups.trending.includes(key)) return 'trending';
            if (this.strategyGroups.meanReversion.includes(key)) return 'meanReversion';
            return 'neutral';
        }
        
        getStrategyWeight(name) {
            const regime = this.marketRegime || 'overall';
            const regimeStats = this.strategyStats[name]?.[regime];
            const overallStats = this.strategyStats[name]?.overall;
            
            let s;
            if (regimeStats && (regimeStats.contrib || 0) > 10) {
                s = regimeStats;
            } else {
                s = overallStats || { alpha: 3, beta: 2 };
            }

            const mean = s.alpha / (s.alpha + s.beta);
            const totalObservations = s.alpha + s.beta;
            const uncertaintyPenalty = totalObservations < 10 ? 0.5 + (totalObservations / 20) : 1.0; 
            let w = (0.5 + mean) * uncertaintyPenalty; 
            w *= this.getGroupBoost(name);
            w = Math.max(0.3, Math.min(2.0, w)); 
            return w;
        }

        getGroupBoost(key) {
            const grp = this.getStrategyGroup(key);
            let boost = 1.0;
            if (this.marketRegime === 'trend' && grp === 'trending') boost *= 1.15;
            if (this.marketRegime === 'range' && grp === 'meanReversion') boost *= 1.15;
            const atrPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0;
            if (atrPct < 0.005) { // Düşük volatilite
                if (grp === 'trending') boost *= 0.9; 
                if (grp === 'meanReversion') boost *= 1.05;
            } else if (atrPct > 0.02) { // Yüksek volatilite
                if (grp === 'trending') boost *= 1.05;
                if (grp === 'meanReversion') boost *= 0.95;
            }
            return boost;
        }
        init() {
            this.initStrategies(); 
            this.setupUI(); 
            this.setupEventListeners();
            this.debouncedRender();
            this.logToJournal('Sistem hazır. "SİSTEMİ BAŞLAT" butonuna tıklayın.');
            
            if (this.headerCollapsed) document.body.classList.add('header-collapsed'); else document.body.classList.remove('header-collapsed');
            this.switchMainView(this.currentMainView);
            this.sessionUpdateInterval = setInterval(() => this.updateSession(), 60000); 
            this.updateSession(); 

            this.countdownInterval = setInterval(() => this.updateCandleCountdown(), 1000);

            if (this.synth) {
                this.loadVoices();
                if(this.synth.onvoiceschanged !== undefined) {
                    this.synth.onvoiceschanged = () => this.loadVoices();
                }
            } else {
                console.warn('SpeechSynthesis API bu tarayıcı/cihazda desteklenmiyor.');
            }
            this.applyStrategyParamOverrides();
            this.startPerformanceMonitor(); // DÜZELTME: Performans izleyiciyi başlat
        }

        initStrategies() { 
            for (const key in this.allStrategiesMap) { this.strategies[key] = new this.allStrategiesMap[key](this); } 
            this.updateActiveStrategies(); 
        }
        updateActiveStrategies() { 
            for (const key in this.strategies) { 
                this.strategies[key].DEFAULT_PROPOSAL_COOLDOWN_MS = this.settings.cooldowns.strategyProposalMs; 
                const isActive = this.settings.activeStrategies[key] && 
                                 !this.settings.statusMaps.shadowBanned[key] && 
                                 !this.settings.statusMaps.hardBanned[key];
                this.strategies[key].setIsLive(isActive);
            } 
        }

        applyStrategyParamOverrides() {
            const p = this.settings.strategyParams || {};
            for (const key of Object.keys(this.strategies)) {
                if (!this.strategies[key]) continue;
                const inst = this.strategies[key];
                const ov = p[key] || {};
                for (const k of Object.keys(ov)) {
                    if (k in inst) inst[k] = ov[k];
                }
            }
        }

        setupUI() {
            document.getElementById('symbol-input').value = this.currentSymbol.replace('USDT', '');
            document.getElementById('timeframe-select').value = this.currentTimeframe;

            this.updateSettingsModalUI();
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme(); 
            this.heatmapManager.updateTheme();
            this.updateSuperTopTicker();
        }
        updateSuperTopTicker() { document.getElementById('ticker-bar-symbol').textContent = this.currentSymbol.replace('USDT', '/USDT'); }

        updateSettingsModalUI() {
            const s = this.settings;
            document.getElementById('modal-confluence-threshold').value = s.confluenceThreshold;
            document.getElementById('modal-param-rsi-period').value = s.params.rsiPeriod;
            document.getElementById('modal-param-atr-period').value = s.params.atrPeriod;
            document.getElementById('modal-param-wall-btc').value = s.params.wallBtc;
            document.getElementById('modal-param-rr-ratio').value = s.params.rrRatio;
            document.getElementById('modal-signal-cooldown-ms').value = s.cooldowns.signalMs;
            document.getElementById('modal-same-direction-cooldown-ms').value = s.cooldowns.sameDirectionMs;
            document.getElementById('modal-opposite-direction-cooldown-ms').value = s.cooldowns.oppositeDirectionMs;
            document.getElementById('modal-reverse-hysteresis-points').value = s.cooldowns.reverseHysteresisPoints;
            document.getElementById('modal-proposal-timeout-ms').value = s.cooldowns.proposalTimeoutMs;
            document.getElementById('modal-strategy-proposal-cooldown-ms').value = s.cooldowns.strategyProposalMs;
            document.getElementById('modal-enable-spoof-detection').checked = s.features.enableSpoofDetection;
            document.getElementById('modal-enable-cusum-drift').checked = s.features.enableCUSUMDrift;
            document.getElementById('modal-enable-risk-guardian').checked = s.features.enableRiskGuardian;
            document.getElementById('modal-enable-auto-optimize').checked = s.optimization.enabled;
            document.getElementById('modal-enable-auto-toggle-strat').checked = s.optimization.autoToggle;
            document.getElementById('modal-enable-breakeven-trail').checked = s.optimization.breakeven.enabled;
            document.getElementById('modal-be-at-r').value = s.optimization.breakeven.beAtR;
            document.getElementById('modal-trail-after-r').value = s.optimization.breakeven.trailAfterR;
            document.getElementById('modal-trail-to-r').value = s.optimization.breakeven.trailToR;
            document.getElementById('modal-enable-tts').checked = s.features.enableTTS;
            
            const enableCandleConfirmEl = document.getElementById('modal-enable-candle-confirm');
            if(enableCandleConfirmEl) enableCandleConfirmEl.checked = s.features.enableCandleConfirm;
            
            const enableMtfConfirmEl = document.getElementById('modal-enable-mtf-confirm');
            if(enableMtfConfirmEl) enableMtfConfirmEl.checked = s.features.enableMtfConfirm;
            
            const mtfTimeframeEl = document.getElementById('modal-mtf-timeframe');
            if(mtfTimeframeEl) mtfTimeframeEl.value = s.features.mtfTimeframe;
            
            const enableDynamicSizingEl = document.getElementById('modal-enable-dynamic-sizing');
            if(enableDynamicSizingEl) enableDynamicSizingEl.checked = s.features.enableDynamicSizing;
            
            this.updateTTSVoiceSelectUI(); 

            const strategyModalContainer = document.getElementById('modal-strategy-toggles');
            strategyModalContainer.innerHTML = '';
            this.allStrategyKeys.forEach(key => { 
                const strategy = this.strategies[key];
                if (!strategy) return;
                const isChecked = s.activeStrategies[key];
                const isShadowBanned = s.statusMaps.shadowBanned[key];
                const isHardBanned = s.statusMaps.hardBanned[key];
                
                let statusText = '';
                if (isHardBanned) statusText = ' (HARDBAN)';
                else if (isShadowBanned) statusText = ' (GÖLGE)';

                const toggleHtml = `<div class="form-group"><label class="checkbox-label"><input type="checkbox" class="strategy-toggle" data-strategy-key="${key}" ${isChecked ? 'checked' : ''} ${isHardBanned || isShadowBanned ? 'disabled' : ''}> ${strategy.displayName}${statusText}</label></div>`;
                strategyModalContainer.innerHTML += toggleHtml;
            });
            this.debouncedRender();
        }

                                                setupEventListeners() {
            document.getElementById('start-btn').addEventListener('click', () => this.start());
            document.getElementById('stop-btn').addEventListener('click', () => this.stop());
            document.getElementById('theme-toggle-btn').addEventListener('click', () => this.toggleTheme());
            document.getElementById('symbol-input').addEventListener('change', async (e) => {
                let newSymbol = e.target.value.toUpperCase().trim();
                if (!newSymbol.endsWith('USDT')) newSymbol += 'USDT';
                await this.changeSymbol(newSymbol);
                this.saveData('utc_current_symbol', newSymbol);
            });
            document.getElementById('timeframe-select').addEventListener('change', async (e) => {
                this.changeTimeframe(e.target.value);
                this.saveData('utc_current_timeframe', e.target.value);
            });
            
            document.querySelector('.header-center-title').addEventListener('dblclick', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('mobile-toggle-controls-btn').addEventListener('click', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });

            document.getElementById('main-controls-btn').addEventListener('click', () => {
                this.toggleControlsPanel();
                this.saveData('utc_header_collapsed', this.headerCollapsed.toString());
            });
            document.getElementById('chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
            document.getElementById('heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
            document.getElementById('fullscreen-chart-btn').addEventListener('click', () => this.enterFullscreenChart());
            document.getElementById('exit-fullscreen-btn').addEventListener('click', () => this.exitFullscreenChart());

            document.getElementById('open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
            document.getElementById('clear-markers-btn').addEventListener('click', () => this.clearChartMarkers()); 
            document.getElementById('chart-zoom-in').addEventListener('click', () => this.chartManager.zoomIn());
            document.getElementById('chart-zoom-out').addEventListener('click', () => this.chartManager.zoomOut());
            document.getElementById('chart-zoom-reset').addEventListener('click', () => this.chartManager.resetZoom());
            document.getElementById('close-settings-modal-btn').addEventListener('click', () => this.closeSettingsModal());
            document.getElementById('settings-modal-overlay').addEventListener('click', (e) => { if (e.target.id === 'settings-modal-overlay') this.closeSettingsModal(); });
            
            // DÜZELTME: Yeni grafik butonu için olay dinleyici eklendi
            document.getElementById('mobile-chart-view-btn').addEventListener('click', () => { this.switchMainView('chart'); this.saveData('utc_current_view', 'chart'); });
            document.getElementById('mobile-heatmap-view-btn').addEventListener('click', () => { this.switchMainView('heatmap'); this.saveData('utc_current_view', 'heatmap'); });
            document.getElementById('mobile-fullscreen-chart-btn').addEventListener('click', () => this.enterFullscreenChart());
            document.getElementById('mobile-open-settings-modal-btn').addEventListener('click', () => this.openSettingsModal());
            document.getElementById('mobile-honor-board-btn').addEventListener('click', () => this.openHonorModal());
            document.getElementById('mobile-banned-board-btn').addEventListener('click', () => this.openHonorModal('banned'));
            // YENİ: Log Paneli butonları için olay dinleyicileri
            document.getElementById('mobile-open-log-modal-btn').addEventListener('click', () => {
                document.getElementById('log-modal-overlay').classList.add('visible');
            });
            document.getElementById('close-log-modal-btn').addEventListener('click', () => {
                document.getElementById('log-modal-overlay').classList.remove('visible');
            });
            document.getElementById('export-logs-btn').addEventListener('click', () => this.exportLogs());


            const s = this.settings;
            document.getElementById('modal-confluence-threshold').addEventListener('input', (e) => s.confluenceThreshold = parseInt(e.target.value));
            document.getElementById('modal-param-rsi-period').addEventListener('change', (e) => s.params.rsiPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-atr-period').addEventListener('change', (e) => s.params.atrPeriod = parseInt(e.target.value));
            document.getElementById('modal-param-wall-btc').addEventListener('change', (e) => s.params.wallBtc = parseInt(e.target.value));
            document.getElementById('modal-param-rr-ratio').addEventListener('change', (e) => s.params.rrRatio = parseFloat(e.target.value));
            document.getElementById('modal-signal-cooldown-ms').addEventListener('change', (e) => s.cooldowns.signalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-same-direction-cooldown-ms').addEventListener('change', (e) => s.cooldowns.sameDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-opposite-direction-cooldown-ms').addEventListener('change', (e) => s.cooldowns.oppositeDirectionMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-reverse-hysteresis-points').addEventListener('change', (e) => s.cooldowns.reverseHysteresisPoints = parseInt(e.target.value) || 0);
            document.getElementById('modal-proposal-timeout-ms').addEventListener('change', (e) => s.cooldowns.proposalTimeoutMs = parseInt(e.target.value) || 1000);
            document.getElementById('modal-strategy-proposal-cooldown-ms').addEventListener('change', (e) => s.cooldowns.strategyProposalMs = parseInt(e.target.value) || 0);
            document.getElementById('modal-enable-spoof-detection').addEventListener('change', (e) => s.features.enableSpoofDetection = e.target.checked);
            document.getElementById('modal-enable-cusum-drift').addEventListener('change', (e) => s.features.enableCUSUMDrift = e.target.checked);
            document.getElementById('modal-enable-risk-guardian').addEventListener('change', (e) => s.features.enableRiskGuardian = e.target.checked);
            document.getElementById('modal-enable-auto-optimize').addEventListener('change', (e) => s.optimization.enabled = e.target.checked);
            document.getElementById('modal-enable-auto-toggle-strat').addEventListener('change', (e) => s.optimization.autoToggle = e.target.checked);
            document.getElementById('modal-enable-breakeven-trail').addEventListener('change', (e) => s.optimization.breakeven.enabled = e.target.checked);
            document.getElementById('modal-be-at-r').addEventListener('change', (e) => s.optimization.breakeven.beAtR = parseFloat(e.target.value));
            document.getElementById('modal-trail-after-r').addEventListener('change', (e) => s.optimization.breakeven.trailAfterR = parseFloat(e.target.value));
            document.getElementById('modal-trail-to-r').addEventListener('change', (e) => s.optimization.breakeven.trailToR = parseFloat(e.target.value));
            document.getElementById('modal-enable-tts').addEventListener('change', (e) => {
                s.features.enableTTS = e.target.checked;
                this.updateTTSVoiceSelectUI();
            });
            document.getElementById('modal-tts-voice-select').addEventListener('change', (e) => {
                s.features.preferredVoiceName = e.target.value === "" ? null : e.target.value;
                this.saveSettings();
                if (e.target.value !== "") this.speak("Ses başarıyla değiştirildi.", { lang: 'tr-TR', rate: 1.0 });
            });
            const enableCandleConfirmEl = document.getElementById('modal-enable-candle-confirm');
            if(enableCandleConfirmEl) enableCandleConfirmEl.addEventListener('change', (e) => s.features.enableCandleConfirm = e.target.checked);
            
            const enableMtfConfirmEl = document.getElementById('modal-enable-mtf-confirm');
            if(enableMtfConfirmEl) enableMtfConfirmEl.addEventListener('change', (e) => s.features.enableMtfConfirm = e.target.checked);
            
            const mtfTimeframeEl = document.getElementById('modal-mtf-timeframe');
            if(mtfTimeframeEl) mtfTimeframeEl.addEventListener('change', (e) => s.features.mtfTimeframe = e.target.value);
            
            const enableDynamicSizingEl = document.getElementById('modal-enable-dynamic-sizing');
            if(enableDynamicSizingEl) enableDynamicSizingEl.addEventListener('change', (e) => s.features.enableDynamicSizing = e.target.checked);


            document.getElementById('modal-strategy-toggles').addEventListener('change', (e) => {
                if (e.target.classList.contains('strategy-toggle')) {
                    const key = e.target.dataset.strategyKey;
                    if (s.statusMaps.hardBanned[key] || s.statusMaps.shadowBanned[key]) {
                        e.target.checked = !e.target.checked; 
                        return;
                    }
                    s.activeStrategies[key] = e.target.checked;
                    this.updateActiveStrategies();
                    this.showNotification(`${this.strategies[key].displayName} ${e.target.checked ? 'aktif' : 'pasif'}.`, 'info');
                    this.saveSettings();
                }
            });

            document.getElementById('modal-clear-signals-btn').addEventListener('click', () => this.clearAllSignals());
            document.getElementById('reset-all-settings-btn').addEventListener('click', () => this.resetAllSettings());
            document.getElementById('save-settings-btn').addEventListener('click', () => { this.saveSettings(); this.showNotification('Ayarlar kaydedildi!', 'success'); this.closeSettingsModal(); });

            document.getElementById('honor-board-btn').addEventListener('click', () => this.openHonorModal());
            document.getElementById('banned-board-btn').addEventListener('click', () => this.openHonorModal('banned'));
            document.getElementById('close-honor-modal').addEventListener('click', () => this.closeHonorModal());
            document.getElementById('honor-modal-overlay').addEventListener('click', (e)=>{ if (e.target.id === 'honor-modal-overlay') this.closeHonorModal(); });
            
            const centerPanel = document.querySelector('.center-panel');
            const resizeHandle = centerPanel.querySelector('.resize-handle');
            if (resizeHandle) {
                let isResizing = false;
                const onMouseMove = (e) => {
                    if (!isResizing) return;
                    const containerRect = centerPanel.parentElement.getBoundingClientRect();
                    let newHeight = e.clientY - containerRect.top;
                    newHeight = Math.max(200, Math.min(containerRect.height - 150, newHeight));
                    centerPanel.style.height = `${newHeight}px`;
                    window.dispatchEvent(new Event('resize')); 
                };
                const onMouseUp = () => {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    document.body.style.cursor = 'ns-resize';
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
            }
        }






        toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('utc_theme', newTheme);
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
        }
        toggleControlsPanel() {
            document.body.classList.toggle('header-collapsed');
            this.headerCollapsed = document.body.classList.contains('header-collapsed'); 
            setTimeout(() => { window.dispatchEvent(new Event('resize')); }, 360);
        }
        switchMainView(viewName) {
            this.currentMainView = viewName;
            const chartView = document.getElementById('chart-container-view');
            const heatmapView = document.getElementById('heatmap-container-view');
            const chartCountdownOverlay = document.getElementById('chart-countdown-overlay');

            if (viewName === 'chart') {
                chartView.classList.remove('hidden-view');
                heatmapView.classList.add('hidden-view');
                chartCountdownOverlay.classList.remove('hidden-view');
            } else {
                chartView.classList.add('hidden-view');
                heatmapView.classList.remove('hidden-view');
                chartCountdownOverlay.classList.add('hidden-view');
            }
            setTimeout(() => window.dispatchEvent(new Event('resize')), 50);
        }
        enterFullscreenChart() {
            document.body.classList.add('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.remove('hidden-view');
            document.getElementById('chart-countdown-overlay').classList.remove('hidden-view');
            window.dispatchEvent(new Event('resize'));
        }
        exitFullscreenChart() {
            document.body.classList.remove('fullscreen-chart');
            document.getElementById('exit-fullscreen-btn').classList.add('hidden-view');
            if (this.currentMainView !== 'chart') {
                document.getElementById('chart-countdown-overlay').classList.add('hidden-view');
            }
            window.dispatchEvent(new Event('resize'));
        }

        openSettingsModal() { this.updateSettingsModalUI(); document.getElementById('settings-modal-overlay').classList.add('visible'); }
        closeSettingsModal() { document.getElementById('settings-modal-overlay').classList.remove('visible'); this.updateActiveStrategies(); this.calculateAllIndicators(); window.dispatchEvent(new Event('resize')); }

        resetAllSettings() {
            if (confirm('Tüm ayarları ve sinyal geçmişini sıfırlamak istediğinizden emin misiniz? Bu işlem geri alınamaz.')) {
                localStorage.clear();
                window.location.reload();
            }
        }

        async start() {
            if (this.isRunning) return;
            this.isRunning = true; 
            document.getElementById('start-btn').disabled = true; 
            document.getElementById('stop-btn').disabled = false;
            
            if (this.settings.features.enableMtfConfirm) {
                this.multiTimeframeManager.initialize(this.currentSymbol, [this.settings.features.mtfTimeframe]);
            }
            
            this.showNotification('Sistem Başlatıldı: Canlı veri akışı başlatılıyor...', 'success');
            this.speak(this.getRandomMessage('systemStart'));
            await this.fetchInitialData(); 
            this.connectWebSockets();
            
            this.renderInterval = setInterval(() => this.render(), 250);
            this.analysisInterval = setInterval(() => this.runPeriodicAnalysis(), 5000);
            if (this.settings.optimization.enabled) {
                this.cooldownTuneInterval = setInterval(() => this.autoTuneCooldowns(), 30000); 
                this.thresholdTuneInterval = setInterval(() => this.autoTuneThresholds(), 30000); 
                this.paramTuneInterval = setInterval(() => this.autoTuneStrategyParams(), 5 * 60 * 1000);
                this.autoToggleStrategiesInterval = setInterval(() => this.autoToggleStrategies(), 5 * 60 * 1000);
            }
        }

        stop() {
            if (!this.isRunning) return;
            this.isRunning = false; 
            document.getElementById('start-btn').disabled = false; 
            document.getElementById('stop-btn').disabled = true; 
            this.disconnectWebSockets();
            if (this.renderInterval) clearInterval(this.renderInterval); 
            if (this.analysisInterval) clearInterval(this.analysisInterval);
            if (this.cooldownTuneInterval) clearInterval(this.cooldownTuneInterval);
            if (this.thresholdTuneInterval) clearInterval(this.thresholdTuneInterval);
            if (this.paramTuneInterval) clearInterval(this.paramTuneInterval);
            if (this.autoToggleStrategiesInterval) clearInterval(this.autoToggleStrategiesInterval);
            
            this.multiTimeframeManager.cleanup();
            this.updateConnectionStatus(false, "BAĞLANTI KESİLDİ"); 
            if (this.combatModeActive) this.deactivateCombatMode();
            this.showNotification('Sistem Durduruldu.', 'danger');
            this.speak(this.getRandomMessage('systemStop'));
        }

        async changeSymbol(newSymbol) {
            if (this.currentSymbol === newSymbol) return;
            this.currentSymbol = newSymbol; 
            this.showNotification(`${this.currentSymbol.replace('USDT', '/USDT')} sembolüne geçildi.`, 'info');
            this.speak(this.getRandomMessage('symbolChange', { 'Sembol': this.currentSymbol.replace('USDT', '') }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); }
            this.updateSuperTopTicker(); 
        }
        async changeTimeframe(newTimeframe) {
            this.currentTimeframe = newTimeframe; 
            this.showNotification(`Zaman aralığı ${this.currentTimeframe} olarak değiştirildi.`, 'info');
            this.speak(this.getRandomMessage('timeframeChange', { 'Timeframe': this.currentTimeframe }));
            this.resetDataForNewSymbol();
            if (this.isRunning) { this.stop(); await this.start(); }
        }
                resetDataForNewSymbol() {
            // --- YENİ: Grafik hafızasını temizle ---
            localStorage.removeItem('utc_chart_view');

            this.candles = []; this.aggTrades = []; this.marketData.price = 0; 
            this.orderBook = { bids: [], asks: [], lastUpdateId: null }; 
            this.indicators = { rsi: [], atr: null, sma20: null, sma50: null, volSma20: null, vwap: null, adx: null, bbands: null };
            this.pendingSignals = [];
            this.chartManager.setData([]); this.chartManager.clearMarkers(); this.render();
            this.heatmapManager.draw({bids:[], asks:[]}, 0);
        }


        async fetchInitialData() {
            try {
                this.logToJournal(`${this.currentSymbol} için geçmiş mum verileri çekiliyor...`);
                const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=${this.currentTimeframe}&limit=500`;
                const response = await fetch(url); if (!response.ok) throw new Error(`API Hatası: ${response.statusText}`);
                const data = await response.json();
                this.candles = data.map(d => ({ time: d[0], open: parseFloat(d[1]), high: parseFloat(d[2]), low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]), }));
                this.chartManager.setData(this.candles); this.logToJournal(`${this.candles.length} adet mum yüklendi.`);
                this.calculateAllIndicators();
            } catch (error) { this.showNotification(`Geçmiş veri alınamadı: ${error.message}`, 'danger'); console.error("Geçmiş veri hatası:", error); }
        }

        connectWebSockets() {
            this.disconnectWebSockets(); 
            this.reconnectAttempts = 0;
            const symbolLower = this.currentSymbol.toLowerCase();
            const streams = [`${symbolLower}@ticker`, `${symbolLower}@depth20@100ms`, `${symbolLower}@aggTrade`, `${symbolLower}@kline_${this.currentTimeframe}`];
            const ws = new WebSocket(`wss://fstream.binance.com/stream?streams=${streams.join('/')}`); 
            this.sockets['main'] = ws;
            
            ws.onopen = () => { this.updateConnectionStatus(true); this.reconnectAttempts = 0; this.logToJournal("WebSocket bağlantısı başarıyla kuruldu."); };
            ws.onmessage = (event) => { const message = JSON.parse(event.data); this.handleMarketData(message.stream, message.data); };
            ws.onerror = (error) => console.error('WebSocket Hatası:', error);
            ws.onclose = () => { 
                if (this.isRunning) { 
                    this.reconnectAttempts++;
                    this.reconnectDelay = Math.min(30000, 3000 * Math.pow(2, this.reconnectAttempts - 1));
                    const message = `YENİDEN BAĞLANILIYOR... (${this.reconnectDelay / 1000}s)`;
                    this.updateConnectionStatus(false, message); 
                    this.logToJournal(`Bağlantı kapandı. ${this.reconnectDelay/1000} saniye sonra yeniden denenecek. (Deneme: ${this.reconnectAttempts})`);
                    setTimeout(() => this.connectWebSockets(), this.reconnectDelay); 
                } 
            };
        }
        disconnectWebSockets() { 
            if (this.sockets['main']) { 
                this.sockets['main'].onclose = null;
                this.sockets['main'].close(1000, "İstemci tarafından kapatıldı"); 
                delete this.sockets['main'];
            }
        }

        handleMarketData(stream, data) {
            const streamType = stream.split('@')[1];
            if (streamType === 'ticker') {
                this.marketData.price = parseFloat(data.c);
                this.marketData.change24h = parseFloat(data.P);
                this.marketData.volume24h = parseFloat(data.q);
                this.marketData.symbol = data.s;
                if (data.s === 'BTCUSDT') this.marketData.btcPrice = parseFloat(data.c);
                this.manageOpenPositions();
                this.checkAutoCloseSignals();
            } 
            else if (streamType.startsWith('depth')) {
                this.orderBook = { 
                    bids: data.b.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    asks: data.a.map(([p, q]) => [parseFloat(p), parseFloat(q)]), 
                    lastUpdateId: data.u 
                };
                this.heatmapManager.draw(this.orderBook, this.marketData.price);
                if(this.settings.features.enableSpoofDetection) this.spoofDetector.trackOrderBook(this.orderBook);
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].analyzeOrderBook === 'function') {
                        this.strategies[key].analyzeOrderBook(this.orderBook);
                    }
                }
            } else if (streamType.startsWith('kline')) {
                if (this.candles.length > 0) {
                    const kline = data.k;
                    const lastCandleInArray = this.candles[this.candles.length - 1];
                    const currentCandleData = { time: kline.t, open: parseFloat(kline.o), high: parseFloat(kline.h), low: parseFloat(kline.l), close: parseFloat(kline.c), volume: parseFloat(kline.v) };
                    
                    if (lastCandleInArray && lastCandleInArray.time === currentCandleData.time) {
                        this.candles[this.candles.length - 1] = currentCandleData;
                    } else {
                         this.candles.push(currentCandleData);
                    }

                    this.chartManager.updateRealtime(kline);

                    if (kline.x) { // Mum kapandı
                        if (this.candles[this.candles.length -1].time !== currentCandleData.time) {
                            this.candles.push(currentCandleData);
                        }
                        if (this.candles.length > 501) this.candles.shift(); 
                        
                        this.checkPendingSignals(currentCandleData);
                        this.calculateAllIndicators(); 
                    }
                    this.manageOpenPositions();
                    this.checkAutoCloseSignals();
                }
            } else if (streamType === 'aggTrade') {
                const trade = { price: parseFloat(data.p), quantity: parseFloat(data.q), isBuyerMaker: data.m, timestamp: data.T };
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].processTrade === 'function') {
                        this.strategies[key].processTrade(trade);
                    }
                }
            }
        }
        
                runPeriodicAnalysis() { 
            if (!this.isRunning) return; 
            try {
                for (const key in this.strategies) {
                    if (this.strategies[key] && typeof this.strategies[key].periodicAnalyze === 'function') {
                        this.strategies[key].periodicAnalyze(); 
                    }
                }
                if (this.settings.features.enableRiskGuardian) this.riskGuardian.checkKillSwitch();

                // --- YENİ: SPOOF DETECTOR OPTİMİZASYONUNU ÇAĞIR ---
                if (this.settings.features.enableSpoofDetection) {
                    this.spoofDetector.checkConfirmations();
                    this.spoofDetector.autoOptimizeThreshold();
                }
                // --- BİTTİ ---

            } catch (error) {
                console.error('Periodic analysis error:', error);
                this.showNotification('Analiz hatası! Loglara bakın.', 'danger');
            }
        }

        
                calculateAllIndicators() {
            if (this.candles.length === 0) return;
            const rsiPeriod = this.settings.params.rsiPeriod;
            const atrPeriod = this.settings.params.atrPeriod;
            const bbandsPeriod = 20;

            const closes = this.candles.map(c => c.close);
            const highs = this.candles.map(c => c.high);
            const lows = this.candles.map(c => c.low);
            const volumes = this.candles.map(c => c.volume);
            const candleTimes = this.candles.map(c => c.time);

            // RSI
            if (closes.length >= rsiPeriod) {
                this.indicators.rsi = this.calculateRSI(closes, rsiPeriod);
            } else { this.indicators.rsi = []; } 

            // ATR
            if (this.candles.length >= atrPeriod) {
                this.indicators.atr = this.calculateATR(this.candles, atrPeriod);
            } else { this.indicators.atr = null; }

            // Bollinger Bands (ORİJİNAL HALİNE DÖNDÜRÜLDÜ)
            if (closes.length >= bbandsPeriod) {
                this.indicators.bbands = this.calculateBB(closes, candleTimes, bbandsPeriod, 2);
                this.chartManager.drawBollingerBands(this.indicators.bbands);
            } else { this.indicators.bbands = null; }

            const sma = (arr, n) => arr.length < n ? null : arr.slice(-n).reduce((a,b)=>a+b,0)/n;
            this.indicators.sma20 = sma(closes, 20);
            this.indicators.sma50 = sma(closes, 50);
            this.indicators.volSma20 = sma(volumes, 20);

            let cumPV = 0, cumV = 0;
            for (const k of this.candles) { const tp = (k.high + k.low + k.close)/3; cumPV += tp * k.volume; cumV += k.volume; }
            this.indicators.vwap = cumV ? (cumPV / cumV) : null;

            this.indicators.adx = this.calcADX(this.candles, atrPeriod);
            const adx = this.indicators.adx;
            if (adx) {
                if (adx.adx > 25) this.marketRegime = 'trend';
                else if (adx.adx < 20) this.marketRegime = 'range';
                else this.marketRegime = 'transition';
            } else { this.marketRegime = 'unknown'; }
        }


        calculateRSI(prices, period) {
            let gains = 0; let losses = 0;
            const rsi = [];
            let prevAvgGain = 0;
            let prevAvgLoss = 0;

            if (prices.length < period + 1) return [];

            for (let i = 1; i <= period; i++) {
                const diff = prices[i] - prices[i - 1];
                if (diff > 0) gains += diff; else losses -= diff;
            }
            prevAvgGain = gains / period;
            prevAvgLoss = losses / period;
            const initialRs = prevAvgLoss === 0 ? Infinity : prevAvgGain / prevAvgLoss;
            rsi.push(100 - (100 / (1 + initialRs))); 

            for (let i = period + 1; i < prices.length; i++) {
                const diff = prices[i] - prices[i - 1];
                const gain = diff > 0 ? diff : 0;
                const loss = diff < 0 ? -diff : 0;
                
                prevAvgGain = (prevAvgGain * (period - 1) + gain) / period;
                prevAvgLoss = (prevAvgLoss * (period - 1) + loss) / period;
                
                const rs = prevAvgLoss === 0 ? Infinity : prevAvgGain / prevAvgLoss;
                const rsiValue = 100 - (100 / (1 + rs));
                rsi.push(rsiValue);
            }
            return rsi;
        }

        calculateATR(candles, period) {
            if (candles.length < period + 1) return null;
            let trs = [];
            for (let i = 1; i < candles.length; i++) {
                const c = candles[i], p = candles[i - 1];
                trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
            }
            if (trs.length < period) return null;
            
            let atr = trs.slice(0, period).reduce((a, b) => a + b, 0) / period;

            for (let i = period; i < trs.length; i++) {
                atr = (atr * (period - 1) + trs[i]) / period;
            }
            return atr;
        }

              calculateBB(prices, times, period, stdDev) {
            const result = { upper: [], middle: [], lower: [] };
            if (prices.length < period) return null;

            for (let i = period - 1; i < prices.length; i++) {
                const slice = prices.slice(i - period + 1, i + 1);
                const sma = slice.reduce((a, b) => a + b, 0) / period;
                const std = Math.sqrt(
                    slice.map(p => Math.pow(p - sma, 2)).reduce((a, b) => a + b, 0) / period
                );
                result.middle.push({ time: times[i], value: sma });
                result.upper.push({ time: times[i], value: sma + (std * stdDev) });
                result.lower.push({ time: times[i], value: sma - (std * stdDev) });
            }
            return result;
        }



        calcADX(candles, period = 14) {
            if (!candles || candles.length < period * 2) return null; 
            const trs = [], plusDMs = [], minusDMs = [];
            for (let i = 1; i < candles.length; i++) {
                const c = candles[i], p = candles[i-1];
                trs.push(Math.max(c.high - c.low, Math.abs(c.high - p.close), Math.abs(c.low - p.close)));
                const upMove = c.high - p.high;
                const downMove = p.low - c.low;
                plusDMs.push((upMove > downMove && upMove > 0) ? upMove : 0);
                minusDMs.push((downMove > upMove && downMove > 0) ? downMove : 0);
            }
            const smooth = (arr) => {
                const smoothed = [arr.slice(0, period).reduce((a, b) => a + b, 0) / period];
                for (let i = period; i < arr.length; i++) {
                    smoothed.push((smoothed[smoothed.length - 1] * (period - 1) + arr[i]) / period);
                }
                return smoothed;
            };
            const sTR = smooth(trs);
            const sPlusDM = smooth(plusDMs);
            const sMinusDM = smooth(minusDMs);

            if (sTR.length === 0 || sPlusDM.length === 0 || sMinusDM.length === 0) return null;

            const plusDIs = sPlusDM.map((val, idx) => 100 * (val / (sTR[idx] || 1e-8)));
            const minusDIs = sMinusDM.map((val, idx) => 100 * (val / (sTR[idx] || 1e-8)));
            
            const dxs = plusDIs.map((pdi, idx) => 100 * Math.abs(pdi - minusDIs[idx]) / ((pdi + minusDIs[idx]) || 1e-8));
            
            if (dxs.length < period) return null;

            const adxValues = smooth(dxs.slice(period - 1));
            
            if (!adxValues || adxValues.length === 0) return null;
            return {
                adx: adxValues[adxValues.length-1],
                pdi: plusDIs[plusDIs.length-1],
                mdi: minusDIs[minusDIs.length-1]
            };
        }

        getOrderBookSnapshotInfo() {
            const ob = this.orderBook;
            if (!ob || !ob.bids || ob.bids.length === 0 || !ob.asks || ob.asks.length === 0) return null;
            const bestBid = ob.bids[0][0], bestAsk = ob.asks[0][0];
            const mid = (bestAsk + bestBid)/2;
            const spreadPct = (bestAsk - bestBid) / mid;
            const topN = this.settings.optimization.gating.topN || 5;
            const sumUsd = (levels) => levels.slice(0, topN).reduce((s,[p,q])=> s + (p*q), 0);
            const topBidUsd = sumUsd(ob.bids);
            const topAskUsd = sumUsd(ob.asks);
            const minTopUsd = Math.min(topBidUsd, topAskUsd);
            return { spreadPct, minTopUsd };
        }
        marketGatingPenalty(direction) {
            const info = this.getOrderBookSnapshotInfo();
            if (!info || !this.settings.optimization.gating.enabled) return 0;
            const g = this.settings.optimization.gating;
            let penalty = 0;
            if (info.spreadPct > g.spreadMaxPct) penalty += 1.5; 
            if (info.minTopUsd < g.minDepthUsd) penalty += 1.5; 
            return penalty;
        }

        getEffectiveThreshold() { return (this.settings.confluenceThreshold || 3) + (this.runtimeThresholdOffset || 0); }

        calculateDynamicTpSl(signal) {
            const atr = this.indicators.atr;
            let rrRatioBase = this.settings.params.rrRatio;
            const minTh = this.getEffectiveThreshold();
            const over = Math.max(0, (signal.score - minTh));
            rrRatioBase *= (1 + Math.min(0.3, over / 10)); 

            if (this.marketRegime === 'trend') rrRatioBase *= 1.1;
            if (this.marketRegime === 'range') rrRatioBase *= 0.95;

            if (!atr || atr === 0) { 
                signal.tp = signal.direction === 'buy' ? signal.price * (1 + 0.005) : signal.price * (1 - 0.005);
                signal.sl = signal.direction === 'buy' ? signal.price * (1 - 0.005 / rrRatioBase) : signal.price * (1 + 0.005 / rrRatioBase);
            } else {
                const atrMultiplier = 1.5 - (Math.min(10, Math.max(0, signal.score)) / 20);
                const slDistance = atr * atrMultiplier;
                const tpDistance = slDistance * rrRatioBase;
                if (signal.direction === 'buy') { signal.sl = signal.price - slDistance; signal.tp = signal.price + tpDistance; }
                else { signal.sl = signal.price + slDistance; signal.tp = signal.price - tpDistance; }
                signal.entrySlDistance = slDistance;
                signal.entryTpDistance = tpDistance;
            }
        }

        manageOpenPositions() {
            if (!this.isRunning || !this.marketData.price || !this.settings.optimization.breakeven.enabled) return;
            const price = this.marketData.price;
            const atr = this.indicators.atr;
            if (!atr) return; 

            let changed = false;
            const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
            for (const s of activeSignals) {
                if (!s.entrySlDistance || s.entrySlDistance <= 0) continue; 
                const rNow = s.direction === 'buy' ? (price - s.price) / s.entrySlDistance : (s.price - price) / s.entrySlDistance;
                s.mfeR = Math.max(s.mfeR || 0, rNow); 
                const settings = this.settings.optimization.breakeven;

                if (!s.beDone && s.mfeR >= (settings.beAtR || 0.8)) {
                    s.sl = s.price; 
                    s.beDone = true;
                    s.note = (s.note ? s.note + ' | ' : '') + 'SL->BE';
                    changed = true;
                    this.showNotification(`Sinyal ${s.id.substring(4,10)} için SL maliyete çekildi.`, 'info');
                }
                if (s.mfeR >= (settings.trailAfterR || 1.5) && (s.trailingStage || 0) < 1) {
                    let newSl;
                    if (s.direction === 'buy') {
                        newSl = price - (atr * settings.trailToR); 
                        s.sl = Math.min(s.tp, Math.max(s.sl, newSl)); 
                    } else { 
                        newSl = price + (atr * settings.trailToR); 
                        s.sl = Math.max(s.tp, Math.min(s.sl, newSl)); 
                    }
                    s.trailingStage = 1;
                    s.note = (s.note ? s.note + ' | ' : '') + 'Trail1';
                    changed = true;
                    this.showNotification(`Sinyal ${s.id.substring(4,10)} için SL güncellendi (Trailing).`, 'info');
                }
            }
            if (changed) { this.saveData('utc_signals', this.signals); this.debouncedRender(); }
        }

        checkAutoCloseSignals() {
            if (!this.isRunning || !this.marketData.price) return;
            const price = this.marketData.price;
            const activeSignals = this.signals.filter(s => s.status === 'active' && s.symbol === this.currentSymbol);
            for (const s of activeSignals) {
                if (s.direction === 'buy') {
                    if (price >= s.tp) { this.updateSignalResult(s.id, 'tp'); }
                    else if (price <= s.sl) { this.updateSignalResult(s.id, 'sl'); }
                } else if (s.direction === 'sell') {
                    if (price <= s.tp) { this.updateSignalResult(s.id, 'tp'); }
                    else if (price >= s.sl) { this.updateSignalResult(s.id, 'sl'); }
                }
            }
        }

        render() { 
            this.renderPriceDisplay(); 
            this.updateSignalProgressBar(); 
        }
        renderPriceDisplay() {
            const priceEl = document.getElementById('current-price');
            const tickerPriceEl = document.getElementById('ticker-bar-price');
            const oldPriceText = tickerPriceEl ? tickerPriceEl.textContent.replace(/,/g, '') : '0';
            const oldPrice = parseFloat(oldPriceText);
            
            if (this.marketData.price) {
                const formattedPrice = this.formatPrice(this.marketData.price);
                if (priceEl) priceEl.textContent = formattedPrice;
                if(tickerPriceEl) tickerPriceEl.textContent = formattedPrice;

                if (!isNaN(oldPrice) && oldPrice !== 0) { 
                    const color = this.marketData.price > oldPrice ? 'var(--positive)' : (this.marketData.price < oldPrice ? 'var(--negative)' : '');
                    if (tickerPriceEl) {
                        tickerPriceEl.style.transition = 'none';
                        tickerPriceEl.style.color = color;
                        setTimeout(() => {
                           tickerPriceEl.style.transition = 'color 0.5s ease';
                           tickerPriceEl.style.color = '';
                        }, 100);
                    }
                }
            }
            const change = this.marketData.change24h || 0;
            const changeEl = document.getElementById('price-change-24h');
            if (changeEl) { changeEl.textContent = `${change.toFixed(2)}%`; changeEl.style.color = change >= 0 ? 'var(--positive)' : 'var(--negative)'; }
            const volumeEl = document.getElementById('volume-24h'); if(volumeEl) volumeEl.textContent = this.formatVolume(this.marketData.volume24h);
            const atrEl = document.getElementById('atr-value'); if(atrEl) atrEl.textContent = this.indicators.atr ? this.indicators.atr.toFixed(this.getDecimalPlaces(this.indicators.atr)) : '-';
        }

        updateCandleCountdown() {
            const headerCountdownEl = document.getElementById('candle-countdown');
            const chartCountdownEl = document.getElementById('chart-countdown-overlay');

            if (!this.isRunning || this.candles.length === 0) {
                headerCountdownEl.textContent = '--:--';
                chartCountdownEl.textContent = '--:--';
                return;
            }
            const now = Date.now();
            const lastCandleOpenTime = this.candles[this.candles.length - 1].time; 
            const timeframeMs = this._timeframeToMs(this.currentTimeframe);
            
            const nextCandleOpenTime = lastCandleOpenTime + timeframeMs;
            let remainingTime = nextCandleOpenTime - now;
            
            if (remainingTime < 0 || remainingTime > timeframeMs) {
                 remainingTime = timeframeMs - (now % timeframeMs);
            }

            remainingTime = Math.max(0, remainingTime); 
            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);
            const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            headerCountdownEl.textContent = formattedTime;
            if (this.currentMainView === 'chart' || document.body.classList.contains('fullscreen-chart')) {
                chartCountdownEl.textContent = formattedTime;
                chartCountdownEl.classList.remove('hidden-view');
            } else {
                chartCountdownEl.classList.add('hidden-view');
            }
        }
         _timeframeToMs(tf) {
            const unit = tf.slice(-1);
            const val = parseInt(tf.slice(0, -1));
            if (unit === 'm') return val * 60 * 1000;
            if (unit === 'h') return val * 60 * 60 * 1000;
            if (unit === 'd') return val * 24 * 60 * 60 * 1000;
            return 60000;
        }

        updateSignalProgressBar() {
            const buyFill = document.getElementById('buy-signal-bar-fill');
            const sellFill = document.getElementById('sell-signal-bar-fill');
            const buyScoreText = document.getElementById('buy-signal-score-text');
            const sellScoreText = document.getElementById('sell-signal-score-text');
            if (!buyFill || !sellFill || !buyScoreText || !sellScoreText) return;

            const maxScoreForDisplay = 10; 
            const buyScore = this.confluenceEngine.buyScore || 0;
            const sellScore = this.confluenceEngine.sellScore || 0;

            const buyPercent = Math.min(100, Math.max(0, (buyScore / maxScoreForDisplay) * 100));
            const sellPercent = Math.min(100, Math.max(0, (sellScore / maxScoreForDisplay) * 100));

            buyFill.style.width = `${buyPercent}%`;
            sellFill.style.width = `${sellPercent}%`;

            buyScoreText.textContent = isFinite(buyScore) ? buyScore.toFixed(1) : '0.0';
            sellScoreText.textContent = isFinite(sellScore) ? sellScore.toFixed(1) : '0.0';
        }

        addPendingSignal(signal) {
            this.pendingSignals.push(signal);
            this.chartManager.addSignalMarker(signal);
            this.showNotification(`ADAY SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${signal.score.toFixed(1)}. Mum kapanışı bekleniyor.`, 'warning', 4000);
        }

        checkPendingSignals(closedCandle) {
            const signalsToActivate = [];
            this.pendingSignals = this.pendingSignals.filter(signal => {
                if (signal.timestamp < closedCandle.time) {
                    let isValid = false;
                    if (signal.direction === 'buy' && closedCandle.close > closedCandle.open) {
                        isValid = true;
                    } else if (signal.direction === 'sell' && closedCandle.close < closedCandle.open) {
                        isValid = true;
                    }
                    
                    if (isValid) {
                        signalsToActivate.push(signal);
                    } else {
                        this.showNotification(`İPTAL: ${signal.direction.toUpperCase()} sinyali mum kapanışında onaylanmadı.`, 'danger', 3000);
                    }
                    return false;
                }
                return true;
            });
            signalsToActivate.forEach(signal => this.activateSignal(signal));
        }

        activateSignal(signal) {
            signal.status = 'active';
            this.signals.unshift(signal); 
            if (this.signals.length > 200) this.signals.pop();
            this.saveData('utc_signals', this.signals);
            this.debouncedRender();
            this.chartManager.addSignalMarker(signal);
            
            let sizeText = signal.recommendedSize ? ` | Boyut: ${signal.recommendedSize}` : '';
            this.showNotification(`AKTİF SİNYAL: ${signal.direction.toUpperCase()} ${signal.symbol.replace('USDT', '/USDT')} | Skor: ${signal.score.toFixed(1)}${sizeText}`, signal.direction === 'buy' ? 'success' : 'danger');
            
            playSignal(signal.direction); 
            const messageKey = signal.direction === 'buy' ? 'buy' : 'sell';
            const message = this.getRandomMessage(messageKey, { 
                Sembol: signal.symbol.replace('USDT', ''), 
                Skor: signal.score.toFixed(1) 
            });
            this.speak(message);
            if (signal.score >= 8 && !this.combatModeActive) { this.activateCombatMode(); } 
        }

        getRecommendedPositionSize(score) {
            if(!this.settings.features.enableDynamicSizing) return null;
            if (score >= 7.5) return "2.0x Yüksek";
            if (score >= 6.0) return "1.5x Orta-Yüksek";
            if (score >= 4.5) return "1.0x Standart";
            return "0.5x Düşük";
        }

        updateSignalResult(signalId, result) {
            const signalIndex = this.signals.findIndex(s => s.id === signalId);
            if(signalIndex !== -1 && this.signals[signalIndex].status === 'active') {
                const signal = this.signals[signalIndex];
                signal.status = result;
                this.stats.total++;
                this.stats[result]++;
                
                this.updateStrategyStats(signal);
                this.updateStrategyShadowStats(signal);
                this.evaluateShadowRehab();

                if (this.settings.features.enableCUSUMDrift) {
                    const driftDetected = this.cusumDetector.update(result === 'tp');
                    if (driftDetected) {
                        this.showNotification('PERFORMANS SAPMASI!', 'Sinyal kazanma oranında sapma tespit edildi. Ayarlar optimize ediliyor...', 'warning');
                        this.speak(this.getRandomMessage('cusumDriftDetected'));
                    }
                }

                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.debouncedRender();
                this.showNotification(`Sinyal ${signal.id.substring(4,10)} - ${result.toUpperCase()} olarak sonuçlandı.`, 'info');
                const messageKey = result === 'tp' ? 'signalTP' : 'signalSL';
                this.speak(this.getRandomMessage(messageKey));
            }
        }

        updateStrategyStats(signal) {
            const isWin = signal.status === 'tp';
            const contributors = signal.contributors || [];
            if(contributors.length === 0) return;
            const totalEff = contributors.reduce((s, c) => s + (c.effScore || (c.baseScore * (c.weight||1))), 0) || 1;
            const decay = 0.995; 

            for (const c of contributors) {
                let stratStats = this.strategyStats[c.strategy];
                if (!stratStats) {
                    stratStats = this.initDefaultStrategyStats()[c.strategy];
                    this.strategyStats[c.strategy] = stratStats;
                }
                
                const updateStat = (statObj) => {
                    statObj.alpha = (statObj.alpha || 3) * decay; 
                    statObj.beta = (statObj.beta || 2) * decay;   
                    const credit = (c.effScore || (c.baseScore * (c.weight || 1))) / totalEff; 
                    statObj.contrib = (statObj.contrib || 0) + 1;
                    if (isWin) { statObj.wins = (statObj.wins || 0) + credit; statObj.alpha += credit; }
                    else { statObj.losses = (statObj.losses || 0) + credit; statObj.beta += credit; }
                    statObj.lastUpdate = Date.now();
                };

                updateStat(stratStats.overall);
                const currentRegimeStats = stratStats[this.marketRegime];
                if (currentRegimeStats) {
                    updateStat(currentRegimeStats);
                }
            }
            this.saveStrategyStats();
        }

        recordShadowProposal(strategy, direction, reason, score) {
            const now = Date.now();
            this.shadowProposals.push({ strategy, direction, reason, score, timestamp: now });
            if (this.shadowProposals.length > 2000) this.shadowProposals.splice(1500); 
        }

        updateStrategyShadowStats(signal) {
            const windowMs = (this.settings.cooldowns?.proposalTimeoutMs || 3000) * 2;
            const start = signal.timestamp - windowMs;
            const end = signal.timestamp;
            const creditBase = 0.5;

            const byStrat = {};
            for (const p of this.shadowProposals) {
                if (p.timestamp >= start && p.timestamp <= end && p.direction === signal.direction) {
                    byStrat[p.strategy] = p;
                }
            }
            for (const strat of Object.keys(byStrat)) {
                let stratStats = this.strategyStats[strat];
                if (!stratStats) {
                    stratStats = this.initDefaultStrategyStats()[strat];
                    this.strategyStats[strat] = stratStats;
                }
                
                const updateStat = (statObj) => {
                    statObj.shadowProposals = (statObj.shadowProposals || 0) + 1;
                    if (signal.status === 'tp') {
                        statObj.shadowWins = (statObj.shadowWins || 0) + 1;
                        statObj.alpha = (statObj.alpha || 3) + creditBase;
                    } else if (signal.status === 'sl') {
                        statObj.shadowLosses = (statObj.shadowLosses || 0) + 1;
                        statObj.beta = (statObj.beta || 2) + creditBase;
                    }
                    statObj.lastUpdate = Date.now();
                };
                
                updateStat(stratStats.overall);
                const currentRegimeStats = stratStats[this.marketRegime];
                if (currentRegimeStats) {
                    updateStat(currentRegimeStats);
                }
            }
            const keepAfter = Date.now() - 10 * 60 * 1000;
            this.shadowProposals = this.shadowProposals.filter(p => p.timestamp >= keepAfter);
            this.saveStrategyStats();
        }

                evaluateShadowRehab() {
            const pen = this.settings.penalties || {};
            if (!pen.shadowEnabled) return;

            for (const key of this.allStrategyKeys) {
                if (!this.settings.statusMaps.shadowBanned[key] || this.settings.statusMaps.hardBanned[key]) continue;

                const st = this.strategyStats[key]?.overall || {};
                const sw = st.shadowWins || 0,
                    sl = st.shadowLosses || 0,
                    sp = st.shadowProposals || 0;
                const total = sw + sl;
                const winRate = total > 0 ? sw / total : 0;

                if (sp >= (pen.minShadowProposals || 20) && winRate >= (pen.rehabWinRate || 0.58)) {
                    this.settings.activeStrategies[key] = true;
                    this.settings.statusMaps.shadowBanned[key] = false;
                    this.updateActiveStrategies();
                    this.saveSettings();
                    this.showNotification(`Rehabilite: ${this.strategies[key].displayName} tekrar canlı! (gölge WR=${(winRate*100).toFixed(0)}%)`, 'success');
                    
                    // --- EKSİK OLAN SATIR BURAYA EKLENDİ ---
                    this.speak(this.getRandomMessage('shadowRehab', { 'Strateji': this.strategies[key].displayName }));
                }
            }
        }


                autoToggleStrategies() {
            if (!this.settings.optimization.enabled || !this.settings.optimization.autoToggle) return;
            const now = Date.now();
            if (now - this.lastAutoToggleTs < 5 * 60 * 1000) return;
            this.lastAutoToggleTs = now;
            const minW = this.settings.optimization.minWeightToStay || 0.6;
            const minContrib = this.settings.optimization.minContribForToggle || 30;

            let changed = false;
            for (const key of this.allStrategyKeys) {
                const w = this.getStrategyWeight(key);
                const stat = this.strategyStats[key]?.overall || {};
                const active = !!this.settings.activeStrategies[key];

                if (active && !this.settings.statusMaps.hardBanned[key] && w < minW && (stat.contrib || 0) >= minContrib) {
                    this.settings.activeStrategies[key] = false;
                    this.settings.statusMaps.shadowBanned[key] = true;
                    this.showNotification(`Oto-optimizasyon: ${this.strategies[key].displayName} gölgeye alındı (w=${w.toFixed(2)}).`, 'warning');
                    
                    // --- EKSİK OLAN SATIR BURAYA EKLENDİ ---
                    this.speak(this.getRandomMessage('shadowBan', { 'Strateji': this.strategies[key].displayName }));
                    
                    changed = true;
                }
            }
            if (changed) {
                this.updateActiveStrategies();
                this.saveSettings();
                this.updateSettingsModalUI();
            }
        }


        autoTuneCooldowns() {
            if (!this.isRunning || !this.settings.optimization.enabled) return;
            const now = Date.now();
            const WINDOW_MS = 5 * 60 * 1000; 
            const recentSignals = this.signals.filter(s => s.status !== 'active' && s.symbol === this.currentSymbol && now - s.timestamp <= WINDOW_MS).slice(0, 50).sort((a,b)=> a.timestamp - b.timestamp);
            let quickFlips = 0, totalPairs = 0;
            if (recentSignals.length >= 2) {
                for (let i = 1; i < recentSignals.length; i++) {
                    totalPairs++;
                    const dt = recentSignals[i].timestamp - recentSignals[i-1].timestamp;
                    if (recentSignals[i-1].direction !== recentSignals[i].direction && dt <= 15000) { 
                        quickFlips++;
                    }
                }
            }
            const flipRatio = totalPairs ? (quickFlips / totalPairs) : 0;
            const volPct = (this.indicators.atr && this.marketData.price) ? (this.indicators.atr / this.marketData.price) : 0.001;

            const cd = this.settings.cooldowns;
            const baseSame = this.loadSettings().cooldowns.sameDirectionMs;
            const baseOpp = this.loadSettings().cooldowns.oppositeDirectionMs;
            const baseSignal = this.loadSettings().cooldowns.signalMs;
            const baseProposalTimeout = this.loadSettings().cooldowns.proposalTimeoutMs;

            const newSame = Math.max(10000, Math.min(120000, Math.round(baseSame * (1 + flipRatio * 0.8))));
            const newOpp  = Math.max(5000, Math.min(120000, Math.round(baseOpp  * (1 + flipRatio * 1.2))));
            const volFactor = volPct < 0.005 ? 1.2 : (volPct > 0.02 ? 0.8 : 1.0);
            const newSignal = Math.max(3000, Math.min(60000, Math.round(baseSignal * volFactor)));
            const newProposalTimeout = Math.max(1500, Math.min(8000, Math.round(baseProposalTimeout * volFactor)));

            let changed = false;
            if (Math.abs(newSame - cd.sameDirectionMs) / cd.sameDirectionMs > 0.05) { cd.sameDirectionMs = newSame; changed = true; }
            if (Math.abs(newOpp - cd.oppositeDirectionMs) / cd.oppositeDirectionMs > 0.05) { cd.oppositeDirectionMs = newOpp; changed = true; }
            if (Math.abs(newSignal - cd.signalMs) / cd.signalMs > 0.05) { cd.signalMs = newSignal; changed = true; }
            if (Math.abs(newProposalTimeout - cd.proposalTimeoutMs) / cd.proposalTimeoutMs > 0.05) { cd.proposalTimeoutMs = newProposalTimeout; changed = true; }

            if (changed) {
                this.saveSettings();
                this.updateSettingsModalUI(); 
                this.showNotification(`Cooldown optimize edildi (flip: ${(flipRatio*100).toFixed(0)}%, vol: ${(volPct*100).toFixed(2)}%).`, 'info');
                this.speak(this.getRandomMessage('cooldownOptimize'));
            }
        }

        autoTuneThresholds() {
            if (!this.isRunning || !this.settings.optimization.enabled) return;
            const now = Date.now();
            const WINDOW_MS = 10 * 60 * 1000;
            const recentSignals = this.signals.filter(s => s.status !== 'active' && s.symbol === this.currentSymbol && now - s.timestamp <= WINDOW_MS).slice(0, 100);
            
            let winRate = recentSignals.length > 5 ? (recentSignals.filter(s => s.status === 'tp').length / recentSignals.length) : 0.55;
            let currentOffset = this.runtimeThresholdOffset || 0;
            let newOffset = currentOffset;

            if (winRate < 0.50) newOffset += 0.1;
            else if (winRate > 0.65) newOffset -= 0.1;
            
            newOffset = Math.max(-1.0, Math.min(2.0, newOffset));

            if (Math.abs(newOffset - currentOffset) > 0.05) {
                this.runtimeThresholdOffset = parseFloat(newOffset.toFixed(1));
                this.showNotification(`Sinyal eşiği optimize edildi: Yeni Ofset ${this.runtimeThresholdOffset.toFixed(1)} (WR: ${(winRate*100).toFixed(1)}%).`, 'info');
            }
        }

        autoTuneStrategyParams() {
            if (!this.settings.optimization.enabled) return;
            const step = 0.05;
            const meta = {
                wallBounce: { DISTANCE_THRESHOLD_PERCENT: {min:0.0001,max:0.001, strict:'down'} },
                velocityScalping: { VELOCITY_THRESHOLD_PERCENT:{min:0.0005,max:0.003, strict:'up'} },
                liquidityGaps: { GAP_THRESHOLD_PERCENT:{min:0.0003,max:0.003, strict:'up'} },
                breakoutPattern: { BREAK_PCT:{min:0.0001,max:0.001, strict:'up'}, VOL_SPIKE:{min:1.0,max:3.0, strict:'up'} },
                supportResistance: { THRESH:{min:0.0005,max:0.005, strict:'down'} },
                fibonacciRetracement: { TOL:{min:0.0005,max:0.005, strict:'down'} },
                vwapReversion: { MULT:{min:0.6,max:2.0, strict:'up'} },
                superTrend: { MULT:{min:1.0,max:6.0, strict:'up'} },
                marketStructure: { SWING:{min:2,max:7, strict:'up'} },
                institutionalOrderFlow: { IMB_THRESHOLD:{min:1.2,max:4.0, strict:'up'} },
                microSpreadArbitrage: { SPREAD_PCT:{min:0.0003,max:0.003, strict:'up'} },
                volumeProfile: { PERIOD: 20, SPIKE: 2.0, CLOSE_POS: 0.7 },
                divergenceDetection: { SWING_PERIOD:{min:2,max:5, strict:'up'} },
                volatilityBreakout: { SQUEEZE_MULT: {min:0.5,max:2.0, strict:'up'}, BREAKOUT_VOL_MULT: {min:1.0,max:3.0, strict:'up'} },
                candleCharacter: { MIN_BODY_TO_WICK_RATIO: {min:0.4,max:0.8, strict:'up'}, ANALYSIS_WINDOW_PERCENT: {min:0.1,max:0.3, strict:'down'} },
                fundingRateReversal: { EXTREME_FUNDING_THRESHOLD: {min:0.0005,max:0.002, strict:'up'} }
            };

            const p = this.settings.strategyParams;
            let changed = false;

            for (const key of Object.keys(this.strategies)) {
                const w = this.getStrategyWeight(key);
                const defs = meta[key]; if (!defs) continue;
                const currentParams = p[key] || {}; 
                let localChanged = false;
                const direction = (w < 0.7) ? 'moreStrict' : (w > 1.3 ? 'lessStrict' : 'keep');
                if (direction === 'keep') continue;

                for (const par of Object.keys(defs)) {
                    const conf = defs[par]; 
                    const val = currentParams[par] ?? this.strategies[key][par];
                    if (val == null) continue;

                    let newVal = val;
                    if (direction === 'moreStrict') {
                        if (conf.strict === 'up') newVal = val * (1 + step);
                        else if (conf.strict === 'down') newVal = val * (1 - step);
                    } else if (direction === 'lessStrict') {
                        if (conf.strict === 'up') newVal = val * (1 - step);
                        else if (conf.strict === 'down') newVal = val * (1 + step);
                    }
                    newVal = Math.max(conf.min, Math.min(conf.max, newVal));
                    
                    if (Math.abs(newVal - val) / Math.max(1e-8, val) > 0.001) {
                        currentParams[par] = Number.isInteger(val) ? Math.round(newVal) : parseFloat(newVal.toPrecision(4));
                        localChanged = true;
                    }
                }
                if (localChanged) { 
                    p[key] = currentParams; 
                    changed = true; 
                }
            }

            if (changed) {
                this.saveSettings();
                this.applyStrategyParamOverrides();
                this.showNotification('Strateji parametreleri mikro-optimize edildi (ameliyat).', 'warning');
            }
        }

        // DÜZELTME: Render fonksiyonları debounce ile çağrılacak
        debouncedRender() {
            clearTimeout(this.renderTimeout);
            this.renderTimeout = setTimeout(() => {
                this.renderSignals(true);
                this.renderStats(true);
            }, 200);
        }

        renderSignals(fullRender = false) {
            const tbody = document.getElementById('modal-signals-body');
            if (!tbody) return;
            if (fullRender) tbody.innerHTML = '';
            
            const signalsToRender = this.signals;

            signalsToRender.forEach((signal, index) => {
                const rowId = `signal-row-${signal.id}`;
                let row = document.getElementById(rowId);
                if(fullRender || !row) { 
                    if (row) row.remove();
                    row = tbody.insertRow(fullRender ? -1 : 0); // Tam render ise sona, değilse başa ekle
                    row.id = rowId;
                    for(let i=0; i<11; i++) row.insertCell();
                }

                row.className = signal.status === 'tp' ? 'signal-tp' : (signal.status === 'sl' ? 'signal-sl' : (signal.status === 'pending' ? 'signal-pending' : ''));
                row.cells[0].textContent = new Date(signal.timestamp).toLocaleTimeString();
                row.cells[1].textContent = signal.symbol.replace('USDT', '');
                row.cells[2].textContent = signal.direction.toUpperCase();
                row.cells[3].textContent = this.formatPrice(signal.price);
                row.cells[4].textContent = signal.tp ? this.formatPrice(signal.tp) : '-';
                row.cells[5].textContent = signal.sl ? this.formatPrice(signal.sl) : '-';
                row.cells[6].textContent = typeof signal.score === 'number' ? signal.score.toFixed(1) : signal.score;
                row.cells[7].textContent = signal.reason;
                row.cells[8].textContent = signal.recommendedSize || '-';
                row.cells[9].textContent = signal.status.toUpperCase();
                row.cells[10].textContent = signal.note || '';
            });
        }

        renderStats() {
            const statsContainer = document.getElementById('modal-stats-container');
            if (!statsContainer) return;

            const total = this.stats.total;
            const tp = this.stats.tp;
            const winRate = total > 0 ? ((tp / total) * 100).toFixed(1) : '0.0';

            const getWR = (stat) => {
                if (!stat) return '-';
                const totalObs = (stat.wins || 0) + (stat.losses || 0);
                if (totalObs === 0) return '-';
                return (((stat.wins || 0) / totalObs) * 100).toFixed(0);
            };

            const renderRegimeStats = (regime) => {
                let regimeTotal = 0, regimeWins = 0;
                Object.values(this.strategyStats).forEach(s => {
                    const stat = s[regime]; 
                    if(stat && (stat.wins !== undefined || stat.losses !== undefined)) { 
                        regimeWins += (stat.wins || 0);
                        regimeTotal += ((stat.wins || 0) + (stat.losses || 0));
                    }
                });
                const wr = regimeTotal > 0 ? (regimeWins / regimeTotal * 100).toFixed(0) : 'N/A';
                return `<div class="stat-item"><span class="stat-label">${regime.charAt(0).toUpperCase() + regime.slice(1)} WR:</span><span class="stat-value">${wr}%</span></div>`;
            };

            const html = `
                <div class="panel-title" style="margin-bottom: 10px;">Genel Sinyal İstatistikleri</div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0 15px;">
                    <div class="stat-item"><span class="stat-label">Toplam Sinyal:</span><span class="stat-value">${total}</span></div>
                    <div class="stat-item"><span class="stat-label">TP (Kazanılan):</span><span class="stat-value" style="color:var(--positive);">${tp}</span></div>
                    <div class="stat-item"><span class="stat-label">SL (Kaybedilen):</span><span class="stat-value" style="color:var(--negative);">${this.stats.sl}</span></div>
                    <div class="stat-item"><span class="stat-label">Kazanma Oranı:</span><span class="stat-value" style="color:${winRate >= 50 ? 'var(--positive)' : 'var(--negative)'};">${winRate}%</span></div>
                    ${renderRegimeStats('trend')}
                    ${renderRegimeStats('range')}
                </div>
                <div class="panel-title" style="margin-top: 15px; margin-bottom: 10px;">Strateji Performansı (Rejime Göre)</div>
                <div class="data-table-container" style="max-height: 250px;">
                    <table class="data-table">
                        <thead><tr><th>Strateji</th><th>Ağırlık</th><th>Genel WR%</th><th>Trend WR%</th><th>Range WR%</th><th>Katkı</th></tr></thead>
                        <tbody>
                            ${Object.keys(this.strategyStats).sort((a,b) => this.getStrategyWeight(b) - this.getStrategyWeight(a)).map(key => {
                                const s = this.strategyStats[key]; 
                                if (!s) return ''; 
                                const overallWR = getWR(s.overall);
                                const trendWR = getWR(s.trend);
                                const rangeWR = getWR(s.range);
                                return `
                                    <tr>
                                        <td>${this.strategies[key]?.displayName || key}</td>
                                        <td>${this.getStrategyWeight(key).toFixed(2)}</td>
                                        <td style="color:${overallWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${overallWR}</td>
                                        <td style="color:${trendWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${trendWR}</td>
                                        <td style="color:${rangeWR >= 50 ? 'var(--positive)' : 'var(--negative)'}">${rangeWR}</td>
                                        <td>${(s.overall?.contrib || 0)}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            statsContainer.innerHTML = html;
        }

        clearAllSignals() {
            if (confirm('Tüm sinyal geçmişini temizlemek istediğinizden emin misiniz?')) {
                this.signals = [];
                this.pendingSignals = [];
                this.stats = { total: 0, tp: 0, sl: 0 };
                this.saveData('utc_signals', this.signals);
                this.saveData('utc_stats', this.stats);
                this.debouncedRender();
                this.chartManager.clearMarkers();
                this.showNotification('Sinyal geçmişi temizlendi!', 'info');
            }
        }
        clearChartMarkers() { this.chartManager.clearMarkers(); this.showNotification('Grafik sinyalleri temizlendi.', 'info'); }

        formatPrice(price) { return price.toLocaleString('en-US', { minimumFractionDigits: this.getDecimalPlaces(price), maximumFractionDigits: this.getDecimalPlaces(price) }); }
        formatVolume(volume) { if (volume >= 1e9) return (volume / 1e9).toFixed(2) + 'B'; if (volume >= 1e6) return (volume / 1e6).toFixed(2) + 'M'; if (volume >= 1e3) return (volume / 1e3).toFixed(2) + 'K'; return volume.toFixed(2); }
        getDecimalPlaces(price) { if (!price) return 2; if (price > 1000) return 2; if (price > 1) return 3; if (price > 0.01) return 4; return 6; }
        
        showNotification(message, type = 'info', timeout = 5000) {
            // Map traditional notification types to new categories
            let category = 'system';
            let priority = 2;
            
            switch(type) {
                case 'success':
                    category = 'success';
                    priority = 3;
                    break;
                case 'danger':
                    category = 'error';
                    priority = 4;
                    break;
                case 'warning':
                    category = 'alert';
                    priority = 3;
                    break;
                case 'info':
                    if (message.toLowerCase().includes('sinyal')) {
                        category = 'trade';
                        priority = 3;
                    }
                    break;
            }
            
            // Detect important notifications
            if (message.toLowerCase().includes('tehlike') || 
                message.toLowerCase().includes('kritik') ||
                message.toLowerCase().includes('uyarı') ||
                message.toLowerCase().includes('dikkat') ||
                message.toLowerCase().includes('durdur')) {
                priority = 4;
            }
            
            // Use the new notification center if available
            if (this.notificationCenter) {
                return this.notificationCenter.notify(message, category, priority, timeout);
            } else {
                // Legacy fallback
                const container = document.getElementById('notifications-container');
                if (!container) return;
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                container.appendChild(notification);
                setTimeout(() => { notification.remove(); }, timeout);
                return notification;
            }
        }
                logToJournal(message, level = 'log') {
            const timestamp = new Date().toLocaleTimeString();
            const formattedMessage = `[${timestamp}] ${message}`;
            console.log(formattedMessage); // Konsola yazdırmaya devam et

            const logOutput = document.getElementById('log-output');
            if (logOutput) {
                const logEntry = document.createElement('div');
                logEntry.textContent = formattedMessage;
                if (level === 'error') logEntry.className = 'log-error';
                if (level === 'warn') logEntry.className = 'log-warn';
                if (level === 'info') logEntry.className = 'log-info';
                
                const isScrolledToBottom = logOutput.scrollHeight - logOutput.clientHeight <= logOutput.scrollTop + 1;
                logOutput.appendChild(logEntry);
                if (isScrolledToBottom) {
                    logOutput.scrollTop = logOutput.scrollHeight;
                }
            }
        }
        // YENİ: Logları dışa aktarma fonksiyonu
        exportLogs() {
            const logOutput = document.getElementById('log-output');
            if (!logOutput || !logOutput.textContent.trim()) {
                this.showNotification('Dışa aktarılacak log bulunmuyor.', 'warning');
                return;
            }
            const blob = new Blob([logOutput.textContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `utc_logs_${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            this.showNotification('Loglar başarıyla dışa aktarıldı.', 'success');
        }

        updateConnectionStatus(isConnected, message = '') {
            const statusDot = document.getElementById('connection-status');
            const statusText = document.getElementById('connection-text');
            if (isConnected) {
                statusDot.classList.add('online');
                statusText.textContent = 'BAĞLI';
                statusText.style.color = 'var(--positive)';
            } else {
                statusDot.classList.remove('online');
                statusText.textContent = message || 'BAĞLANTI YOK';
                statusText.style.color = 'var(--negative)';
            }
        }

        updateSession() {
            this.sessionState = this.sessionProfiler.getCurrentSession();
        }

        activateCombatMode() {
            if (this.combatModeActive) return;
            this.combatModeActive = true;
            document.documentElement.setAttribute('data-theme', 'war');
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
            this.showNotification('SAVAŞ MODU AKTİF EDİLDİ!', 'danger');
            this.speak(this.getRandomMessage('combatModeActivate'));
            playSignal('combat');
        }

        deactivateCombatMode() {
            if (!this.combatModeActive) return;
            this.combatModeActive = false;
            const savedTheme = localStorage.getItem('utc_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            this.chartManager.updateTheme();
            this.heatmapManager.updateTheme();
            this.showNotification('SAVAŞ MODU DEVRE DIŞI BIRAKILDI.', 'success');
            this.speak(this.getRandomMessage('combatModeDeactivate'));
        }

        loadVoices() {
            this.voices = this.synth.getVoices();
            this.updateTTSVoiceSelectUI();
        }

        updateTTSVoiceSelectUI() {
            const selectEl = document.getElementById('modal-tts-voice-select');
            if (!selectEl) return;
            const currentVoice = this.settings.features.preferredVoiceName;
            selectEl.innerHTML = '<option value="">Otomatik Seç</option>';
            if (this.voices.length > 0) {
                 this.voices.forEach(voice => {
                    if (voice.lang.startsWith('tr')) {
                        const option = document.createElement('option');
                        option.value = voice.name;
                        option.textContent = `${voice.name} (${voice.lang})`;
                        if (currentVoice === voice.name) {
                            option.selected = true;
                        }
                        selectEl.appendChild(option);
                    }
                });
            }
        }
        getRandomMessage(key, replacements = {}) {
            const messages = this.speechTexts[key];
            if (!messages || messages.length === 0) {
                console.warn(`'${key}' için konuşma metni bulunamadı.`);
                return `Varsayılan mesaj: ${key}`;
            }
            let message = messages[Math.floor(Math.random() * messages.length)];

            for (const placeholder in replacements) {
                const regex = new RegExp(`\\[${placeholder}\\]`, 'g');
                message = message.replace(regex, replacements[placeholder]);
            }
            return message;
        }

        // DÜZELTME: TTS Kuyruk Mekanizması
        speak(text, options = {}) {
            if (!this.synth || !this.settings.features.enableTTS) return;
            this.speechQueue.push({ text, options });
            if (!this.isSpeaking) {
                this.processSpeechQueue();
            }
        }

        processSpeechQueue() {
            if (this.speechQueue.length === 0) {
                this.isSpeaking = false;
                return;
            }
            this.isSpeaking = true;
            const { text, options } = this.speechQueue.shift();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = options.rate || 1.1; 
            utterance.pitch = options.pitch || 1.0; 
            utterance.volume = options.volume || 0.8; 
            utterance.lang = options.lang || 'tr-TR'; 

            const preferredVoice = this.voices.find(v => v.name === this.settings.features.preferredVoiceName);
            if (preferredVoice) {
                utterance.voice = preferredVoice;
            } else {
                const turkishVoice = this.voices.find(v => v.lang.startsWith('tr-'));
                if (turkishVoice) utterance.voice = turkishVoice;
            }
            
            utterance.onend = () => {
                setTimeout(() => this.processSpeechQueue(), 300); // Sesler arası kısa bir bekleme
            };
            
            utterance.onerror = (event) => {
                console.error('SpeechSynthesis Hata:', event.error);
                this.isSpeaking = false; // Hata durumunda kuyruğu serbest bırak
                this.processSpeechQueue(); // Bir sonraki öğeyi dene
            };

            this.synth.speak(utterance);
        }

        openHonorModal(filter = 'all') {
            const el = document.getElementById('honor-modal-body');
            const honor = [], shame = [], banned = [];
            const minContrib = 10; 

            for (const key of this.allStrategyKeys) {
                const st = this.strategyStats[key]?.overall || {};
                const w = this.getStrategyWeight(key);
                const active = !!this.settings.activeStrategies[key];
                const isShadow = !!this.settings.statusMaps.shadowBanned[key];
                const isHard = !!this.settings.statusMaps.hardBanned[key];
                const contrib = (st.contrib || 0);
                const totalObs = (st.wins || 0) + (st.losses || 0);
                const wr = totalObs > 0 ? ((st.wins || 0) / totalObs * 100) : 0;

                const row = {
                    key, name: this.strategies[key]?.displayName || key, w, wr, contrib, status: isHard ? 'HARDBAN' : (isShadow ? 'GÖLGE' : (active ? 'CANLI' : 'PASİF'))
                };

                if (isHard || isShadow) banned.push(row);
                if (!isShadow && !isHard) {
                    if (w >= 1.1 && totalObs >= minContrib) honor.push(row);
                    else if (w <= 0.8 && totalObs >= minContrib) shame.push(row);
                }
            }
            
            const pickRogue = shame.sort((a,b) => a.w - b.w)[0];

            const renderList = (title, arr, empty = '-') => `
                <div class="panel-title" style="margin:6px 0;">${title}</div>
                <div class="data-table-container" style="max-height:240px;">
                <table class="data-table">
                    <thead><tr><th>Strateji</th><th>w</th><th>WR%</th><th>Katkı</th><th>Durum</th><th>Aksiyon</th></tr></thead>
                    <tbody>
                    ${arr.length ? arr.map(r => `
                        <tr>
                        <td>${r.name}</td><td>${r.w.toFixed(2)}</td><td>${r.wr.toFixed(0)}</td><td>${r.contrib}</td><td>${r.status}</td>
                        <td>
                            <button class="btn btn-tiny" onclick="window.app.toggleShadow('${r.key}')">${this.settings.statusMaps.shadowBanned[r.key] ? 'Gölgeden Al' : 'Gölgeye Al'}</button>
                            <button class="btn btn-tiny ${this.settings.statusMaps.hardBanned[r.key] ? 'btn-danger' : ''}" onclick="window.app.toggleHardBan('${r.key}')">${this.settings.statusMaps.hardBanned[r.key] ? 'Unban' : 'HardBan'}</button>
                        </td>
                        </tr>
                    `).join('') : `<tr><td colspan="6">${empty}</td></tr>`}
                    </tbody>
                </table></div>`;

            let html = '';
            if (filter === 'banned') {
                html += renderList('Banlılar (Gölge/HardBan)', banned, 'Kimse banlı değil.');
            } else {
                if (pickRogue) {
                    html += `<div class="notification danger" style="position:relative; margin-bottom:10px;">Günün şerefsizi: <b>${pickRogue.name}</b> (w=${pickRogue.w.toFixed(2)})</div>`;
                    this.speak(this.getRandomMessage('rogueOfDay', { 'Strateji': pickRogue.name }));
                }
                html += renderList('Şerefli (güçlüler)', honor.sort((a,b)=>b.w-a.w));
                html += renderList('Şerefsizler (zayıflar)', shame.sort((a,b)=>a.w-b.w));
                html += renderList('Banlılar (Gölge/HardBan)', banned);
            }

            el.innerHTML = html;
            document.getElementById('honor-modal-overlay').style.display = 'flex';
            this.lastHonorModalFilter = filter;
        }

        closeHonorModal() { document.getElementById('honor-modal-overlay').style.display = 'none'; }

        toggleShadow(key) {
            const cur = !!this.settings.statusMaps.shadowBanned[key];
            this.settings.statusMaps.shadowBanned[key] = !cur;
            if (cur) {
                if (!this.settings.statusMaps.hardBanned[key]) {
                    this.settings.activeStrategies[key] = true;
                }
            } else {
                this.settings.activeStrategies[key] = false;
            }
            this.updateActiveStrategies();
            this.saveSettings();
            this.openHonorModal(this.lastHonorModalFilter);
            this.showNotification(`${this.strategies[key].displayName} ${cur ? 'gölgeden alındı' : 'gölgeye alındı'}.`, 'info');
            this.speak(this.getRandomMessage(cur ? 'shadowRehab' : 'shadowBan', { 'Strateji': this.strategies[key].displayName }));
        }

        toggleHardBan(key) {
            const cur = !!this.settings.statusMaps.hardBanned[key];
            this.settings.statusMaps.hardBanned[key] = !cur;
            if (this.settings.statusMaps.hardBanned[key]) {
                this.settings.statusMaps.shadowBanned[key] = true;
                this.settings.activeStrategies[key] = false;
            } else {
                this.settings.statusMaps.shadowBanned[key] = false;
            }
            this.updateActiveStrategies();
            this.saveSettings();
            this.openHonorModal(this.lastHonorModalFilter);
            this.showNotification(`${this.strategies[key].displayName} ${cur ? 'hardbandan çıkarıldı' : 'hardban edildi'}.`, cur ? 'success' : 'danger');
        }

        // DÜZELTME: Performans izleme fonksiyonu
        startPerformanceMonitor() {
            this.performanceMonitorInterval = setInterval(() => {
                if (performance.memory) {
                    const memUsage = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
                    this.logToJournal(`Performans: Bellek=${memUsage}MB, Sinyaller=${this.signals.length}, Bekleyenler=${this.pendingSignals.length}`);
                }
            }, 30000);
        }
    }

    // Uygulamayı başlat
    window.app = new UltimateTradingCommandCenter();

    /* =================================================================
       PANTEON SISTEMI VE GÖRSEL EFEKTLER
       ================================================================= */
    /* =================================================================
       ADVANCED VISUALIZATION TOOLS
       ================================================================= */
    class AdvancedTradingVisualizer {
        constructor(app) {
            this.app = app;
            this.isInitialized = false;
            this.heatmapEnabled = false;
            this.volumeProfileEnabled = false;
            this.liquidityHeatmapEnabled = false;
            this.orderFlowEnabled = false;
            this.marketStructureVisualization = false;
            this.optionsOverlayEnabled = false;
            this.supportResistanceLevels = [];
            this.fibonacciLevels = [];
            this.pivotPoints = [];
            this.init();
        }
        
        init() {
            if (this.isInitialized) return;
            
            // Initialize visualization components
            this.addVisualizationButtons();
            
            // Create necessary canvas layers
            this.createAdditionalCanvasLayers();
            
            // Bind events
            this.bindEvents();
            
            this.isInitialized = true;
            console.log('Advanced Trading Visualization Tools initialized');
        }
        
        createAdditionalCanvasLayers() {
            // Create order flow canvas layer
            const orderFlowCanvas = document.createElement('canvas');
            orderFlowCanvas.id = 'order-flow-canvas';
            orderFlowCanvas.style.position = 'absolute';
            orderFlowCanvas.style.top = '0';
            orderFlowCanvas.style.left = '0';
            orderFlowCanvas.style.width = '100%';
            orderFlowCanvas.style.height = '100%';
            orderFlowCanvas.style.pointerEvents = 'none';
            orderFlowCanvas.style.display = 'none';
            orderFlowCanvas.style.zIndex = '5';
            
            // Create volume profile canvas
            const volumeProfileCanvas = document.createElement('canvas');
            volumeProfileCanvas.id = 'volume-profile-canvas';
            volumeProfileCanvas.style.position = 'absolute';
            volumeProfileCanvas.style.top = '0';
            volumeProfileCanvas.style.right = '0';
            volumeProfileCanvas.style.width = '80px';
            volumeProfileCanvas.style.height = '100%';
            volumeProfileCanvas.style.pointerEvents = 'none';
            volumeProfileCanvas.style.display = 'none';
            volumeProfileCanvas.style.zIndex = '6';
            
            // Add to chart container
            const chartContainer = document.getElementById('live-chart');
            if (chartContainer) {
                chartContainer.style.position = 'relative';
                chartContainer.appendChild(orderFlowCanvas);
                chartContainer.appendChild(volumeProfileCanvas);
            }
        }
        
        addVisualizationButtons() {
            // Create visualization controls container
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'visualization-controls';
            controlsContainer.style.position = 'absolute';
            controlsContainer.style.top = '50px';
            controlsContainer.style.right = '10px';
            controlsContainer.style.display = 'flex';
            controlsContainer.style.flexDirection = 'column';
            controlsContainer.style.gap = '5px';
            controlsContainer.style.zIndex = '100';
            
            // Add buttons
                        const buttons = [
                { id: 'toggle-heatmap-btn', icon: '🔥', title: 'Isı Haritası' },
                { id: 'toggle-volume-profile-btn', icon: '📊', title: 'Hacim Profili' },
                { id: 'toggle-liquidity-btn', icon: '💧', title: 'Likidite Görselleştirme' },
                { id: 'toggle-order-flow-btn', icon: '📈', title: 'Emir Akışı' },
                { id: 'toggle-market-structure-btn', icon: '🔍', title: 'Piyasa Yapısı' },
                { id: 'toggle-options-overlay-btn', icon: '🔄', title: 'Opsiyon Verileri' },
                { type: 'divider' }, // Ayırıcı
                { id: 'mobile-notification-history-btn', icon: '📋', title: 'Bildirim Geçmişi', mobileOnly: true },
                { id: 'mobile-clear-notifications', icon: '🗑️', title: 'Bildirimleri Temizle', mobileOnly: true },
                { id: 'mobile-toggle-notification-sound', icon: '🔊', title: 'Sesi Aç/Kapat', mobileOnly: true }
            ];
            
                        buttons.forEach(btnInfo => {
                if (btnInfo.type === 'divider') {
                    const divider = document.createElement('hr');
                    divider.className = 'mobile-only';
                    Object.assign(divider.style, {
                        borderColor: 'var(--border-color)', width: '80%', margin: '5px auto',
                        borderStyle: 'solid', borderWidth: '1px 0 0 0'
                    });
                    controlsContainer.appendChild(divider);
                    return;
                }

                const button = document.createElement('button');
                button.id = btnInfo.id;
                button.className = 'btn-tiny visualization-btn';
                if (btnInfo.mobileOnly) {
                    button.classList.add('mobile-only');
                }
                button.innerHTML = btnInfo.icon;
                button.title = btnInfo.title;
                Object.assign(button.style, {
                    width: '28px', height: '28px', padding: '2px', fontSize: '14px',
                    background: 'rgba(1, 4, 9, 0.7)', backdropFilter: 'blur(2px)',
                    border: '1px solid var(--border-color)', borderRadius: '4px',
                    color: 'var(--text-main)', cursor: 'pointer',
                    display: 'flex', alignItems: 'center', justifyContent: 'center'
                });
                controlsContainer.appendChild(button);
            });
            
            // Add to chart container
            const chartContainer = document.getElementById('live-chart');
            if (chartContainer) {
                chartContainer.style.position = 'relative';
                chartContainer.appendChild(controlsContainer);
            }
        }
        
        bindEvents() {
            // Bind click events to visualization buttons
            document.getElementById('toggle-heatmap-btn')?.addEventListener('click', () => this.toggleHeatmap());
            document.getElementById('toggle-volume-profile-btn')?.addEventListener('click', () => this.toggleVolumeProfile());
            document.getElementById('toggle-liquidity-btn')?.addEventListener('click', () => this.toggleLiquidityHeatmap());
            document.getElementById('toggle-order-flow-btn')?.addEventListener('click', () => this.toggleOrderFlow());
            document.getElementById('toggle-market-structure-btn')?.addEventListener('click', () => this.toggleMarketStructure());
            document.getElementById('toggle-options-overlay-btn')?.addEventListener('click', () => this.toggleOptionsOverlay());
            
            // Resize event
            window.addEventListener('resize', () => this.handleResize());
        }
        
        toggleHeatmap() {
            this.heatmapEnabled = !this.heatmapEnabled;
            document.getElementById('toggle-heatmap-btn')?.classList.toggle('active', this.heatmapEnabled);
            if (this.heatmapEnabled) {
                this.app.switchMainView('heatmap');
            } else {
                this.app.switchMainView('chart');
            }
        }
        
        toggleVolumeProfile() {
            this.volumeProfileEnabled = !this.volumeProfileEnabled;
            document.getElementById('toggle-volume-profile-btn')?.classList.toggle('active', this.volumeProfileEnabled);
            const volumeProfileCanvas = document.getElementById('volume-profile-canvas');
            if (volumeProfileCanvas) {
                volumeProfileCanvas.style.display = this.volumeProfileEnabled ? 'block' : 'none';
            }
            if (this.volumeProfileEnabled) {
                this.drawVolumeProfile();
            }
        }
        
        toggleLiquidityHeatmap() {
            this.liquidityHeatmapEnabled = !this.liquidityHeatmapEnabled;
            document.getElementById('toggle-liquidity-btn')?.classList.toggle('active', this.liquidityHeatmapEnabled);
            // Implementation of liquidity heatmap visualization
            if (this.liquidityHeatmapEnabled) {
                this.app.showNotification('Liquidity heatmap activated', 'info');
                this.analyzeLiquidity();
            }
        }
        
        toggleOrderFlow() {
            this.orderFlowEnabled = !this.orderFlowEnabled;
            document.getElementById('toggle-order-flow-btn')?.classList.toggle('active', this.orderFlowEnabled);
            const orderFlowCanvas = document.getElementById('order-flow-canvas');
            if (orderFlowCanvas) {
                orderFlowCanvas.style.display = this.orderFlowEnabled ? 'block' : 'none';
            }
            if (this.orderFlowEnabled) {
                this.drawOrderFlow();
            }
        }
        
        toggleMarketStructure() {
            this.marketStructureVisualization = !this.marketStructureVisualization;
            document.getElementById('toggle-market-structure-btn')?.classList.toggle('active', this.marketStructureVisualization);
            if (this.marketStructureVisualization) {
                this.app.showNotification('Market structure visualization activated', 'info');
                this.analyzeMarketStructure();
            } else {
                // Clear market structure markers
                if (this.app.chartManager && this.app.chartManager.chart) {
                    // Remove market structure lines
                }
            }
        }
        
        toggleOptionsOverlay() {
            this.optionsOverlayEnabled = !this.optionsOverlayEnabled;
            document.getElementById('toggle-options-overlay-btn')?.classList.toggle('active', this.optionsOverlayEnabled);
            if (this.optionsOverlayEnabled) {
                this.app.showNotification('Options data overlay activated', 'info');
                this.fetchOptionsData();
            }
        }
        
        handleResize() {
            if (this.volumeProfileEnabled) {
                this.drawVolumeProfile();
            }
            if (this.orderFlowEnabled) {
                this.drawOrderFlow();
            }
        }
        
        drawVolumeProfile() {
            const canvas = document.getElementById('volume-profile-canvas');
            if (!canvas || !this.app.candles || this.app.candles.length < 10) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Resize canvas to match its display size
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get price range from visible candles
            const candles = this.app.candles;
            const minPrice = Math.min(...candles.map(c => c.low));
            const maxPrice = Math.max(...candles.map(c => c.high));
            const priceRange = maxPrice - minPrice;
            
            // Calculate volume at different price levels
            const priceLevels = 40; // Number of price levels
            const volumeByPrice = new Array(priceLevels).fill(0);
            
            candles.forEach(candle => {
                const priceRange = candle.high - candle.low;
                if (priceRange === 0) return;
                
                // Distribute volume across price range
                for (let i = 0; i < priceLevels; i++) {
                    const levelPrice = minPrice + (i / priceLevels) * (maxPrice - minPrice);
                    if (levelPrice >= candle.low && levelPrice <= candle.high) {
                        // Weight by proximity to close price
                        const weight = 1 - Math.abs(levelPrice - candle.close) / priceRange;
                        volumeByPrice[i] += candle.volume * weight;
                    }
                }
            });
            
            // Find max volume for scaling
            const maxVolume = Math.max(...volumeByPrice);
            
            // Draw volume profile
            ctx.fillStyle = 'rgba(100, 100, 255, 0.5)';
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < priceLevels; i++) {
                const y = canvas.height - (i / priceLevels) * canvas.height;
                const volumeWidth = (volumeByPrice[i] / maxVolume) * canvas.width;
                
                ctx.fillRect(0, y, volumeWidth, canvas.height / priceLevels);
                ctx.strokeRect(0, y, volumeWidth, canvas.height / priceLevels);
            }
            
            // Draw POC (Point of Control) - highest volume level
            const pocIndex = volumeByPrice.indexOf(maxVolume);
            if (pocIndex >= 0) {
                const pocY = canvas.height - (pocIndex / priceLevels) * canvas.height;
                ctx.strokeStyle = 'rgba(255, 255, 0, 1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, pocY);
                ctx.lineTo(canvas.width, pocY);
                ctx.stroke();
            }
        }
        
        drawOrderFlow() {
            const canvas = document.getElementById('order-flow-canvas');
            if (!canvas || !this.app.aggTrades || this.app.aggTrades.length < 10) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Resize canvas to match its display size
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get recent trades
            const trades = this.app.aggTrades.slice(-50);
            if (trades.length === 0) return;
            
            // Draw trade flow
            let x = 50;
            const spacing = (canvas.width - 100) / trades.length;
            
            for (let i = 0; i < trades.length - 1; i++) {
                const trade = trades[i];
                const nextTrade = trades[i + 1];
                
                // Calculate y position based on price (normalized to canvas height)
                const minPrice = Math.min(...trades.map(t => t.price));
                const maxPrice = Math.max(...trades.map(t => t.price));
                const priceRange = maxPrice - minPrice;
                
                if (priceRange === 0) continue;
                
                const y1 = canvas.height - ((trade.price - minPrice) / priceRange) * (canvas.height - 40);
                const y2 = canvas.height - ((nextTrade.price - minPrice) / priceRange) * (canvas.height - 40);
                
                // Draw line connecting trades
                ctx.beginPath();
                ctx.moveTo(x, y1);
                ctx.lineTo(x + spacing, y2);
                
                // Color based on whether it's a buy or sell
                if (trade.isBuyerMaker) {
                    ctx.strokeStyle = 'rgba(220, 53, 69, 0.7)'; // Red for sells
                } else {
                    ctx.strokeStyle = 'rgba(40, 167, 69, 0.7)'; // Green for buys
                }
                
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw circle for trade point with size based on quantity
                const radius = Math.min(10, Math.max(3, Math.sqrt(trade.quantity) * 0.5));
                ctx.beginPath();
                ctx.arc(x, y1, radius, 0, Math.PI * 2);
                
                if (trade.isBuyerMaker) {
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.7)'; // Red for sells
                } else {
                    ctx.fillStyle = 'rgba(40, 167, 69, 0.7)'; // Green for buys
                }
                
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                x += spacing;
            }
        }
        
        analyzeMarketStructure() {
            if (!this.app.candles || this.app.candles.length < 50) return;
            
            const candles = this.app.candles;
            
            // Find swing highs and lows
            const swingHighs = [];
            const swingLows = [];
            
            const lookback = 3; // Number of candles to look back and forward
            
            for (let i = lookback; i < candles.length - lookback; i++) {
                // Check for swing high
                let isSwingHigh = true;
                for (let j = i - lookback; j <= i + lookback; j++) {
                    if (j === i) continue;
                    if (candles[j].high >= candles[i].high) {
                        isSwingHigh = false;
                        break;
                    }
                }
                
                if (isSwingHigh) {
                    swingHighs.push({ time: candles[i].time, price: candles[i].high });
                }
                
                // Check for swing low
                let isSwingLow = true;
                for (let j = i - lookback; j <= i + lookback; j++) {
                    if (j === i) continue;
                    if (candles[j].low <= candles[i].low) {
                        isSwingLow = false;
                        break;
                    }
                }
                
                if (isSwingLow) {
                    swingLows.push({ time: candles[i].time, price: candles[i].low });
                }
            }
            
            // Draw swing points on chart
            if (this.app.chartManager && this.app.chartManager.series && this.app.chartManager.series.candles) {
                const markers = [];
                
                swingHighs.forEach(high => {
                    markers.push({
                        time: high.time / 1000,
                        position: 'aboveBar',
                        color: 'rgba(220, 53, 69, 0.7)',
                        shape: 'arrowDown',
                        text: 'H'
                    });
                });
                
                swingLows.forEach(low => {
                    markers.push({
                        time: low.time / 1000,
                        position: 'belowBar',
                        color: 'rgba(40, 167, 69, 0.7)',
                        shape: 'arrowUp',
                        text: 'L'
                    });
                });
                
                this.app.chartManager.series.candles.setMarkers(markers);
            }
        }
        
        analyzeLiquidity() {
            if (!this.app.orderBook || !this.app.orderBook.bids || !this.app.orderBook.asks) return;
            
            const { bids, asks } = this.app.orderBook;
            
            // Find liquidity clusters
            const bidClusters = this.findLiquidityClusters(bids);
            const askClusters = this.findLiquidityClusters(asks);
            
            // Add horizontal lines at major liquidity levels
            if (this.app.chartManager && this.app.chartManager.chart) {
                // Implementation depends on your charting library
                console.log('Liquidity clusters identified:', { bidClusters, askClusters });
            }
        }
        
        findLiquidityClusters(levels) {
            if (!levels || levels.length === 0) return [];
            
            // Sort levels by price
            const sortedLevels = [...levels].sort((a, b) => a[0] - b[0]);
            
            // Group nearby levels
            const clusters = [];
            let currentCluster = { price: sortedLevels[0][0], volume: sortedLevels[0][1] };
            
            for (let i = 1; i < sortedLevels.length; i++) {
                const [price, volume] = sortedLevels[i];
                const prevPrice = sortedLevels[i-1][0];
                
                // If close to previous level, add to cluster
                if (Math.abs(price - prevPrice) / prevPrice < 0.001) { // 0.1% threshold
                    currentCluster.price = (currentCluster.price * currentCluster.volume + price * volume) / 
                                          (currentCluster.volume + volume); // Volume-weighted average price
                    currentCluster.volume += volume;
                } else {
                    // Start new cluster
                    clusters.push(currentCluster);
                    currentCluster = { price, volume };
                }
            }
            
            clusters.push(currentCluster);
            
            // Sort by volume and take top clusters
            return clusters.sort((a, b) => b.volume - a.volume).slice(0, 5);
        }
        
        fetchOptionsData() {
            // Simulate options data fetch
            setTimeout(() => {
                this.app.showNotification('Options data fetched successfully', 'success');
                // Process options data
                this.processOptionsData({
                    callsOpenInterest: [/* mock data */],
                    putsOpenInterest: [/* mock data */],
                    maxPain: 45000,
                    putCallRatio: 0.85
                });
            }, 1000);
        }
        
        processOptionsData(optionsData) {
            // Add options-related indicators to chart
            console.log('Processing options data:', optionsData);
            
            // Show max pain line on chart
            if (this.app.chartManager && this.app.chartManager.chart && optionsData.maxPain) {
                // Implementation depends on your charting library
                this.app.showNotification(`Max pain level: ${optionsData.maxPain}`, 'info');
            }
        }
    }
    
    class PantheonSystem {
        constructor() {
            // Initialize gods with their properties
            this.gods = {
                metatron: { power: 0, maxPower: 100, color: 'var(--metatron-color)' },
                uriel: { power: 0, maxPower: 100, color: 'var(--uriel-color)' },
                raphael: { power: 0, maxPower: 100, color: 'var(--raphael-color)' },
                gabriel: { power: 0, maxPower: 100, color: 'var(--gabriel-color)' },
                michael: { power: 0, maxPower: 100, color: 'var(--michael-color)' }
            };
            
            // Initialize abilities with cooldowns
            this.abilities = {
                revelation: { cooldown: 60000, lastUsed: 0 },
                valor: { cooldown: 45000, lastUsed: 0 },
                restoration: { cooldown: 30000, lastUsed: 0 }
            };
            
            // Initialize other properties
            this.effects = [];
            this.isInitialized = false;
            this.powerDecayRate = 0.1; // Saniyede %0.1 güç azalması
            this.lastDecayTime = Date.now();
            
            // Initialize the system
            this.init();
        }
        
        init() {
            if (this.isInitialized) return;
            
            // Kayıtlı güç değerlerini yükle
            this.loadPowers();
            
            // Arayüz olaylarını bağla
            this.bindEvents();
            
            // Görsel efektleri başlat
            this.initEffects();
            
            // Güç azaltma döngüsünü başlat
            this.decayLoop();
            
            this.isInitialized = true;
            console.log('Panteon Sistemi başlatıldı');
        }
        
        bindEvents() {
            // Kapatma butonu
            document.querySelector('.pantheon-close')?.addEventListener('click', (e) => {
                e.stopPropagation();
                const ui = document.getElementById('pantheon-ui');
                if (ui) {
                    ui.style.display = 'none';
                    localStorage.setItem('pantheonUIVisible', 'false');
                }
            });
            
            // Yetenek butonları
            Object.keys(this.abilities).forEach(abilityId => {
                const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
                if (abilityEl) {
                    abilityEl.addEventListener('click', () => this.activateAbility(abilityId));
                }
            });
            
            // Tanrı etkileşimleri
            document.querySelectorAll('.god').forEach(godEl => {
                const godName = godEl.dataset.god;
                if (godName && this.gods[godName]) {
                    godEl.addEventListener('click', () => this.onGodClick(godName));
                }
            });
        }
        
        loadPowers() {
            try {
                const savedPowers = JSON.parse(localStorage.getItem('pantheonPowers') || '{}');
                Object.keys(this.gods).forEach(godName => {
                    if (savedPowers[godName] !== undefined) {
                        this.gods[godName].power = Math.min(savedPowers[godName], this.gods[godName].maxPower);
                    }
                });
                this.updateUI();
            } catch (e) {
                console.error('Güç değerleri yüklenirken hata:', e);
            }
        }
        
        savePowers() {
            try {
                const powersToSave = {};
                Object.keys(this.gods).forEach(godName => {
                    powersToSave[godName] = this.gods[godName].power;
                });
                localStorage.setItem('pantheonPowers', JSON.stringify(powersToSave));
            } catch (e) {
                console.error('Güç değerleri kaydedilirken hata:', e);
            }
        }
        
        increasePantheonPower(godName, amount = 1) {
            if (!this.gods[godName]) return;
            
            const god = this.gods[godName];
            god.power = Math.min(god.power + amount, god.maxPower);
            
            // Özel efektler
            this.createPowerEffect(godName);
            
            // UI güncelle
            this.updateUI();
            
            // Kaydet
            this.savePowers();
            
            // Özel yetenekler
            this.checkSpecialAbilities(godName);
            
            return god.power;
        }
        
        checkSpecialAbilities(godName) {
            const god = this.gods[godName];
            if (!god) return;
            
            // %100 güç özel yeteneği
            if (god.power >= god.maxPower) {
                this.triggerElciSpecialAbility(godName);
                god.power = 0; // Gücü sıfırla
                this.updateUI();
                this.savePowers();
            }
        }
        
        triggerElciSpecialAbility(godName) {
            const abilities = {
                metatron: () => this.activateRevelation(),
                uriel: () => this.activateValor(),
                raphael: () => this.activateRestoration(),
                gabriel: () => this.activateCommunication(),
                michael: () => this.activateJudgment()
            };
            
            if (abilities[godName]) {
                abilities[godName]();
                this.showNotification(`${this.getGodDisplayName(godName)} özel yeteneği aktive edildi!`, 'success');
            }
        }
        
        activateRevelation() {
            // Tüm stratejilerin doğruluk oranını geçici olarak artır
            this.showNotification('Vahiy: Stratejilerin doğruluk oranı arttı!', 'info');
        }
        
        activateValor() {
            // Risk almayı artıran cesaret bonusu
            this.showNotification('Cesaret: Risk limitleri artırıldı!', 'info');
        }
        
        activateRestoration() {
            // Kayıpları telafi etme
            this.showNotification('Şifa: Kayıplar telafi ediliyor...', 'info');
        }
        
        activateCommunication() {
            // Haber ve veri akışını iyileştir
            this.showNotification('İletişim: Veri akışı optimize edildi!', 'info');
        }
        
        activateJudgment() {
            // Düşman pozisyonlarını ortaya çıkar
            this.showNotification('Yargı: Düşman pozisyonları tespit edildi!', 'warning');
        }
        
        activateAbility(abilityId) {
            const ability = this.abilities[abilityId];
            if (!ability) return;
            
            const now = Date.now();
            const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
            
            if (cooldownLeft > 0) {
                this.showNotification(`Bekleyin: ${(cooldownLeft/1000).toFixed(1)} saniye kaldı`, 'warning');
                return;
            }
            
            // Yeteneği etkinleştir
            ability.lastUsed = now;
            this.startCooldown(abilityId, ability.cooldown);
            
            // Yeteneğe özel işlemler
            switch(abilityId) {
                case 'revelation':
                    this.activateRevelation();
                    break;
                case 'valor':
                    this.activateValor();
                    break;
                case 'restoration':
                    this.activateRestoration();
                    break;
            }
        }
        
        startCooldown(abilityId, duration) {
            const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
            if (!abilityEl) return;
            
            const cooldownEl = abilityEl.querySelector('.ability-cooldown');
            if (!cooldownEl) return;
            
            abilityEl.classList.add('on-cooldown');
            cooldownEl.style.transition = `transform ${duration}ms linear`;
            cooldownEl.style.transform = 'scaleX(0)';
            
            // Animasyon bittiğinde sınıfı kaldır
            setTimeout(() => {
                abilityEl.classList.remove('on-cooldown');
                cooldownEl.style.transition = 'none';
                cooldownEl.style.transform = 'scaleX(1)';
                // Tarayıcıya stil değişikliğini işlemesi için kısa bir gecikme
                setTimeout(() => {
                    cooldownEl.style.transition = '';
                }, 10);
            }, duration);
        }
        
        onGodClick(godName) {
            // Tanrıya tıklandığında özel bir şeyler yap
            this.showNotification(`${this.getGodDisplayName(godName)} dinleniyor...`, 'info');
        }
        
        getGodDisplayName(godName) {
            const names = {
                metatron: 'Metatron',
                uriel: 'Uriel',
                raphael: 'Raphael',
                gabriel: 'Gabriel',
                michael: 'Michael'
            };
            return names[godName] || godName;
        }
        
        updateUI() {
            // Güç çubuklarını güncelle
            Object.entries(this.gods).forEach(([godName, god]) => {
                const powerEl = document.querySelector(`.god[data-god="${godName}"] .god-power`);
                const progressEl = document.querySelector(`.god[data-god="${godName}"] .god-progress-fill`);
                
                if (powerEl) {
                    powerEl.textContent = `${Math.round(god.power)}%`;
                }
                
                if (progressEl) {
                    const percentage = (god.power / god.maxPower) * 100;
                    progressEl.style.width = `${percentage}%`;
                    
                    // Güç seviyesine göre renk yoğunluğunu ayarla
                    const opacity = 0.3 + (percentage / 100 * 0.7);
                    progressEl.style.opacity = opacity;
                }
            });
            
            // Özel yetenek durumlarını güncelle
            this.updateAbilityStates();
        }
        
        updateAbilityStates() {
            const now = Date.now();
            
            Object.entries(this.abilities).forEach(([abilityId, ability]) => {
                const abilityEl = document.querySelector(`.ability[data-ability="${abilityId}"]`);
                if (!abilityEl) return;
                
                const cooldownLeft = (ability.lastUsed + ability.cooldown) - now;
                
                if (cooldownLeft > 0) {
                    // Bekleme süresi devam ediyor
                    abilityEl.classList.add('on-cooldown');
                    
                    // İlerleme çubuğunu güncelle
                    const progress = 1 - (cooldownLeft / ability.cooldown);
                    const cooldownEl = abilityEl.querySelector('.ability-cooldown');
                    if (cooldownEl) {
                        cooldownEl.style.transform = `scaleX(${progress})`;
                    }
                } else {
                    // Hazır
                    abilityEl.classList.remove('on-cooldown');
                }
            });
        }
        
        decayLoop() {
            const now = Date.now();
            const deltaTime = (now - this.lastDecayTime) / 1000; // Saniye cinsinden
            
            // Güç azalt
            Object.values(this.gods).forEach(god => {
                const decayAmount = this.powerDecayRate * deltaTime;
                god.power = Math.max(0, god.power - decayAmount);
            });
            
            this.lastDecayTime = now;
            this.updateUI();
            this.savePowers();
            
            // Her saniye güncelle
            setTimeout(() => this.decayLoop(), 1000);
        }
        
        createPowerEffect(godName) {
            const god = this.gods[godName];
            if (!god) return;
            
            const effect = {
                type: 'power-up',
                god: godName,
                x: Math.random() * window.innerWidth,
                y: window.innerHeight,
                size: 5 + Math.random() * 10,
                alpha: 0.8,
                speed: 1 + Math.random() * 3,
                life: 100,
                update: function() {
                    this.y -= this.speed;
                    this.life--;
                    return this.life > 0;
                },
                draw: function(ctx) {
                    ctx.save();
                    ctx.globalAlpha = this.alpha * (this.life / 100);
                    ctx.fillStyle = god.color;
                    
                    // Parçacık efekti
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Işık efekti
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.size * 3
                    );
                    gradient.addColorStop(0, `${god.color}80`);
                    gradient.addColorStop(1, `${god.color}00`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x - this.size * 3, this.y - this.size * 3, this.size * 6, this.size * 6);
                    
                    ctx.restore();
                }
            };
            
            this.effects.push(effect);
            
            // Maksimum efekt sayısını sınırla
            if (this.effects.length > 100) {
                this.effects.shift();
            }
        }
        
        initEffects() {
            const canvas = document.getElementById('effects-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Canvas boyutunu ayarla
            const resizeCanvas = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            };
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Animasyon döngüsü
            const animate = () => {
                // Temizle
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Efektleri güncelle ve çiz
                this.effects = this.effects.filter(effect => {
                    const isAlive = effect.update();
                    if (isAlive) {
                        effect.draw(ctx);
                    }
                    return isAlive;
                });
                
                requestAnimationFrame(animate);
            };
            
            animate();
        }
        
        showNotification(message, type = 'info') {
            // Mevcut bildirim sisteminizi kullanarak gösterin
            console.log(`[${type.toUpperCase()}] ${message}`);
            
            // Örnek bildirim oluşturma (mevcut sisteminize göre)
            if (window.app && typeof window.app.showNotification === 'function') {
                window.app.showNotification(message, type);
            } else {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                const container = document.getElementById('notifications-container') || document.body;
                container.appendChild(notification);
                
                // Otomatik kaldır
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 300);
                }, 5000);
            }
        }
    }
    
    /* =================================================================
       ENHANCED RISK MANAGEMENT SYSTEM
       ================================================================= */
    class EnhancedRiskManagement {
        constructor(app) {
            this.app = app;
            this.maxDrawdown = 0;
            this.historicalVolatility = 0;
            this.valueAtRisk = 0;
            this.riskAnalysisEnabled = false;
            this.dynamicPositionSizing = true;
            this.correlationMatrix = {};
            this.optimalLeverage = 1.0;
            this.volatilityThresholds = {
                low: 0.5,
                medium: 1.0,
                high: 2.0,
                extreme: 3.0
            };
            this.riskMetrics = {
                sharpeRatio: 0,
                sortinoRatio: 0,
                calmarRatio: 0,
                maxDrawdown: 0,
                winRate: 0,
                profitFactor: 0
            };
            
            this.init();
        }
        
        init() {
            this.calculateHistoricalMetrics();
            this.scheduleRiskUpdates();
            this.bindControls();
            
            console.log('Enhanced Risk Management System initialized');
        }
        
        bindControls() {
            // Add risk controls to settings panel
            const settingsContainer = document.getElementById('modal-features');
            
            if (settingsContainer) {
                const riskControlsHTML = `
                    <div class="settings-item">
                        <label for="dynamic-position-sizing">Dynamic Position Sizing</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="dynamic-position-sizing" ${this.dynamicPositionSizing ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    <div class="settings-item">
                        <label for="risk-analysis">Advanced Risk Analysis</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="risk-analysis" ${this.riskAnalysisEnabled ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                `;
                
                const riskDiv = document.createElement('div');
                riskDiv.className = 'settings-group';
                riskDiv.innerHTML = `<div class="panel-title">Risk Management</div>${riskControlsHTML}`;
                
                settingsContainer.appendChild(riskDiv);
                
                // Add event listeners
                document.getElementById('dynamic-position-sizing')?.addEventListener('change', (e) => {
                    this.dynamicPositionSizing = e.target.checked;
                    this.app.showNotification(`Dynamic position sizing ${e.target.checked ? 'enabled' : 'disabled'}`, 'info');
                });
                
                document.getElementById('risk-analysis')?.addEventListener('change', (e) => {
                    this.riskAnalysisEnabled = e.target.checked;
                    if (e.target.checked) {
                        this.calculateRiskMetrics();
                        this.app.showNotification('Advanced risk analysis enabled', 'info');
                    } else {
                        this.app.showNotification('Advanced risk analysis disabled', 'info');
                    }
                });
            }
        }
        
        calculateHistoricalMetrics() {
            if (!this.app.candles || this.app.candles.length < 30) return;
            
            const candles = this.app.candles;
            const returns = [];
            
            // Calculate daily returns
            for (let i = 1; i < candles.length; i++) {
                const prevClose = candles[i-1].close;
                const currentClose = candles[i].close;
                returns.push((currentClose - prevClose) / prevClose);
            }
            
            // Calculate historical volatility
            this.historicalVolatility = this.calculateStandardDeviation(returns) * Math.sqrt(365); // Annualized
            
            // Calculate maximum drawdown
            let peak = -Infinity;
            let maxDrawdown = 0;
            
            for (let i = 0; i < candles.length; i++) {
                if (candles[i].close > peak) {
                    peak = candles[i].close;
                } else {
                    const drawdown = (peak - candles[i].close) / peak;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);
                }
            }
            
            this.maxDrawdown = maxDrawdown;
            
            // Calculate VaR (Value at Risk)
            returns.sort((a, b) => a - b);
            const varIndex = Math.floor(returns.length * 0.05);
            this.valueAtRisk = Math.abs(returns[varIndex]);
            
            // Calculate optimal leverage based on volatility
            this.optimalLeverage = this.calculateOptimalLeverage();
        }
        
        calculateRiskMetrics() {
            if (!this.app.signals || this.app.signals.length < 5) return;
            
            const signals = this.app.signals;
            const returns = [];
            let wins = 0;
            let grossProfit = 0;
            let grossLoss = 0;
            
            // Process completed signals
            signals.filter(s => s.status === 'tp' || s.status === 'sl').forEach(signal => {
                const entryPrice = signal.price;
                const exitPrice = signal.exitPrice || entryPrice;
                const direction = signal.type === 'buy' ? 1 : -1;
                const returnPct = direction * (exitPrice - entryPrice) / entryPrice;
                
                returns.push(returnPct);
                
                if (returnPct > 0) {
                    wins++;
                    grossProfit += returnPct;
                } else {
                    grossLoss += Math.abs(returnPct);
                }
            });
            
            // Calculate metrics
            this.riskMetrics.winRate = signals.length > 0 ? wins / signals.length : 0;
            this.riskMetrics.profitFactor = grossLoss > 0 ? grossProfit / grossLoss : 0;
            
            // Calculate Sharpe Ratio
            const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
            const stdDev = this.calculateStandardDeviation(returns);
            this.riskMetrics.sharpeRatio = stdDev > 0 ? avgReturn / stdDev : 0;
            
            // Calculate Sortino Ratio (only negative returns for denominator)
            const negativeReturns = returns.filter(r => r < 0);
            const downside = this.calculateStandardDeviation(negativeReturns);
            this.riskMetrics.sortinoRatio = downside > 0 ? avgReturn / downside : 0;
            
            // Calculate Calmar Ratio
            this.riskMetrics.calmarRatio = this.maxDrawdown > 0 ? avgReturn / this.maxDrawdown : 0;
            
            console.log('Risk metrics calculated:', this.riskMetrics);
        }
        
        calculateStandardDeviation(array) {
            const n = array.length;
            if (n === 0) return 0;
            
            const mean = array.reduce((sum, val) => sum + val, 0) / n;
            const variance = array.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
            
            return Math.sqrt(variance);
        }
        
        calculateOptimalLeverage() {
            // Using Kelly Criterion for optimal leverage
            if (this.riskMetrics.winRate === 0) return 1.0;
            
            const winRate = this.riskMetrics.winRate;
            const avgWin = this.riskMetrics.profitFactor * (1 - winRate) / winRate;
            const avgLoss = 1;
            
            const kellyFraction = (winRate / avgLoss) - ((1 - winRate) / avgWin);
            return Math.max(0.5, Math.min(2.0, kellyFraction)); // Limit between 0.5x and 2x
        }
        
        getPositionSizing(baseSize) {
            if (!this.dynamicPositionSizing) return baseSize;
            
            // Adjust position size based on volatility and risk metrics
            let volatilityFactor = 1.0;
            
            if (this.historicalVolatility < this.volatilityThresholds.low) {
                volatilityFactor = 1.2; // Increase position size in low volatility
            } else if (this.historicalVolatility > this.volatilityThresholds.high) {
                volatilityFactor = 0.8; // Decrease position size in high volatility
            } else if (this.historicalVolatility > this.volatilityThresholds.extreme) {
                volatilityFactor = 0.5; // Significantly reduce position size in extreme volatility
            }
            
            // Adjust by win rate and profit factor
            let performanceFactor = 1.0;
            if (this.riskMetrics.winRate > 0.6 && this.riskMetrics.profitFactor > 1.5) {
                performanceFactor = 1.1; // Increase size when performing well
            } else if (this.riskMetrics.winRate < 0.4 || this.riskMetrics.profitFactor < 1.0) {
                performanceFactor = 0.9; // Decrease size when performing poorly
            }
            
            // Apply Kelly-based optimal leverage
            const leverageFactor = this.optimalLeverage;
            
            // Calculate final position size
            const adjustedSize = baseSize * volatilityFactor * performanceFactor * leverageFactor;
            
            return Math.max(baseSize * 0.5, Math.min(baseSize * 2.0, adjustedSize)); // Limit between 50%-200% of base size
        }
        
        scheduleRiskUpdates() {
            // Update risk metrics every 15 minutes
            setInterval(() => {
                if (this.riskAnalysisEnabled) {
                    this.calculateHistoricalMetrics();
                    this.calculateRiskMetrics();
                }
            }, 15 * 60 * 1000);
        }
        
        getCurrentRiskLevel() {
            // Determine current risk level based on volatility and metrics
            if (this.historicalVolatility > this.volatilityThresholds.extreme) {
                return 'extreme';
            } else if (this.historicalVolatility > this.volatilityThresholds.high) {
                return 'high';
            } else if (this.historicalVolatility > this.volatilityThresholds.medium) {
                return 'medium';
            } else {
                return 'low';
            }
        }
        
        getRiskReport() {
            return {
                riskLevel: this.getCurrentRiskLevel(),
                historicalVolatility: this.historicalVolatility,
                valueAtRisk: this.valueAtRisk,
                maxDrawdown: this.maxDrawdown,
                sharpeRatio: this.riskMetrics.sharpeRatio,
                sortinoRatio: this.riskMetrics.sortinoRatio,
                winRate: this.riskMetrics.winRate,
                profitFactor: this.riskMetrics.profitFactor,
                optimalLeverage: this.optimalLeverage
            };
        }
    }

</script>

<!-- Tüm sınıflar yüklendikten sonra sistemleri başlat -->
<script>
    // Tüm DOM yüklendiğinde sistemleri başlat
    document.addEventListener('DOMContentLoaded', function() {
        // PantheonSystem ve diğer sistemleri başlat
        window.panteon = new PantheonSystem();
        
        // Advanced Trading Visualization Manager
        window.advancedVisualizer = new AdvancedTradingVisualizer(window.app);
        
        // Enhanced Risk Management System
        window.riskManager = new EnhancedRiskManagement(window.app);
        
        console.log('Tüm sistemler başlatıldı ve hazır.');
    });
</script>

<!-- Advanced Notification Container -->
<div id="notifications-container" class="notifications"></div>

<!-- Notification History Modal -->
<div id="notification-history-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Bildirim Geçmişi</h3>
            <span class="close-modal">&times;</span>
        </div>
        <div class="modal-body">
            <div class="notification-filters">
                <button class="filter active" data-filter="all">Tümü</button>
                <button class="filter" data-filter="trade">İşlem</button>
                <button class="filter" data-filter="alert">Uyarı</button>
                <button class="filter" data-filter="success">Başarılı</button>
                <button class="filter" data-filter="error">Hata</button>
                <button class="filter" data-filter="system">Sistem</button>
            </div>
            <div id="notification-history-list"></div>
        </div>
        <div class="modal-footer">
            <button id="clear-notifications-history" class="btn btn-danger">Geçmişi Temizle</button>
        </div>
    </div>
</div>
</body>
</html>
